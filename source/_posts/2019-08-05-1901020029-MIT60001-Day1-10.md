---
title: 1901020029-MIT60001-Day1-10
date: 2019-08-05 19:12:07
tags: ['Python', 'MIT', '学习打卡']
categories: 'MIT60001'
---
### 学员信息
- 学号：1901020029
- 学习内容：MIT6.0001课程 1-10天打卡
- 学习用时：20小时

### 学习笔记
第一天：20190624
学习时间：3小时
学习内容：MIT Lecture 1
学习收获：
1、从上周开始学习MIT课程，Lecture1听了3遍，第一遍跟英文字幕，发现无法理解课程，后两遍跟中文字幕，尽可能理解课程讲解的内容。
2、陈述性知识：陈述事实。程序性知识：即配方，如何做。
3、什么是一个配方？包含简单的步骤、每一步被执行时的控制流、以及用什么方式停止程序。
4、计算器是固定程序的计算机，只会计算；电脑则是储存程序的计算机，可以进行机器存储和执行指令。
5、理解计算机的基本体系架构。
6、编程语言与英语语言类比：数字、字符串、简单的运算符就像英语里的单词，是编程语言的原始构件；原始构件的组合要符合语法结构，数字和字符串组合在一起会导致语法无效；编程语言只能有唯一的含义。
7、复习数据、对象（标量对象、非标量对象）类型、类型转换、打印命令、表达式、数值运算、=（赋值）的含义、变量这些基本概念。
遇到的难点：
1、英语仍是拦路虎，畏难心理有点严重。课程用中文字幕听完后，打开PPT来仔细阅读，还是有许多看不懂的地方。
2、psets 是 problem sets 的缩写吗？是问题集合的意思吗？
3、练习题1、2做完，第一次使用Spyder，练习题3的视频在打开时没注意，点成用默认的QuickTime player播放，对文件进行了转码，然后就遭遇意外无法打开。我尝试重新在钉钉上下载lecture文件，重新解压，依然无法解决此问题。

第二天：20190625
学习时间：2小时
学习内容：MIT Lecture 2
学习收获：
1、快速过一遍Lecture1pdf，读不懂的英文努力理解一下。
2、字符串对象类型包括字母、特殊字符、空格、数字；需要封装在双引号或单引号中；用+来连接，其中的空格必须用“ ”来实现；用 * num 来实现字符串的num次重复。
3、用print( )实现在控制台的输出，括号内的输出内容字符串需有引号，用+拼接的内容之间无空格，用，连接的内容之间显示空格。
4、用input(“ ”)进行人机交互，提示用户按引号内的内容输入并回车，将用户输入绑定到一个变量；默认用户输入为字符串类型，如果需要数字类型，需要转换。
5、对象类型之间可以用比较运算符连接成表达式，最后评估为布尔值，真或假。
6、控制流实现程序的分支。用if…、if…else…、if…elif…else…来实现。
7、for循环：知道迭代数量；能用break结束；使用一个计数器；用while循环可以重写一个for循环。
8、while循环：可无限数量的迭代；能用break结束；可以使用一个计数器但是必须在循环之前初始化计数器并在循环内部递增它；用for循环可能不能重写一个while循环。
疑问：
昨天想问，但忘记问了，这个课程的名称里6.0001的含义是什么？

第三天：20190626
学习时间：2小时
学习内容：MIT Lecture 3前半部分
学习收获：
1、逐渐理顺学习节奏，先用中文跟视频尽量理解，再仔细阅读pdf，消灭生词。
2、对字符串数据类型的处理：把其当作大小写敏感的字符序列；可以用运算符==、>、<等进行比较；可以用len( )函数检索字符串的长度；可以用[ ]索引到字符串内指定的位置；字符串不可以被修改。
3、其中关于字符串切割的例子 s [4：1：-2 ]，开始怎么也绕不明白，后来去查阅The Python Tutorial的讲解，终于明白了。
4、做随堂练习是检验自己到底懂没懂的最好方法，今天去公开课网站做前两个Lecture的IN-CLASS questions，发现虽然代码都尝试运行过，但是题还是会答错，说明原理并没有理解透彻。
5、践行“不耻下问”的结果很赞，前天关于psets的疑惑，问之前各种担心会不会太小白，会不会被笑话，结果得到了热心同学的解答，确定是问题集合后，也在想这个psets在哪里？今天在公开课网站上找到了ASSIGNMENTS里的psets，接下来要多多练习了。
6、这几天多看、多读、多想的结果就是真的不那么怕英语啦，能明显感觉到自己通过英语能理解的东西越来越多了。
7、小伙伴们一起来打卡啊，加油！

第四天：20190627
学习时间：2小时
学习内容：MIT Lecture 3后半部分
学习收获：
1、学习三种不同的算法，理解计算机如何帮助我们解决具体的问题。三种算法为猜测和检查、近似算法、以及二分搜索法。
2、近似算法是为了寻求一个足够好的答案，在求解立方根的例子中，给定一个epsilon变量，给定一个增量值increment变量，如果增量值过小会导致程序很慢但结果的准确度很高，如果增加epsilon范围，则会降低结果的准确度，但能更快得到答案。
3、二分搜索法老师以0-100之间的猜数游戏为例，讲解这样的求解方法可以快速降低搜索范围，以对数的形式降低猜测次数，不同于遍历每一个数据进行猜测的线性的猜测检查法和近似解决法，强大的二分法能更快速的获取答案。
4、几个用于理解不同算法的代码案例，反反复复看了很多遍，也运行了所有的代码，换不同的数据体验结果有何不同，感觉每看一遍都有不同的理解。

第五天：20190628
学习时间：2小时
学习内容：MIT Lecture 4前半部分
学习收获：
1、重点内容：结构化程序及隐藏的细节；函数；说明书；关键词return vs print；范围。
2、先用投影仪的例子来帮助我们理解编程中分解decomposition和抽象abstraction的概念。
3、超大型舞台需要很多台投影仪协同工作，每台投影仪的内部处理完全相同，但给每台投影仪输入不同的内容，最后不同的投影结果组合出完美的舞台成像。
4、好程序不是指更长的代码，而是能提供更多的功能。实现机制就是分解和抽象。
5、在编程中用分解创造结构。代码被分解成模块modules，模块是独立的、用于分解代码、计划重复使用、有组织的、连贯一致的。函数functions和类classes可以实现分解。
6、在编程中用抽象来隐藏细节。把一块代码理解为黑盒，不用管其内部细节，会看函数说明书或字符串文档，知道怎么用这块代码实现想要的功能就可以了。
7、可反复使用的代码块叫函数，函数在程序中不运行，除非函数被调用。
8、函数的特征：有名字、有参数（0或更多）、有说明文档（可选项但推荐有）、有主体、返回某物。

第六天：20190629
学习时间：1小时
学习内容：MIT Lecture 4后半部分
学习收获：
1、理解变量作用域，嵌套的变量作用域例子有点绕不清。
2、当函数被调用时，形参被绑定到实参的值。
3、当进入一个函数，新作用域/框架/环境创造出来。
4、作用域是对象名称的映射。
5、程序先列出全局变量，函数的值是一些代码，然后是各个变量的值，当变量在调用函数时，就进入被调用函数的局部变量作用域，程序开始列出函数内部的变量，直到函数的返回值，这个函数的返回值回到主程序的函数变量里。
6、没有return陈述的一个警告：如果函数没有return陈述，python返回值None。

第七天：20190630
学习时间：30min
学习内容：MIT Lecture 5前半部分
学习收获：
1、理解两个新的数据类型：元组 ( ) 和列表 [ ]。
2、元组一旦创建其值不可更改；列表的值是可变的。
3、元组和列表的元素可以像字符串一样进行索引、定位、切割等。
4、列表的值可改变这一点使列表对象非常有用。
5、添加列表元素用L.append（element）
6、只是听课（跟中文字幕）来理解课程有点困难，周末时间严重不够用。
7、感觉前几课的内容因为训练营突击学习过，大概了解最基础概念，听课程加看pdf能比较好理解，今天的感觉到吃力，后续学习是应该继续跟课程，先听一遍下来，还是巩固复习前面的内容，花时间做练习，彻底搞懂再继续？感觉自己又犯了究细节的毛病，而忘记了全面和完整，听不懂也应该先听一遍不是吗？但是最大的难点在于不懂如何写收获。

第八天：20190701
学习时间：3小时
学习内容：MIT Lecture 5视频前30min + PPT（p1-p16）
学习收获：
1、重新复习元组、列表这两个复合数据类型。昨晚只是跟字幕听视频感觉头脑很混乱，今天放慢速度，边听边看pdf，做到理解内容。
2、元组：有序的元素序列，可以混合不同的元素类型；不能改变元素的值，同字符串一样，一旦创建是不可变的；用( )代表元组。
3、注意：元组 t = (2,“mit”,3）经t [1:2]切割后值为(“mit”, ）这里额外的逗号意味着它是一个元素的元组，而不是字符串。
4、元组用于替换两个变量的值非常方便，(x,y)=(y,x)一行代码即可实现。否则想替换变量x、y的值，必须设置一个临时变量才能实现。
5、利用元组可以实现从函数中返回多个值。
6、元组中嵌套元组元素，进行遍历元组数据，对处理真实世界的数据非常有用。这点需要运行代码实例才比较好理解元组实现的功能。
7、列表是有序的信息序列，可索引；用[ ]表示；通常包含同类元素，也可以包含混合的元素；列表是可改变的。
8、像字符串一样，可以用更pythonic的语言来遍历列表，计算列表元素的总和。for i in L：
9、有关列表的操作：
用L.append(element)实现在列表L后添加element；
用+实现两个列表的组合；
用L.extend(some_list)实现在列表后扩展一些清单；
用del(L[index])删除索引位置的元素；
用L.pop( )实现返回列表的最末尾元素，并将L改变为去除最末尾元素的新列表；
用L.remove(element)实现查找第一个出现的element，并去除它，如果元素不存在，则报错。
10、列表与字符串之间的互转：
用list(s)实现将字符串s的每个字符转变为列表元素；
用s.split( )实现在字符串中某个字符处将其分解为两个元素的列表；
用‘ ’.join(L)实现将列表L转变为字符串;
用’’.join(L)实现在转变为字符串的字符之间添加
用sorted(L)实现对列表L的排序，列表L没有改变；
用L.sort( )实现对列表L的排序，列表L改变；
用L.reverse( )实现对列表L的反转，列表L改变。
心得：
1、心静下来，理解力明显上升。
2、视频中的代码示例一定要亲自运行，并修改数据来试验结果，有助于提高对代码的理解。
3、遇到中文字幕拗口不好理解时，配合pdf来理解效果更佳。

第九天：20190702
学习时间：2小时
学习内容：MIT Lecture 5后10min + PPT(p16-24)
学习收获：
1、列表对象具有可变性，不同于字符串、元组等不可变对象。
2、变量名仅是贴在对象上的标签，对象变了，指向对象的标签都受影响。
3、用列表对象进行具体操作时会产生某些副作用。
4、理解别名现象，比如warm和hot指向同一个列表对象，使用append()函数改变hot变量时，warm变量也改变了。
5、针对列表可变性，克隆列表是很有用的方法。用[:]实现，比如hot= warm[:]，这样改变hot时，warm仍是原来的列表对象。
6、对列表排序调用sort()函数改变列表，返回None；调用sorted()函数不改变列表，但必须分配值给变量。
7、列表嵌套列表，在实际工作中要时刻注意副作用的问题。
8、做exercise。

第十天：20190703
学习时间：2小时
学习内容：MIT Lecture 6（主题：递归，字典）前10min + PPT(p1-p13)
学习收获：
1、老师换成了Eric Grimson，一下有点不适应。
2、理解递归RECURSION，是把规模大的问题转化为规模小的相似的子问题来解决。在函数中，就产生了函数调用它自身的情况。此外，这个解决问题的函数必须有结束条件，否则会产生无限递归。
3、之前已经学了循环结构(for、while)来迭代算法，按照一套状态变量在每次迭代循环时更新来捕获计算。
4、举例：展示乘法a*b和计算阶乘n！分别用迭代求解方案和递归求解方案是如何一步步实现的，学习递归的解题思维。
5、时间主要花在网上阅读有关递归的文章，帮助理解递归的思想。