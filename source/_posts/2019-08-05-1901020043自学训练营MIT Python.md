---
title: 1901020043-MIT60001-LECTURE3-2
date: 2019-08-05
tags: ['Python', 'MIT', '学习打卡']
categories: 'MIT60001'
---

### 学员信息

- 学    号: 1901020043
- 学习内容: MIT 6.0001 LECTURE 3+Python编程导论（第2版）（第3章）
- 学习用时: 4小时

### 学习笔记

收获总结：

1. 近似解位于实际解附近的一个常数范围内，这个常数我们成为epsilon。

2. 穷举法程序会运行多长时间？迭代的次数依赖于答案与0的距离以及步长，大致来说程序会执行while循环最多x/step次。step设定太小，程序运行时间过长，设定太大，会略过适合的答案。

3. 二分查找是每一步都将查找空间分为两部分，二分查找是对穷举算法的一个重大改进，穷举算法只能在每次迭代后将查找空间缩小一部分。

4. 用==比较两个浮点数会产生不可思议的结果，更好的做法是看看两个浮点数是否足够接近，而不是比较两个浮点数是否相等。e.g. abs(x-y) <0.0001比x==y更好。

5. 最常用的近似算法是牛顿-拉弗森法，如果存在一个值guess是多项式p的根的近似值，那么guess-p(guess)/p'(guess)就是一个更好的近似值，p'是p的一次导数。

6. 仔细体悟穷举算法、二分查找法、牛顿法求立方根的思路。

遇到的问题和解决方法：尚未编写程序比较三种算法的效率。
