<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019-09-11901100295-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A020%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[title date tags categories 11901100295-自学训练营学习20群-自我介绍 2019年9月19日 22:57 Python入门 自我介绍 基本信息 姓名：李西峰 学号：11901100295 工作背景 12年毕业参加工作，从事测绘工程行业5年有余。17年下旬辞职，为直接找工作，在家发呆1年左右。后转行进入电商行业，从事一年基础工作后辞职。19年4月独自开始网上接单拍摄项目至今。 自我介绍 92年生人，现阶段工作与编程无直接关联，觉得应该挤出些时间学习一下计算机思维，顺便重新学英语。以前摄影是爱好，现在摄影是工作。把爱好当工作之后，或许应该再培养一个爱好，选编程吧。 第一次使用Markdown语言编写帖子，试试插入一张个人近照吧 如果7年就是一辈子的话，那今年是新生元年。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day11%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day11学习心得date: 2019-09-23tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day11 学习心得 在使用pip安装第三方库的时候非常顺畅，没有出现卡壳，重点在于学习使用第三方库，每个库我都学习的不是很深刻，还需要后续的好好深入研究，要用一生来学习编程，我的时间预算很充足。 现在学习编程还是没形成规律，要每天都都写点代码要不然手生。 学习的时候最重要的还是耐心，耐心读完英文，要养成直接接触第一手消息，阅读英文的习。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day10%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day10学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day10 学习心得 使用pip安装第三方库的时候出现了比较大的问题，主要就是上次使用pycharm学习python时候的那个pip已经毁坏，但是我也没找到anaconda目录下的pip,所以一直导致安装失败。 后来，经过教练的远程辅导以及自己的网上搜索解决了这个问题，心中有莫大的成就感。 这里有一个对我来说非常重要的文章删除列表中满足一定条件的元素]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day1%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day1学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day1 学习心得 通过使用GitHub来进行协作，学会一个重要的协作方式。 在本地电脑的hello-world仓库中创建名为local.txt文本文件，是出现了一点小问题，经过与教练的沟通，顺利解决。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day2%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day2学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day2 学习心得 下载Anaconda，刚拿到任务的时候，我就做完了。但是，下面一步，在VS Code的中配置Python环境，我花了好长时间。 原因是VS Code中有中文字符，并非全英文，所以，按照教程进行操作，会有一些不懂的地方。 最后，在网上提交的一些issue中，我找到了答案。然后完成了python环境的配置。后来进行得就很快了。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day3%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day3学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day3 学习心得 前段时间因为个人私事，中断了学习，导致再从第3天开始学习的时候，必须把前两天的知识全部看完，真是用进废退啊，必须坚持学完，不能中途中断。 在学习的时候，使用input函数，无法进行输入，通过Google之后找到了解决答案。 对于一个简单的计算器程序，自己毫无头脑，在Google上参考了别人的案例，然后自己一点点理解之后进行了，模仿学习。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day4%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day4学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day4 学习心得 每天都没有大块的时间用来学编程，都是用零散的时间来学习编程，所以这一课学了两天。 在阅读文档的时候因为文档不太好读，花费了好多时间，几乎都是翻译一点，理解一点。 这个编程是自己完完全全编出来的，并没有参考任何的网上案例，在跑通那一瞬间，心里的成就感爆棚。增加了自己对for循环和while循环的理解。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day5%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day5学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day5 学习心得 拖延了好几周才重新拾起来，一定不要拖延，拖延会使得前功尽弃。 学习了字符串，列表，数组，集合，字典，原组等数据容器。加深对这些数据容器的操作方法的理解。 在编码过程中有好多地方都不太明白，但是，在作业库上借鉴了同学的作业以后，可以有一些很好的思路。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day6%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day6学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day6 学习心得 第一个任务与第五天的任务2差不多，简单做一下函数封装就可以了 第二个任务中，在中文分词的时候出现一点小困难，后来，将中文字符串全部清洗以后，问题就解决了。 还是要多多加油。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day7%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day7学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day7 学习心得 今天的任务不是很难，仅仅是对上一天的任务的整理，最主要的是调用模块，这个问题还需要深入的讨论。 在提交pr的时候出现了一点小问题，因为自己的粗心，忘记了一个按钮，经过教练的指导学会了，开心。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day8%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day8学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day8 学习心得 今天的作业主要是在昨天的基础上加了一个异常处理，所以前一天的作业很关键，一定要做的透彻一点，今天的作业才能做得比较好。 虽然完成作业，但是英文的官方文档还是阅读的不太熟练，现在只能慢慢花时间弄清楚每一句英文的意思。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-day9%E6%89%93%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营3群-Python入门day9学习心得date: 2019-09-12tags: [‘Python’, ‘自学营’,’学习心得’] categories: ‘学习心得’学员信息 学号：1901040001 学习内容：Python入门day9 学习心得 今天，学习的是python自带的标准库，学的还是比较顺畅。 学习时间不能集中进行，还是应该更加专心，心无旁骛。 继续加油。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-%E5%AD%A6%E4%B9%A0Markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习Markdown语法 标题用#来代表标题的级数，#越多，标题级数越高，最多可设六级标题。 字体加粗：我爱你斜体：我爱你加粗和斜体：我爱你删除线：我爱你 段落Markdown段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 引用在引用的内容前面加一个&gt;即可，多加一个&gt;即表示多级引用。 “青泥何盘盘，百步九折萦岩峦。” 分割线三个或三个以上的-或*，即代表分割线。 列表 无序列表：使用+/-/*任意一个，后面接一个空格，后面再接所写内容。 有序列表：使用1./2./3.等，后面接一个空格，后面再接所写内容。 列表嵌套：两个同级表格，在第二个表格前面敲三个空格即可。 表格 学号 姓名 职务 01 刘备 主公 02 关羽 忠臣 03 张飞 忠臣 8. 超链接 超链接名 9. 图片 略 **** 我爱python]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F1901040001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A03%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[title: 1901040001-自学训练营学习3群-自我介绍date: 2019-09-12 22:31:07tags: [‘Python入门’] categories: ‘自我介绍’基本信息姓名：夏聪聪学号：1901040001工作背景：研究生在读（材料加工领域）自我介绍：不是计算机科班出身，但是对编程有很大兴趣，希望成为一名编程高手。]]></content>
  </entry>
  <entry>
    <title><![CDATA[1901100371-自学训练营学习21群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100371-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A021%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：阿申学号：1901100371 工作背景目前从事oracle dba相关的工作 自我介绍大学学的电子信息工程专业，毕业后投身IT，曾经幻想过做一名码农，但阴差阳错的进了dba这个坑，无奈技术更新迭代如此迅速，需要活到老学到老，只能暗自充电，希望不被人工智能革了命。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
        <tag>DBA</tag>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100139-自学训练营17群-Python入门学习心得]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901100139-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A517%E7%BE%A4-Python%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100139 学习内容：Python入门 学习心得 自学是一门技术，在这次python入门的学习中，我想也了解了对我来说非常有用的学习编程的心得： 了解语言 很简单，学习一门语言或者技术之前先了解它是做什么的，每一个语言都有自己的优势与劣势，都有自己最擅长的领域，就和每一个人一样都有自己的优点，每一个人都不能说自己所有的事情都能做，编程语言也一样的。 学习和模仿 软件开发不同于其他行业，其他行业你可能需要特定的设备和特定的老师，但我们编程学习的优势就在于：无论何时何地只要你有一台能联网的电脑，就可以开启编程之路，当你有任何问题的时候，你几乎都可以在网上寻找答案并且网上还会有大量的教程，你都可以通过不同的方式找到它，最初或许比较困难，慢慢的你会发现自己检索能力得到提升，当你知道语言是什么、它的helloworld怎么写的时候，你就走过了第一步，接下来你需要做的就是在课程老师的带领下模仿老师的代码，理解老师编写代码的思路自己再编写一遍，在自己编写的过程中，你会发现很多小错误，改掉这些小错误会令你进步飞速。 大量练习和实践 在我看来没有什么方法比练习能让你有更快的进步。如果你只是去看而不去编写和实践，那过不了多久这门语言就会变更成路人，也就是与你擦肩而过。为什么这么说，为你不实践你就只会有短暂记忆。这也是做任何事情最最重要的，不仅限于编程，你见过只听英语的人自己从来不讲，然后摇身一变就能突然讲出流利的英语么？或许有这样的天才，但那真的几乎只有极少数的人，我相信我们大多数人都必须通过努力和练习，去收获我们的成果。 以上三点仅仅是我再自学过程中所体会的,希望能对大家有帮助，学习一直在路上。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100296-自学训练营学习20群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100296-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A020%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：灵越学号：1901100296 工作背景09年开始从事测试及相关工作16年离开IT行业转入瑜伽行业现如今是一名瑜伽老师 自我介绍​ 大学时候学习过Java开发，工作一直做的测试和管理相关的工作，随着时间和人际关系的处理消磨了自己对于计算机行业的激情，转行进入瑜伽行业做起了一名瑜伽老师。体验了3年的瑜伽教学生涯还是惦记着IT行业，最起码比瑜伽老师挣钱吧，所以自己开始学习Python开发，等待自己的回归。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100240-自学训练营学习19群-python入门14天总结]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901100240-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A019%E7%BE%A4-python%E5%85%A5%E9%97%A814%E5%A4%A9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[课程总结Github除编译器之外的重要协作软件Github，其功能类似于编程版本的Google Doc，可以允许多人同时编程。 对每段更改保有历史记录，可回溯任意更改，避免代码被覆盖，且可回溯任意版本。 Github建立在分支架构之上，主分支负责程序主体，dev分支则可供个人修改使用。个人修改的程序可通过pull request请求并入主分支。此功能保证多人同时协作的同时，亦可以避免程序被个人错误更改。 通过folk加入其他repository，通过clone下载到本地，通过commit讲更改提交到主分支，通过pull request将修改提交。 Python 编译器Anaconda-Navigator 综合了数个python编译器。 Visual Studio Code适合快速编译python shell内容，界面视觉效果较好。Spyder适合做短代码测试，界面一般。 Visual Studio Cose 和 Spyder 保存的代码可以自动同步，方便转换。 在python shell中需要print将数值显示，否则默认隐藏。 Hello Word约定俗称的语言入门所编写的第一个程序。 Print作为python输出，在python shell内不print的内容默认隐藏。 print时以’/t’控制同行空格打印。 print时以’’换新的一行。 结构类型有字典（dictionary），元组(tuple)，列表(list)等储存单位。 元组和列表是以位置储存元素，位置0对应第一元素，位置1对应第二元素，构成元素和位置一一对应的关系。 字典是以key和item进行一一对应。 元组内部数据无法更改。 字典用于统计数字较为方便。 循环for loop 和 while loop是最常用的两种循环模式。 for loop不仅可以进行数字循环，也可以进行列表中元素的循环。 while loop可以通过 while True 不断循环直到达成条件break。 break会跳出最内层的循环。 当过多循环减慢速度时，可采用numpy替代。 try…except阻止程序进入error，可保证代码继续运行。 可暂时忽略无效代码。 配合try…except然后print，可进行debuging。 Debugbug可以双轴分为四象限：横轴为显性，隐性；纵轴为持续性，间歇性。 隐性bug比显性bug危险，间歇性bug比持续性危险。 显性bug程序会直接报错，易于发现；隐性bug程序不会报错，但输出结果与预期不符，更难发现。 持续性bug每次运行都会出现，间歇性只会在特殊情况下出现。 千年虫既为典型隐性间歇性bug。 Debug过程，需要讲代码分为不同模块，检测不同模块结果，发现模块结果错误既修改之。 修改单一模块后，仍需整体运行以保证输出正确。 排序计算机编程的重要组成部分。 不同的排序方式会产生巨大的速度差别。 模块将已经编写好的代码作为模块保存，可以在其他程序中进行调用。 调用所需时间较长。 可使得程序简洁明了。 画图画图逻辑与matlab相似。 需要导入matplotlib包函数。 处理速度相对较慢。 matplotlib包本身不支持中文，故需要通过一下代码导入中文： lt.rcParams[‘font.family’] = [‘sans-serif’] plt.rcParams[‘font.sans-serif’] = [‘SimHei’] yagmail可进行收发邮件，配合try..except使用，可保证在程序出错时迅速收到提醒。 邮件发送前邮箱需要授权Pop/SMTP。 授权后以授权码代替密码。 getpass默认隐藏密码，输入不可见。 yagmail.SMTP()中host需要输入，否则出现超时错误。 getpass可用于获取密码，其特点为密码会呈现不可见状态，以保护密码安全。 wxpy微信外链程序，可编写自动回复脚本。 基于webweixin进行，有可能被微信web封号。 jieba中文分词包，其共嫩建立在内含的词典之上。 可通过jieba进行词频统计。 jieba输出为不可见的list形式。 自学相关凡是知道方向，大部分问题都可通过搜索引擎解决。 寻找方向是自学的关键。 自定一个Project，以解决问题的形式进行学习，倒逼学习相关知识。 自学可能产生回音室效应，产生自循环，也就是倾向于用已知知识解决新问题，因此需要时时与他人对比。 部分问题已经有人做出更好解答，不可迷恋自身能力。 相对于系统化学习，可能漏过部分基础，使得无知于某些高效解决方案。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100240-自学训练营学习19群-python入门打卡心得]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901100240-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A019%E7%BE%A4-python%E5%85%A5%E9%97%A8%E6%89%93%E5%8D%A1%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息学号：1901100240 day1 学习内容：下载使用Github 学习用时：3小时 收获总结 除编译器之外的重要协作软件Github，其功能类似于编程版本的Google Doc，可以允许多人同时编程。 对每段更改保有历史记录，可回溯任意更改，避免代码被覆盖，且可回溯任意版本 Github建立在分支架构之上，主分支负责程序主体，dev分支则可供个人修改使用。个人修改的程序可通过pull request请求并入主分支。此功能保证多人同时协作的同时，亦可以避免程序被个人错误更改。 通过folk加入其他repository，通过clone下载到本地，通过commit讲更改提交到主分支，通过pull request将修改提交 遇到的难点与问题（是否解决） 对Github整体构架及操作目的了解不足 （已解决） 对本地及云端操作可能产生的覆盖记录问题有所担忧 （已解决） day2 学习内容：安装Visual Studio Code 并编写程序 ‘hello world’ 学习用时：1小时 收获总结 Anaconda-Navigator 综合了数个python编译器 Visual Studio Code适合快速编译python shell内容，界面视觉效果较好。Spyder适合做短代码测试，界面一般 Visual Studio Cose 和 Spyder 保存的代码可以自动同步，方便转换 在python shell中需要print将数值显示，否则默认隐藏 遇到的难点与问题（是否解决） Visual Studio Code 安装以及配置问题（已经解决） Visual Studio Code 界面熟悉 （已经解决） day3 学习内容： 编写计算器 学习用时：0.5小时 收获总结 以try except保证输入是数字 遇到的难点与问题（是否解决） 无 day4 学习内容： 打印99乘法表 学习用时：0.5小时 收获总结 print时以’/t’控制同行空格打印 print时以’’换新的一行 遇到的难点与问题（是否解决） 无 day5 学习内容： 字符串，list，字典操作 学习用时：2小时 收获总结 list操作可采用内嵌函数进行 英文分词可采用re包，re.split进行 re.split时需要注意去除特殊符号 字典的排序采用sorted(X.items(),key=lambda X:X[1],reverse=True) 遇到的难点与问题（是否解决） 无 day6 学习内容：词频统计以及注释 学习用时：3小时 收获总结 使用符号’#’进行注释，规则为解释代码目的写在代码前一行，解释变量现在代码同行 汉语分词逻辑与英语不同，无空格区分，故无法采用re.split 汉语可使用list进行分字，再删除后续标点符号 遇到的难点与问题（是否解决） 无 day7 学习内容： 模块及调用 学习用时：3小时 收获总结 模块调用同样采用import 区分中英文需要先将字符串转为utf-8，分别取其中中英文赋值范围（可与网页搜索），再转换成原字符串 字符串生成需要采用生成器 遇到的难点与问题（是否解决） 中英文区分问题（已解决） day8 学习内容： try except，final，raise的理解及应用 学习用时：0.5小时 收获总结 通过try except避免error使得程序继续运行 遇到的难点与问题（是否解决） 无 day9 学习内容： Counter函数的调用和词频统计 学习用时：1.5小时 收获总结 import文件时路径是关键因素 路径分绝对路径和相对路径 Counter函数的调用和dict统计的对比并未有明显优势 遇到的难点与问题（是否解决） 无 day10 学习内容： jieba，第三方模块的安装和调用 学习用时：2小时 收获总结 通过jieba进行词频统计 jieba输出为不可见的list形式 遇到的难点与问题（是否解决） 中文分词问题（已解决） day11 学习内容： yagmail(邮箱库)、 requests(⽹网络请求库)和 pyquery使用 学习用时：4小时 收获总结 邮件发送前邮箱需要授权Pop/SMTP 授权后以授权码代替密码 getpass默认隐藏密码，输入不可见 yagmail.SMTP()中host需要输入，否则出现超时错误 遇到的难点与问题（是否解决） 邮件发送问题，网络设置（已解决） day12 学习内容： 微信自动聊天程序wxpy使用 学习用时：3小时 收获总结 微信外链的使用 遇到的难点与问题（是否解决） 微信被封问题 day13 学习内容： matplotlib，numpy的使用 学习用时：2小时 收获总结 matplotlib不支持中文，会显示乱码。 通过代码”lt.rcParams[‘font.family’] = [‘sans-serif’] plt.rcParams[‘font.sans-serif’] = [‘SimHei’]”以允许标题等采用中文 遇到的难点与问题（是否解决） 无]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100231-自学训练营18群-Python入门学习心得]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901100231-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A518%E7%BE%A4-Python%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100231 学习内容：Python入门 Python自学感悟 &emsp;&emsp;作为一名此前通过看书对C有过些许涉猎的程序菜鸟，我早已听闻Python的大名，但出于各种原因始终没能开始对Python的学习。作为一名准大学生，在这人生中少有的长假里，终于下定了决心，报了Python自学训练营开始了对Python的学习。&emsp;&emsp;市面上关于Python学习的教材铺天盖地，颇有乱花渐欲迷人眼之感。那么，为什么要通过这种方式来学习呢？尤其是考虑到市面上的选择何其之多。选择这种方式的本意，只是出于对自身积极性的不自信，想借外在的监督督促自己完成对Python的学习。但是在具体的学习过程中，却产生了不少的感悟，收获了意外之喜。 “拼积木” 编程是什么呢？编程语言，既然有语言二字，说白了功能就是用来交流。计算机的算力远超过人脑，而为了利用这强大的算力，我们必须和计算机进行交流，让不明白人类语言的计算机能够听从我们的命令，实现我们的目的。编程语言就是专门用于和计算机交流的语言，而利用这种语言的过程，可以简单看成是在“拼积木”。 在自学营中，每一次的任务都要经由两个步骤完成：阅读参考资料，然后就参考资料的内容进行组合，直到实现任务目标。这一“拼积木”的过程看似稀松平常，毕竟我们日常生活中使用的语言也可以看作是一个个的词语由一定的语法规则拼搭出的“积木”。但是日常语言使用的频繁让我们忽略了这么一个事实：同样一个意思，用不同的语气、语速、语句表达，会有截然不同的效果，不恰当的表达方式有时还会弄巧成拙。很多人其实都知道这个道理，但是真正会在平日里关注这一点的人，除了行业要求或经历使然，又有多少是完全自觉地关注语言表达的效率和艺术呢？而自学过程中信息的极度简约——只有“积木块”，拼搭积木的方式要由学员自己独立思考，这就使得平日里被忽略的事物重新被我们所思考。 在与计算机交流的过程中，我们写下的每一个语句都清晰地摆在面前，随时可供改进与修改。正如写作有助于将人脑中纷乱的思绪得以整理，编程这一对积木进行拼搭的过程不由得使我们开始思考，每一种拼搭方式的优与劣，每种完成积木拼搭的可能性。将任务像拼搭积木一样分割成小块分别解决，以及思考改进拼搭的方法，这是不仅有利于编程，还是能在日常生活中持续发挥作用的宝贵思维工具。 试探边界 正如上文所说，编程可以被看做是一种积木的拼搭，只是缺少图纸，拼搭的效果完全取决于编程者本人。方法总比困难多，虽说很像是摸着石头过河，但迟早可以到达彼岸，只是耗时多少的问题。而在这一过程中，总少不了试探。对于编程来说，一次次的调试，都是为了最终掌握某语句用法必不可少的试探。 相比于学习其他技能，编程的试错成本相当低，以至于自学者可以就参考资料中的例子进行大胆的猜想和尝试，直到最终摸清边界，掌握用法。这不仅适用于编程，学习其他技能也同样需要这样试错的心态。举个亲身经历的例子，我在学习游泳和骑自行车时，一开始总是束手束脚，但当我学会浮水，学会防止摔跤——最大化降低试探的成本之后，我便可以开始肆意的试错，直到最终掌握这两项技能的要领。生活，就是对世界的一次次试探，直到找到与外界和睦共处的那个舒适点啊。 以任务为中心 Python语言本身自带的模块中有很多功能，这些功能林林总总，花样繁多。老实说，在具体开始动手尝试之前，看到这数目繁多的用法实在是令人不免有些头痛。此外，相较于程序调试，阅览各种模块各种函数的用法实在是枯燥得多。这个问题其实很好解决，因为编程语言学习的目的是使用，根据要完成的目的去寻找解决问题的方法是有趣得多也高效得多的学习方式。 事实上，作为初学者，很多进阶的用法其实并没有必要掌握。有时候，对某种函数的部分掌握就足以解决现有的问题。编程本身就是为了利用电脑的算力解决问题，只要有具体的问题，围绕解决问题展开对编程的学习，即使没有掌握百分百的技能，但也已培养了解决大多数问题的能力。这个世界有太多信息，远超人力所能掌握，有些函数、模块的用法若是从未遇到有特定任务需求，不能掌握也无伤大雅。学会做减法，能让很多事情变得更加轻松。就好像我们身为中国人，但不是所有方块字都要求必须掌握。翻开康熙字典，多的是真实存在但几乎从未被我们所知的汉字。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090017-自学训练营8群-Python入门学习心得]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901090017-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A58%E7%BE%A4-Python%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901090017 学习内容：Python入门 学习心得 自学是一门手艺，手艺的关键在于熟能生巧，熟的关键在于勤学、勤练、勤记，总之切忌偷懒 决定自学一门技能，有几个问题需要考虑： 是否能够承受学习的时间成本，如果根本没时间学，浅尝辄止=浪费自己的时间； 自学考验自我管理的能力，尤其是短期内看不到收益的时候，如何说服自己坚持下去？我觉得找到合适的组织，并肩作战的小伙伴，有耐心有热情教学的教练是我能自学下去的巨大的动力来源，但最终还是要靠自己，要相信自己； 要努力从自学中找到乐趣。刚开始接触编程的时候感觉举步维艰，多次放弃。后来随着知识的增长，逐渐体会到了学习编程的乐趣，是让我坚持下去的一个理由。 接下来马上要进入数据营学习了，下面总结一下在入门营中做的不够好和需要改进的地方： 聪明的提问：刚开始不知道怎么提问题，有时候卡在一个问题上瞎琢磨浪费了很多时间，后来发现不管问什么问题教练都会给予耐心指导，所以到后期有点儿偷懒了，有的问题本来应该自己思考一下的，但是没有思考就直接让教练帮忙，这一点不好。 不总结不打卡：就是懒 。 加强记忆和总结归纳。 遇到困难不要怕，干就是了。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1900100068-自学训练营学习15群-PYthon入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1900100068-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A015%E7%BE%A4-PYthon%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 学号：&lt;1900100068&gt; 学习内容：Python入门 学习笔记 day01 学习内容：github使用 学习用时：6h 总结：&emsp;&emsp;万事开头难，只是google的翻译选项就找了半天，另外感觉英语不好真要命啊，还好有教练，很负责，耐心解答。虽然按照说明操作了一遍但对于真正理解并烂熟于心还有很大差距，过程当中也遇到了不少阻力，一度怀疑自己太笨基础太差不适合学习这个，可最终还是突破了自己坚持了下来，相信以后会越来越顺利，加油！ day02 学习内容：配置本地运行开发环境 学习时长：大约3h 总结：&emsp;&emsp;本次学习间隔时间稍长，而且内容方面因为参加了体验营本该顺利一些，没想还是折腾了好久，一方面是因为间隔时间长，另一方面是自己本身掌握的就不是很牢靠，所以在以后的学习过程中，要尽量避免间隔太长时间，而且要经常复习前面学习过的要点。 day08 学习内容：PYthon的异常处理 学习用时：2.5h 总结：&emsp;&emsp;对操作的理解有了一定的提高。先跟着走下去，比放弃好不知多少倍。 day09 学习内容：了解PYthon的自带标准库 学习用时：3h 总结：&emsp;&emsp;间隔时间太长，前面的知识和记忆就容易忘。再一次坚持了下来，继续努力。 day10 学习内容：如何安装第三方库 学习用时：1.5h 总结：&emsp;&emsp;不懂就问，不耻下问。有一个好教练真是事半功倍。 day11 学习内容：实战演练1 学习用时：2h 总结：&emsp;&emsp;第一次实战，第一次独立完成，慢慢感觉越来越好了。我想随着实战的演练，真正的惊喜还在后面。 day12 学习内容：实战演练2 学习用时：2h 总结：&emsp;&emsp;编程玩微信，虽然还不知道具体有什么用，但感到挺神奇。一天完成2个任务，还有两个任务就毕业了，真是又骄傲又兴奋。 day13 学习内容：实战演练3 学习用时：2h 总结：&emsp;&emsp;自己独立完成了教练让解决的问题，感觉一步步正在稳步提升。想想长征就要到头了，真是兴奋。 学习总结 这14天的python入门课程，说是14天，可实实在在几乎折磨了一个月，为什么是折磨呢，因为实在是欲罢不能。我是先进行了体验营学习的，体验还是很良好的，因为看到了之前一直以为自己怎么也不可能学会的编程在自己的手指头上敲打了出来，然后加入了这个入门课程，然后发现体验就是体验，真正的课程才刚开始，上学时本就非常拖成绩的英语此时终于再一次惩罚了我，我像看天书一样，连蒙带试的好不容易熬过了两天的课程，此时已有当初后悔之意，后来在教练和助教的帮助下，又逐渐恢复了信心，虽然大多数练习都是跟着视频的讲解做的，里面的内容的具体含义说实话并没有理解，但随着一天天的不断接触和操作，也慢慢的明白了许多，也从很多的错误中学习到了好多。 如果说这门课一方面是确确实实教会了我好多编程内容的话，那另一方面就是增加了我好多信心，学习东西的信心，并且也能自己学会的信心，我想这才是对于我来说最重要的收获。 关于这门课，我一定会再反复学习直到理解和熟练应用。非常感谢教练和助教的悉心指导和帮助，感谢笑来老师，感谢自己！]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100367-学训练营学习21群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100367-%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A021%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：范磊学号：1901100367 工作背景工程师 自我介绍 17年学了笑来举行的ruby on rails ，今天学学Python，感受一下这个过程。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100365-自学训练营学习21群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100365-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A021%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：北海学号：1901100365 工作背景出口贸易 自我介绍 我是一名70后，俩孩儿的妈，估计自学群里属我最大了吧！之所以要学编程，是因为去年读了笑来老师的 财富自由之路 之后，觉得不论年龄大小，都要有经常更新自己操作系统的意识，并且要真的更新。之后，断断续续看到公众号里对编程意义的推广，我觉得这或许也算是一种底层能力，学了之后，不也算是新操作系统的一部分吗？所以，这份意识，外加对这个学科功能的好奇促使我报名啦！ 我并没有觉得我的工作需要代码协助，但是，如果在英语环境下的学习能够提高英语能力，那就算是有帮助！明年我准备考BEC高级，现在看书还是蛮吃力的呢！ 个人认为，不论什么技能，只要学过，它就会潜移默化的影视我们的意识，所以，我希望自己能多多的学习，同时也很喜欢学习，眼下的智能型社会环境已然启动，我们预先掌握一门跟大环境对话的语言，该是不错的！ 有教练指导是个省事省时的好事情，有同学一起学习，是更令人开心的另外一件好事情！ 加油！]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100137-自学训练营17群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100137-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A517%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100137 学习内容：Python入门14天 学习用时：24天 学习笔记 day01 学习任务：使用github进行协作 总结：&emsp;&emsp;第一天的内容要求是基本的安装。由于提前看过《 自学是门手艺 》，就已经照着书在电脑上安装了jupterlab和注册了github，可是当我照着自学准备要求进行时才发现安装有许多的问题，由于怕出差错我不得不重新进行安装，花费了许久的时间。 day02 学习任务：安装配置环境变量 总结：&emsp;&emsp;安装Anaconda和vscode花费了一定的时间，因为刚接触vscode较困难的方面是在vscode中配置python环境，我查询了许多网上资料和参考资料才了解应该怎么配置。我主要是根据资料把环境更改为Python 3.7.3-bit(‘base’:conda),语言环境我没有进行更改，比较能适应英语环境。 day03 学习任务：了解python以及使用vscode编写简单计算器 总结：&emsp;&emsp;今天已经开始编写任务我可以说是一头雾水。初尝试编写计算器对与我新手而言一点都不简单。我只有不停的翻阅李笑来老师的《自学是门手艺》和去google上搜索有效信息，自己不停的尝试不同的代码编写最后才完成简单计算机的编写。 输入，输出Input()Print() 处理多种情况 if…elif….elif…else 。 day04 学习任务：使用 for…in 打印九九乘法表 总结：&emsp;&emsp;今天的学习刚好对应李笑来老师的《自学是门手艺》，书里面刚好给出了如何使用for…in，while，偶数的·运行代码，这对编写代码非常有帮助。 循环While continue break pass day05 学习任务：python数据类型的学习。 总结：&emsp;&emsp;任务开始繁重和费力，一共有三个任务需要完成，我花了两天的时间进行这项学习。在代码运行期间一直出差错不是我想要的结果不停的修改，有时候感到无力可是还是坚持自己研究，当得到我想要的结果时我觉得非常有意义。 进行排序 sorted（） 大小写翻转swapcase() day06 学习任务：python函数的用法。 总结：&emsp;&emsp;我开始放慢了学习的脚步，我开始花2天的时间完成一项自学内容。今天的内容与day5的相似，可是当我需要使用def定义函数的时候,之后的代码的输入前面都需要tab空格，同时学习了运用创建空白文档整理单词，使用split除去字符 中文汉字与英文单词统计出现次数的方式的相同，只不过中文汉字不需要去除一些符号。 Print（）前不需要tab空格。 day07 学习任务：掌握 Python 中模块的用法，理解代码的复用 总结：&emsp;&emsp;自学内容需要添加一个新函数，合并输出day6的内容。因为day6的时候学习了如何定义新的函数，所以重新添加一个新函数合并没有很困难。可是运行代码时还是出现了许多问题。比如中文汉字并没有按个数排列，只能对之前的代码进行修改，添加了中文字符的范围代码。在使用from…import去调用文件的时候，mymodule里的文件一直运行不了,最后就只采用了import…. day08 学习任务：掌握 Python 中的异常处理（try except finally raise 总结：&emsp;&emsp;学习内容为python中的异常处理主要是针对ValueError。我对这个内容也是不太了解看了很多遍参考资料。 Try：……Except ValueError:…… day09 学习任务：初步了解 Python 自带的标准库，并学会如何查阅和使用 总结：&emsp;&emsp;关于使用counter去完善排序功能，把每个定义函数后面都加上了一个count，并且返还到collections.Counter most-common([n])这个函数上，return…..读取tang300文件我尝试了好几种方法，一直读取不正确,最后根据参考资料上的代码: 1234# 打开本地文件with open()as f： read_data=f.read() f.close day10 学习任务：掌握如何安装使用第三方库 总结：&emsp;&emsp;自学内容比较复杂的是要通过三方中文分词库统计词频。安装jieba时出现问题，mac系统需要在pip install jieba之后添加链接才能安装成功。 day11 学习任务：将之前作业中的词频统计功能应用到实际案例中 总结：&emsp;&emsp;Day11的内容比较有趣是把整理的文章以邮件的形式发送。成功安装了yagmail，pyquery和requests。从微信上提取文章,对文章进行整理。代码运行无误可是邮件一直发送不成功，询问了教练才知道密码是需要授权码。 123from pyquery import pyQuery;document=PyQuery(response.text);content=document(‘#js_content’).text() day12 学习任务：实战练习，通过微信发送消息 总结：&emsp;&emsp;Day12依然是实战练习，通过微信发送消息。由于安装wxpy受到了限制导致后面运行不成功，不过还是在运行时自动出现了二维码觉得很神奇。 123456from wxpy impot*bot=Bot()my_friend = bot.friends@bot.register(my_friend,sharing)# 转化为str类型 str()# 添加新对象append() day13 学习任务：使用matplotlib生成图片 总结：&emsp;&emsp;最后一天的内容参考参考资料可以输出图片，可是最后一天的内容并不简单花费了很多时间去研究如何生成图片。根据参考资料给出了如何制作图画以及图画的信息，同时需要加入了前几天作业的内容。 学习心得&emsp;&emsp;在自学的过程中我收获颇多，我能静下心来自己研究和学习我不会的东西。刚开始的时候我做不完就不休息，可以一整天坐在电脑面前不休息不停的尝试，甚至导致我晚上睡觉都还在想代码。之后我放慢了脚步，想不清楚就慢慢来，多看书查阅有效的资料参考大家的作业思路视频等，使得我最后几天的任务都完成得较快。我很享受研究的过程，虽然有时很辛苦很没头绪，可是当得到想要的结果时格外的开心有成就感。感谢教练还有助教一路的陪伴，指出了存在的问题并且及时给予我帮助。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>14天学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[191040056-自学训练营3群-python入门14天心得]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901040056-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A53%E7%BE%A4-python%E5%85%A5%E9%97%A814%E5%A4%A9%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：191040056 day8学习内容：PYTHON中异常的处理 try except学习用时：8h 学习笔记为了提交请求只显示当天的改动，我重装了desktop GitHub，从新下载了仓库，本级版的好了，但网页版的还显示之前的作业。学习了try except 相关的资料， 遇到的难点与问题（是否解决）&gt;githup 提交总是显示之前也要提交，不知道为什么 day9 学习内容：标准库，collections。Counter 读取本地文件函数with open（）as 学习用时：9h学习笔记学习了collections.COUNTER MOST_COMMON([N})的统计排序的运用，和with open() as 的运用 遇到的难点与问题（是否解决）&gt; 教练反馈后，我上传day9出现view pull request、 第九天的作也 不能单独发出请求命名标题。中午我打开网页，请求正常话，我又重新发了一遍。原因不太懂。我的理解是只有完成更改请求和教练确认后，才能正常发出请求。with open（）as 运行时，发出 gbk 错误提示，我参考网上和同学们完成的代码，还是不行，我运行了好几个同学的代码，也有同样的警告。 day10 学习内容：DAY10 关于jieba的安装和运用 学习用时：6h 学习笔记jieba支持三种模式 精确模式、全模式、搜索引擎模式，支持繁体分词，支持自定义词典MIT授权协议如何安装：打开Anacoda 的命令模式，输入 pip insall jieba精确模式的大概格式：seg_list = jieba.cut(“文件”,cut_all=False) 遇到的问题：运行出现编码错误，通过网上查解决 day11 学习内容：day11 有关如何通过python发送邮件 学习用时：14 学习笔记在学习过程中，遇到了几个问题。安装邮件网络协议是用pip 还是 pip3 .网络查询的是py3的版本用pip3 ,我按作业提示用了pip .运行出现的提示警告，看不懂，网上怎么更好的搜到解决方案。 day12 学习内容：day12 关于如何用pyhon登录微信接发信息 学习用时：17h 学习笔记首先用pip instsll 命令安装wxpy。我的pyhon是3.7版本的，根据资料应该用pip3 命令安装，但是pip3在Anconda 上不识别，我就用pip 安装了。运行是 出现了二维码，用微信扫描显示在连云港等录，而不是在上海，不知道是什么原因。我想起看电影黑客可以改动IP地址，感到很神奇。 运行 不是很很好，接法信息一致没有搞定，应该是我的操作有问题。根据之前的运行结果的不理想。我猜测的原因很可能是我前期ANCONDA 和VS CODE 的环境设置没有设置好 day13 学习内容：DYA13 学习运用matplotlib 和 numpy 生成图文表格 学习用时：8h 学习笔记在Anaconda 里安装的matpltib 和numpy ，显示已安装，运行结果只到扫描二维码，我在 网上查看了原因，是微信里没有设置网络登录许可。我的电脑没有按装微信电脑版，安装后还是不行，打野12的作业老师说没有问题，结果没有出来，应该还是我的电脑的一些设置没有对。后续需要从头来过一遍。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>14天学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100032-自学训练营13群-python入门14天]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901100032-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A513%E7%BE%A4-python%E5%85%A5%E9%97%A814%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100032 学习内容：Day1-14 学习用时：2个月 第1天 Github第2天 配置环境一、感受：用Print函数，让电脑打出“hello world”字样，感受到一种强烈的仪式感。一种感觉，python和小汽车一样，都是人类自己创造出来方便生活的工具，但如果要真正得到这种便利，那就必须要学会这项工具。就像小汽车一样，当你坐上驾驶位，就进入了汽车的运作系统，而安装python、配置好环境，就仿佛获得一辆车，钻进去，感受到不一样的操作环境。学好了车，驾驭车，车会把你快速载向远方，学python，就如同学会了计算机语言，一旦能驾驭，你便拥有了快速抵达未来的工具。 第3天 编写加减乘除计算器一、感受：编了一个极傻瓜的计数器，好像有一点点意思。 二、知识点： 123456789101112131415161718 """ 注释之用 """input # 要求在展示端输入的内容print # 要求终端输出显出的内容operator # 运算符first_number # 左边变量second_number # 右边变量type# 函数——类型int # 整数类型str # 文本类型if # 如果elif # 再如果else # 否则 三、逻辑分析：第一步：确定三个变量（运算符，要计算的两个数据），input输入的内容第二步：确定两个运算变量的整数类型，并明确print输出内容的类型第三步：用if…elif…else函数明确可运算的范围，根据运算符赋值的变化，再print输出计算公式和结果。 就像烧菜一样，先把食材摆出来，明确好哪些是主料、哪些是配料，定好量，切好，再安排好烧制工艺方法，这些都设定清楚，赋值，然后再丢给“电脑”这个“大厨”，它一会儿就做好了。 不明之处：’ ’ 两个单引号和（）括号中间的代码有什么本质的区别？ 四、补充知识点：（ ）tuple元组类型，不可变序列。[ ] list列表可变序列 。{ } dict字典数据类型， 可以是数字、字符串，也可以是元组。 第4天 控制流程一、感受：也许这就是数据处理的初始形态？ 二、知识点： 1234567891011121314151617181920212223242526if 搭配 else语句共同使用，如果if语句表件表达式结果为假，那么程序执行else语句后的代码。if语句最多只能有一个else语句，但可以有任意数量的elif语句。elif(即else-if), 检查多个表达式是否为真while语句：条件循环语句（一直循环，直到条件不再为真）for语句：循环语句% 取模—返回除法的余数 (取余）** 幂—返回X的y次幂// 取整除—返回商的整数部分！= 不等于（比较两个对象是否不相等）&lt; &gt; 不等于（比较两个对象是否不相等）按位或：|按位异或：^按位与：&amp;移位: &lt;&lt; , &gt;&gt;+= 加法赋值运算符1､（相加，然后返回值给前一个变量） eg: a=1 b=2 a+=b print(a) 32､（字符串连接）eg: a=‘1’ b=‘2’ a+=b print(a) 12%= 取模赋值运算符 %s 是字符串对应的格式通配符，表示格式化一个对象为字符%d 是数值整型对应的格式通配符，表示一个整数 三、逻辑分析： 第一步：用for语句明确数据范围第二步：赋值第三步：明确打印显示公式与结果第四步：用while语句明确范围，套嵌if-else语句，明确打印规则，排除真的，打印假的。最后：i += 1 加法赋值 i (代表i +1之后还是i的值，范围依然在1-10区间。 第5天 数据容器一、感受内容非常多，有点吃不消、看不懂，学得有些吃力、不明就里，只好抄视频。感觉lambda匿名函数很难弄懂。 二、知识点： 123456789101112131415161718swapcase( ) ：用于对字符串的大小写字母进行转换sorted ：对所有可迭代的对象进行升序排列,返回的是一个新的 listsort： 应用在 list 上的方法,对已经存在的列表进行操作，无返回值reverse： 排序规则 reverse = True 降序排列 reverse = False 升序排列counter函数：用来遍历列表中的所有元素，并将元素出现的次数记录下来set 集合： 用来去掉列表中的重复元素，可以在for…in 里减少循环次数lambda：是匿名函数，lambda会创建一个函数对象，但不会把这个函数对象赋给一个标识符；而def则会把函数对象赋值给一个变量key：列表里面的每个值，对应字典就是每个键。sorted参数的key表示按元素的那一项的值进行排序？？？sorted(counter.items( ), key=lambda x: x[1]) 的意思： counter.items( ) 为待排序的对象；key=lambda x: x[1] 为对前面的对象中的下标第一项出现次数的值？（即value，词频统计数？下标是什么？为数值所取的编号即为下标？）的值进行排序。 key=lambda 变量：变量[维数] 。维数可以按照自己的需要进行设置。dict类型counter的items方法，表示返回一个包含相应项(key, value)的元组列表。key即为单词，value即为单词出现的次数。布尔值： 只有两个值，Ture和False.[::-1] 涉及的数字倒序输出，反转。a[::-1]相当于 a[-1:-len(a)-1:-1]，也就是从最后一个元素到第一个元素复制一遍，倒序，列表翻转。slice切片需注意：切片的时间包含 开始 索引，不包含结尾，所以，为了不把需要取出的第一个字符切掉，需要往前多加一个字符。如：取第3到第8个字符，则[2:8]int 整数类型 integerstr 字符串类型 stringbin 二进制类型 binary systemoct 八进制类型 octonary number systemhex 十六进制类型 hexadecimal 三、逻辑分析：第一任务：字符串的基本处理第一步：定义sample_text变量，把要分析的内容复制给变量第二步：用str类型的replace方法进行替换。再打印。 text = sample_text.replace(‘better’, ‘worse’)第三步：将字符串分割，分割成 list, 再filtered变量存放被过滤后的单词 words = text.split( ) filtered = [ ]第四步：用for …in循环遍历一遍，用find方法查看己被分割的list判断是否包含要被剔除的元素ea。如果不包含ea，则赋值为&lt; 0 (此处为什么不直接写-1?），由于字符串索引从0开始，包含ea则进入到0开始被索引（要被过滤掉），如果不包含则为-1,属于要被过滤后的list，被装入filtered变量里。最后再打印被过滤后的filtered变量内容。 简言之：分割打散字符 —— 放出过滤器filter —— 用for…in遍历find找有ea元素的list，赋予&lt;0的计算机索引值，将其归入不被索引的范围，即被过滤掉，用filtered过滤器留下不含ea元素的list，打印出来，达成任务。 if word.find(‘ea’) &lt;0——如果找到有ea元素，则记入不被索引范围，留下不含ea元素的word. filtered.append(word)——添加不含ea元素的word到过滤器里，更新列表，不返回任何值。（append，指将传入的对象附加(添加)到现有列表中）第五步：用swapcase() 方法用于对字符串的大小写字母进行转换。 第二个任务：统计字符串样本中英文单词出现的次数第一步：定义sample_text变量，把要分析的内容复制给变量第二步：将字符串分割，分割成 element列表。第三步：定义新的list变量words，存放处理过的单词第四步：挑选出文本中的非单词符号，剔除。之后，元素长度len不为0的，则算正常单词，存入到变量words里面。打印出现的单词（己过滤掉重复出瑞的）。第五步：采用key=lambda匿名赋值变量，按词频统计数降序排列。按词频数从大到小排列打印。 第三个任务：数组操作，进制转换用a[::-1]翻转列表把int类型元素拼接之前需变成一个包含str类型元素的列表。用’ ’(空字符串）和str类型的join方法连接列表里的元素。’ ’(空字符串）：表示连接的时候元素间不用任何按符隔开。 第6､7天：统计函数词频一、感想：复习到这一天，感觉很累。好像学习激情消失了。又安慰自己毕竟花了钱，打肿了脸也要学完啊。虽然还是没有掌握到学python的精髓。 相关知识点： 12345678910111213141516key=lambda X: X[1]x[1]表示x下标为1的值返还给x用from …import …导入需要统计的文本result = stats_word.stats_text(sample_text)print(‘统计结果 ==&gt;’, result)输出统计结果。def (define，定义函数的意思）一般格式：def函数名(参数1,参数2,……,参数N):执行语句如：def stats_text_en(text):注意：结尾要有冒号。 二、逻辑：把命令语句事先写好，然后再导入要统计的文本，进行统计并排序。 三、疑问：是不是以后可以这个文本直接替换成别的文本，然后，也能进行相关的词频统计呢？还是说，直接导入要替换的文章网页更方便？ 第8天：异常处理一、感想：一般在运行的时候，如果有错，运作框内会提示错误出来，所以，不明白这个异常处理是不是有点儿多余？ 相关知识点： 12345678910111213用try…except捕获异常， try: 参数except Exception as e: print(参数）为什么是e?traceback模块：跟踪异常返回信息logging模块：Python内置的标准模块,主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回路等。if not isinstance(text, str):判断参数text 是不是 str 字符串类型，如果不是，则抛出ValueError异常 二、逻辑：导入要分析的文本，再调用traceback 和 logging两个函数，报错，并找出错误的位置。 三、疑问：是不是记住了python一些自带的命令模块，逻辑清晰写的复制粘帖，然后，用异常处理报错，基本啥事儿都可以解决了呀？ 第9和10天：标准库和第三方库的调用感受：字太小，看得很累，对视力不好。视频的声音听得人犯困。安装jiebar 的时候，因为是苹果系统，与视频讲的不一样，所以卡了很久。 知识点： 123主要是jieba中文库分词的作用。苹果系统采用的安装方法是直接进入到Anaconda Navigator里面—-environments---base(root)—-Open Terminal(终端）自行录入 install jieba即可。后面要安装，直接运用此法就行。 第11天至第13天：实操一、感想：因为微信不支持，所以，没有感受到处理结果。所以，并没有兴奋。 相关知识点： yagmail 快速发送邮件 requests爬虫的基本框架是获取HTML页面信息，解析页面信息，保存结果，requests模块是用于第一步获取HTML页面信息； requests库用于爬取HTML页面，提交网络请求，基于urllib,但比urllib更方便对应http的不同请求类型，requests库有不同的方法： requests.get():获取HTML网页的主要方法，对应于HTTP的GET requests.post():向HTML网页提交POST请求的方法，对应于HTTP的POST requests.head():获取HTML网页头信息的方法，对应于HTTP的HEAD requests.put():向HTML网页提交PUT请求，对应于HTTP的PUT requests.patch():向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete():向HTML页面提交删除请求，对应于HTTP的DELETE 123456789document = pyquery.PyQuery(r.text)def get_article(): r = requests.get(‘网址’) pyquery 爬虫辅助利器,PyQuery可以方便地用来解析HTML内容,提取网页中的任何数据def get_article(): r = requests.get(‘网址’) document = pyquery.PyQuery(r.text) return document(参数).text() getpasspython内置的获取密码及用户名的模块 loggingPython内置的标准模块,主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回路等。 matplotlib用来绘制柱状图。 numpy 是大量Python数学和科学计算包的基础。支持大量的维度数组和矩阵运算,对数组运算提供了大量的数学函数库!Numpy比Python列表更具优势,其中一个优势便是速度。机器学习算法中大部分都是调用Numpy库来完成基础数值计算的。 13天学习大总结： 实际从7月2日开始，断断续续花了近2个月时间。 半懂不懂，不知道入门了没有，不知道怎么样才算入门。也许是因为没能与实际工作生活相结合，所以，找不到感觉，学得很落寞。 其实也知道坚持到最后也许会有一定的好处，但目前为止，没有对实际生活（工作收入等）产生直接切入点，后续学习动力堪忧。 在反思自己当时是不是一时冲动的结果. 虽然自学是需要坚持的，但如果一开始没有得到实际的好处或者乐趣，或者说，并没有感知到学习它的直接效用，那如何继续？（我文科生，做运营的） 希望未来的工作中能需要接触哪怕是要懂得运用python，这样，才能不枉费这段时间的学习。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>14天学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090023-自学训练营9群-Python入门学习心得]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901090023-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A59%E7%BE%A4-Python%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901090023 学习内容：Python入门 对自学的感悟和理解&emsp;&emsp;这两个月报名参加“Python编程入门自学训练营”，和来自各行各业的十多名童鞋一起自学。面对一个完全陌生的领域，从不知所措、自我怀疑到一步步走出重重迷雾，完成爬虫语言编程入门的任务。在自学路上，一枚编程小白到底经历了什么？又收获了什么？ 自学是什么样的旅程？ 在Python任务自学中，不断经历笨手笨脚、手忙脚乱，问各种当时绞尽脑汁也想不明白的傻乎乎的问题。看到其他学员也一样，我明白了我所经历的很可能是入门新领域的必经过程。 In the self-teaching course of recent tasks, I constantly ran into a state of clumsiness and anxiety, and asked silly questions that no matter how I racked my brain yet still remained confused about at that moment. After learning this was the same case in other learners, I realized what I encountered was probably the must-experience process on the threshold of entering a new field. 不会做、做不好，有挫败感、痛苦和自我怀疑，但不要随便放弃，调整好心态后，再接着做下去；做不到很懂，先弄懂一小部分，先去完成任务，先尝试把完成任务需要的知识点搞懂。 I don’t know what to do; I cannot do it well; I am disappointed, miserable and self-doubted. Yes, my feelings are true. But do not run away just because of these! First, do something to be calm and rational again, then go on to do the tasks. Despite the fact that I cannot understand all the reference material, I could attempt to master a bit of it, bit by bit. Try to finish the tasks first, as well as understand the points required in the completion of tasks. 记起Elly说过的，要对自己无条件的爱和耐心。我经历的再正常不过，关键是掌握好的学习方法，早点度过这个过程。 Elly once said, treat yourself with unconditional love and patience, for my experiences are not uncommon at all. The key is to gain more effective self-teaching approaches and going through the process as soon as possible. 总结：那些“看不懂、不知所措、似乎明白了，这怎么办”等等，是常态。明白了“自学就是不断动脑，逼迫自己去思考下一步怎么办，要怎么做才能有效解决眼前的问题。” ****Conclusion: It is not uncommon at all that “I don’t understand”, “I have no idea”,“I seem to understand”, “how to deal with this?” and the like. I come to realize that “self-teaching involves using my brain constantly, propelling myself to come up with the next step and the effective solutions to the questions ahead.” 自学会经历哪些心态？ 整个过程中（尤其是Day4-6的自学任务），经常有“看不懂，没有解答思路”的情况，所以常常蹦出“放着好好的日子不过，跑这里找虐”的想法。此时，我就提醒自己，我是来了解编程到底是怎么回事的，我是来提高自学能力的。一遍遍告诉自己，要耐心，要沉住气。 In the process(especially for Day4-6 tasks), I frequently encountered the situations like “What? I totally don’t understand!”, “I have no idea about how to solve this!”. Thus, the idea that I choose to suffer rather than live a cozy life often occurred to me. Then, I reminded myself that I do this for getting to know what programming is like, and for enhancing my ability in self-teaching. Again and again, I told myself to keep patient and stay calm. 有时任务就卡在那里，绞尽脑汁也不得要领，在最绝望的时候，我想到了教练，想到了其他童鞋。于是在issue区提问求助，得到了童鞋和教练的提示和鼓励。此时，才蓦地惊醒，“要给解决任务设置时限，必要时果断求助”，这才解了燃眉之急。 Sometimes I was stuck on a particular task, racking my brain but gaining nothing. When huge despair crawled, I thought of my coach and other learners, so I turned to them in the “issue area”, a special online zone for all learners to post their problems in learning, and got their clues and encouragement. Only then did I realize that I should ask for help immediately if it takes so long to cope with a problem, which finally helped me in handling the paper tiger. 在自学过程中，当发现自己这也不会、那也不会时，如果着急焦虑，那么即使任务最终完成了，也会觉得非常疲惫，甚至痛苦。相反，此时放松而专注地去自学，那么完成任务后仍然会觉得精力旺盛，并且开心满满。 In the self-teaching process, if you are anxious when you find you do not understand this or that, then you will probably feel exhausted and even miserable even though you finish all tasks. Conversely, if you choose to be relaxed and focused then, you are likely to stay energetic and cheerful the moment you complete the assignments. 总结：只要有耐心，一步步想办法，我相信我们能搞得定。毕竟，最后很多人做到了，不是吗？Conclusion: As long as we have patience to address the problems step by step, I believe that we can make it. After all, many learners did it finally, didn’t they? 自学有什么好方法？ 从刚拿到任务到最终完成任务，需要沉下心去阅读参考资料，耐心去找跟任务关联的信息点和解决思路，不对的地方再定位问题，这样一步步下来，终于一点点拨开云雾见青天。 From receiving the tasks to accomplishing them, you need to calm down while reading reference material, find out relevant information and solutions to the task with patience, pinpoint problems when anything goes wrong. By following these steps, you will finally get things done. 接受自己在自学过程中做不好非常非常重要！零基础学员做任务各种不顺利——本该如此啊！既然如此，入门新领域，我们首先必须明白，没有人一上来就做得很好，根本不必跟人比较，更不必因此自卑。所以，入门新领域学习方法之一就是完成一个任务，不给自己限时。 It is critical to accept the fact that I cannot do it well in the process! A beginner cannot finish a task smoothly—it should be like this! Thus, when we start to learn a new skill, we need to understand at first that nobody could do so well just at the very beginning. We do not need to compare with others, nor do we degrade ourselves if we are terrible with a new skill. In this sense, a good way to learn is to not set a limited time period for us to complete a certain task. 在自学训练营，练成了使用Google搜索的习惯。不得不说，这真是解决问题的极好办法，哪里不会google哪里。 In the self-teaching camp, it is nice to form a habit of using Google, a powerful searching tool. There is no doubt that it is a fantastic approach to solve a problem: google wherever you do not understand. 自学一个新领域，最好跟社群一起学。在群里看到自己跟各位小伙伴有共同目标、共同体验，是自己得以一步步走到最终胜利的重要原因。而单打独斗，往往难以走下去。人是群居动物，人就是乐于与志同道合的人一起。 To self-teach in a brand-new field, we had better do it in a community. Seeing I and other members have the same goal and experience is the key to attempting to the final success. On the other hand, it is rather difficult for us to go alone on the way to self-learning. In other words, humans are “people creatures” who prefer to work with the same type of people. 自学要有反馈，有专业人士指导，这样才能及时了解自己的情况，比如自己做得怎么样，怎么解决某些具体任务，或完成的任务有哪些出现问题，又该如何改正。 We need feedback when self-learning. With the instructions of professionals, we are able to learn how well we have done, how to handle some concrete tasks or how to debug the mistakes we have made. 总结：非常感谢训练营的教练们，感谢他们设计的Python自学产品，让我的自学能力得以提高，我不会忘记这段自学体验，今后我要尽力把自学能力发扬光大。再次感谢！]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
        <tag>Python入门</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-MIT-自学 lecture9]]></title>
    <url>%2FMIT60001%2F1901030012-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%90%A5-lecture9notesday43%2F</url>
    <content type="text"><![CDATA[学员信息 学号: 1901030012 学习内容: MIT第9课视频文稿p6 学习用时: 128mins Notes no.: Day43 学习笔记 Information hiding So the whole reason why we’re using classes in object-oriented programming is so that you can abstract certain data from the user. One of the things you should be abstracting is these data attributes. So users shouldn’t really need to know how a class is implemented.They should just know _how to use the class._ Eg: Let’s say whoever wrote the Animal class wants to change the implementation. And they’ve decided they don’t want to call the data attribute “age” anymore, they want to call it “years,” OK? So when they initialize an animal they say self.years = age. So an animal still gets initialized by its age. And the age gets passed into a data attribute named “years,”. Since I’m implementing this class, I want to have a getter, which is going to return self.years. So I’m not returning self.age anymore, because age is no longer the data attribute I’m using. So with this new implementation, if someone was using this implementation and was accessing age directly as— was accessing the data attribute age directly— with this new implementation, they’d actually get an error, right? Because this animal that they created using my old implementation no longer has an attribute named “age.” And so Python’s going to spit out an error saying no attribute found or something like that. If they were using the getter a.get_age()— the person who implemented the class reimplemented get_age()to work correctly, right, with their new data attribute, years, as opposed to age— so if I was using the getter get_age(), I wouldn’t have run into the bug, OK? So things to remember— write getters and setters for your classes. And later on in your code, use getters and setters to prevent bugs and to promote easy to maintain code. so information hiding is great. But having said that, Python’s actually not very great at information hiding, OK? Python allows you to do certain things that you should never be doing:1. The first is to access data attributes from outside of the class, OK? So if I were to say a.age, Python allows me to do that without using a getter and setter.2. Python also allows you to write to data attributes from outside the class. [Eg](: So if I implemented the class Animal assuming that age was a number, an integer, and all of my methods work as long as age is an integer, but someone decided to be smart and, outside of the class, set age to be infinite as a string, that might cause the code to crash, OK? Python allows you to do that. But now you’re breaking the fact that age has to be an integer, right? So now the methods should probably be checking the fact that age is an integer all the time.)3. The other thing that you’re allowed to do is to create data attributes outside of the class definition. [Eg](So if I wanted to create a new data attribute called “size” for this particular instance, Python also allows me to do that. And I can set it to whatever I want, OK? So Python allows you to do all these things, but it’s actually not good style to do any of them. So just don’t do it. All right.) My boogieman is living in my illusion. Too much read between the lines. 我就是想得offlined多一些。我如果不想做，想啥都不切题。有病要治，尝试找解药： _3.1_ Marcus.sleightofhand “上手”，才能解决焦虑。“上手”，没有重点，但是有“通”点。……永远记得，我们真正的目标是，“上”手。 ……如何给自己制造反馈。要制造反馈，你必须先有成果，制造反馈的目的就是要基于已有的成果来发现问题。所以要制造反馈，我们可能要写一点东西，录制一点音频，甚至录像，这些是给自己制造反馈的最佳手段。总结来说就是要及时输出。 你学了一些东西之后，一定要想办法讲出来或应用出来，这正是给自己制造反馈。所以你一定要积极地给别人讲东西，…… 缺少反馈的一个最常见的情况是，我们平时会看一些书，看完了也就过去了，时间长了也就忘记了。就是因为没有反馈，我们并没有笑话书中的重要内容。 —— Marcus XU “SLEIGHT OF HAND” _3.2_ My Angel.letustalkaboutit @糖糖今天在AMA里也回答了我的问题，以任务为导向开干，而且不能闭门造车，要持续反馈和反复沟通。所以，实际上最好的antivirus methods就是该干嘛干嘛，该作作业啊，，，“躲”着是个什么事儿，打开了作业指引读不进去的主要原因就是没想做作业。。。一条一条的读，记住自己读这个指引的任务是什么，拆解到最小单位的尝试输出，if offlined please try shifting back，practice makes progress。 _3.3_ Max.piggiefight 其实最大的鼓励还是来源于Max猪，他和爸比在玩的有一个游戏就是统计类的，然后他昨天的观察作业就是花的结构。和我数据营的作业一毛一样啊，，，他也不知道完整的统计啊，他也一开始并不全面知道花的那些结构的名词和作用啊，人家就是不怕地、兴致勃勃地完成自己的任务啊，他特别不理解的看着我苦闷的脸，然而，他还是patpat我说：麻麻你别怕哈，你来用电脑写你的作业，不懂的，我来教你。 Eyes on “ME”. 哎，四岁八个月的“我”，比同龄Max却还有很多心理建设需要做，好吧，还好我有Max的鼓励和支持，有这个自学营的小伙伴们，也说明我进步了，至少我不像以往那样封闭，而是在努力地追望着营友们的背影，现在爬行追赶。 我们每个人的学习方法是不同的，要摸索自己适合的方法，摸索靠“上手”呀，谢谢自学营里每一位campmates们的鼓励、帮助与支持，有你们的世界真好，加油Cat! 感谢教练们，，，让我再gu（四声）qiu（轻声）一会儿。。。。。。黑线脸喵。。。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901070018-自学训练营18群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901070018-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A518%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901070018 学习内容：Python入门14天 学习用时：未知 学习笔记 day01 用时：4h 总结：&emsp;&emsp;英语阅读还有点吃力，把资料全都看完了。 day02 用时：3h 总结：&emsp;&emsp;第二次做难度降低，阅读英文还是有点难。 day3 用时3h 总结：&emsp;&emsp;解决一个问题，不是很清楚原理。 day04 学习内容：流程控制 学习时间：0.5h 总结：&emsp;&emsp;之前反复阅读了自学是门手艺若干遍，现在再看今天的作业感觉很简单，会了都不难，觉得困难只是幻觉。 Day5 用时：2h 总结：&emsp;&emsp;由于反复阅读自学是门手艺，今天只遇到一个问题，花了了很多时间，没有解决。果断找第二种方法，这个问题记录下来，等以后基础足够在来研究。 DAY6 用时：2h 总结：&emsp;&emsp;第二次做作业，和第一次做这个作业感觉完全不同，果然要重复足够多的次数。还有就是把注意力集中在解决问题上。 DAY7 用时：2h 总结：&emsp;&emsp;由于反复阅读了自学是门手艺，还有查阅了一些教程，解决了模块找不到的问题。过程中提醒自己，没啥可怕的。 DAY8 用时：3h 总结：&emsp;&emsp;阅读了一遍文档，看懂了一部分就写出来了。虽然只是最基础的try…exceptraise,但是读懂文档并且学会一个全新的一句。这对我来说是一个很大的进步。 DAY9 用时：4h 总结：&emsp;&emsp;阅读官方文档还是有些不懂，不过没有全部弄懂也没关系，因为懂最重要的就够用了。这次的内容和自学是门手艺中的一章相关。现在发现第一次进入训练营时竟然没有阅读这本书，在没有基础的情况下，一上来就看官方文档还是英文上结果可想而知。 DAY10 用时；4h 总结：&emsp;&emsp;遇到环境变量的问题。因为下载了anaconda和pycharm 所以有两个python在电脑里。结果就是第三方库被下载到anaconda中，而pycharm环境中没有，最后用的Google找到了解决方法。 DAY11 用时：4h 总结：&emsp;&emsp;这次的内容，官方文档不是很懂，还需要多看，基本上都是Google。我现在深刻理解了Google对于自学者的重要性。文档还需要反复阅读。 DAY12 用时：2 总结：&emsp;&emsp;从开始接收到任务，一直到做完用了6天。其实做的时间只有两个小时，其它时间总是被困难幻觉所干扰。以后遇到困难幻觉，立刻开始行动。 DAY13 用时：未知 总结：&emsp;&emsp;这次作业遇到了一些问题，在教练的帮助下通过反复阅读搜索解决了。通过这些天的学习，感觉自己理解了困难幻觉这个词。在自学的道路上所有的困难都是幻觉，懂了以后感觉不过如此，用就行了。 DAY14 用时：未知 总结：&emsp;&emsp;入门结束了，自学还要继续。 14天学习总结 现在回过头来总结自学营的学习过程，真的不难的课程我从四月开始学总计用时141天。我之前总觉得接触python没多久，好像就两个月左右，github上的记录赤裸裸的粉碎了这个幻觉。 这141天中真正用在学习上的时间肯定没有14天，分别在day2、day2、day11(我上了两次训练营！)放弃了117天、9天、4天总计130天，真正学习的时间是10天（github真是个好东西），其中有几天每天都可以完成两天的作业。放弃的原因只有一个，太难了。 尽管《自学是门手艺》中反复强调这些困难都是幻觉，尽管书中做了大量的心理建设，尽管这141天中我也断断续续地在读这本书，尽管每次放弃的时候都知道不应该放弃，但我还是放弃了。然后过一段时间又挣扎着开始。 现在反思那些把我难住的知识点，其实就那么回事，真的不难。当时觉得难是因为阅读的量和次数都不够，当然就不会，然后就焦虑，然后就放弃了。 现在我深刻的理解了困难幻觉这个概念，所有的困难都是幻觉，等学会了就会发现就那么回事。 总结一下学习过程就一句话，没啥可怕的！]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100050-自学训练营学习13群-李森强自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100050-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A013%E7%BE%A4-%E6%9D%8E%E6%A3%AE%E5%BC%BA%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：李森强学号：1901100050 工作背景律师 自我介绍律师，前移动销售，前警察，二级心理咨询师。近一年来，自己与程序员合作做数字资产量化，每个月要给程序员不少钱，于是想自己学习编程，以后自己做量化，省下一大笔费用。学习编程的经历，还是在10多年前的大学学习过VB编程，现在早已经忘记了。不过，正好，不会影响现在学习Python。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>律师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100178-自学训练营18群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100178-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A518%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学`员信息 学号：&lt;1901100178&gt; 学习内容：&lt;Python入门14天&gt; 学习用时：&lt;24天&gt; 学习总结 day03 学习内容：&lt;利用Python程序编写简易计算器&gt; 学习用时：&lt;4hours&gt; 收获总结 初步了解到了Python的功能，并认识了一些编程语言 学习了字符串、三种控制流、两种循环 掌握编程技术是一门长久的功课，不是轻而易举就能学会，需要耐心和意志 遇到的难点与问题（是否解决） 起初对编写简易计算器一头雾水，不知从何下手【已解决】 day05 学习内容：&lt;掌握Python基本语言&gt; 学习用时：&lt;4hours&gt; 收获总结 学习了字符串的基本处理方法 学会统计字符串样本中英⽂文单词出现的次数 通过这么多天的学习，渐渐地磨炼了自己的耐心与意志 慢慢掌握了Python程序的流程 遇到的难点与问题（是否解决） 对编程技术的概念以及核心还一窍不通【未解决】 day06 学习内容：&lt;学会运用 封装统计英文单词以及中文汉字词频的函数&gt; 学习用时：&lt;3hours&gt; 收获总结 初学者总是很好奇 List 和 Tuple 的区别。首先是使用场景，在将来需要更改的时候，创建 List ；在将来不需要更改的时候，创建 Tuple。其次，从计算机的角度来看，Tuple 相对于 List 占用更小的内存。 基本了解了Python中函数的功能，并学会按词频降序排列列的数组 day07 学习内容：&lt;将统计中⽂文词频和英文词频的函数封装为一个模块&gt; 学习用时：&lt;6hours&gt; 收获总结 成功是靠一步步的努力和充沛的时间以及精力取得的 通过今天的学习，我更进一步地了解并认识到了Python的运行流程 渐渐地掌握了函数的运作流程 day08 学习内容：&lt;为函数添加参数类型检查&gt; 学习用时：&lt;6hours&gt; 收获总结 在main.py里，加上try: except:，如果输入的不是字符串，比如列表，则打印出错误提示。 day09 学习内容：&lt;day09 标准库&gt; 学习用时：&lt;7hours&gt; 收获总结 本次作业在day08作业上加以修改，先在函数里多加一个变量，再使用python自带标准库里的Counter()，统计出的结果直接为字典形式。可转换成列表。 在main.py里，需要先import json，使用open()打开文件时需要填写本地的绝对路径，路径前面以r开头，引号内为路径。 day10 学习内容：&lt;day10 第三方库&gt; 学习用时：&lt;2hours&gt; 收获总结 通过不断的学习，自己的编程能力也在慢慢提升，在学习过程中我也在慢慢成长，不断地进步，效率也在慢慢提升，希望最终能有好结果 day11 学习内容：&lt;实战演练1：获得网页内容，分词统计，邮寄发送统计结果&gt; 学习用时：&lt;10hours&gt; 收获总结 想到通过&lt;p&gt;标签提取，但是示例中似乎没有，不知道如何处理了，继续看作业文档。Github上搜索PyQuery，里面的参考示例在IDLE中跟着敲了一边，还是不知道如何通过标签提取内容，又想到，通过标签提取内容也可能不准确，放弃自己琢磨，看视频。是通过下面两行代码提取出HTML中的内容的： 12document = PyQuery(r.text)article = document(&apos;#js_content&apos;).text() # 提取内容 对代码有两个疑问： js_content 是什么？document不是一个变量吗，怎么可以把document当做函数一样使用呢document(‘#js_content’).text() ？查看网页源代码，搜索js_content，原来是标签的id，#js_content是指通过标签id来提取内容。&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt; 另一个问题，document = PyQuery(r.text)，这个document是什么？没有进一步去解决。 step 3 : 发送邮件。根据视频提示，写好代码，运行，发送邮件时，会报下面的错误：smtplib.SMTPAuthenticationError: (535, b&#39;Error:\xc7\xeb\xca\xb9\xd3\xc3\xca\xda\xc8\xa8\xc2\xeb\xb5\xc7\xc2\xbc\xa1\xa3\xcf\xea\xc7\xe9\xc7\xeb\xbf\xb4: http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256&#39;)反复尝试几次，都是同样的错误，再次看作业文档，提示网页设置开启SMTP，登录设置后开启后，再次尝试，依然报同样的错，再次仔细看作业文档，原来登录密码要输入开启SMTP后的授权码。完成任务。 day12 学习内容：&lt;将实战项目1的功能包装集成到个人微信&gt; 学习用时：&lt;3hours&gt; 收获总结 了解了wxpy模块，学会了把之前的功能封装，以便随时调用，但是美中不足的是，现在的微信不让网页登陆，尝试了很久也不能解决，先把作业交了，之前的知识点需要勤加练习 更进一步地了解编程技术以及python的功能 day14 学习内容：&lt;Python14天入门营&gt; 学习用时：&lt;24天&gt; &lt;总结&gt; 今年暑假的7月20日，我在妈妈的鼓励下，进入了一切不可预知的编程世界，也开启了我对网络世界探索的第一扇大门。 起初我对这件事不是很抱有好感，再加上第一次作业的难度对我来说已经到达了一种不可理喻的地步，我几乎学得快要崩溃，仿佛在绝境垂死挣扎，我有过想要放弃的念头，但是我妈给我做了榜样，她领导着我在学习，给我做排头兵，我也渐渐恢复了信心，一次又一次地克服了难关，当然，教练和同学的指导与帮助也是必不可少的。 时间过得飞快，转瞬即逝，今天已经是课程的最后一天，我心里仿佛如释重负，不禁暗暗地说：“终于解脱了”,当然，兴奋之余也有些许的不舍，因为这长达二十多天的学习让我深深地感受到了编程语言的魅力，科技在飞速地发展，作为新时代的接班人，网络技术的掌控也是我们不可或缺的一部分，希望有更多的人去了解编程，学习编程，让编程技术的魅力在新时代尽情绽放！]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100206-自学训练营学习18群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100206-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A018%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 学号：&lt;1901100206&gt; 学习内容：Python入门14天 学习用时：&lt;25天&gt; 学习笔记 day01 学习内容： day01: 使用github进行协作 学习用时： 合计3小时 收获总结： 在Pull Request时，base：是被合并的,compare：是有改动的，即把这些改动合并到base。 总体来说，没遇到什么困难，因为不是第一次接触github了。 这次做作业的过程中，和原来学习过程中遇到英语就退缩的我不一样的是，我开始试着读链接中的英文文档了，即使读得慢也坚持读完。 day02 学习内容： day02：配置本地运行开发环境 学习用时： 2小时 收获总结： 对于作业，先clone文件到本地，修改后commit，然后合并，最后pull request到远程仓库。这一套流程已经很熟悉了。 难点：在配置vs code开发环境时，面对长长的英文文档，有种没法下手的感觉，读了两段后开始云里雾里。就先跳过了。 day03 学习内容： day03 hello python 学习用时： 10小时 笔记： 收获总结： 函数round(3.1415, 2)，后面的参数代表返回几个小数位;method：.append()，可在列表里使用;print(a, end=” “)，end代表输入结果之间以什么结尾 继续和英文文档死磕到底，看懂了后写作业就不难。 day04 学习内容： day04 控制流程 学习用时： 10小时 收获总结： list.insert(0, w) 第一个数代表位置，第二个数代表插入的东西 单词：iterate 迭代;单词：indentation 缩进 写for循环时，感觉不是很难。但搜索后得知有更好的写法。 写while循环时，却因为定势思维以及思考不够深入而反复得不到正确结果。好在通过搜索也解决了问题。 day05 学习内容： day05 数据容器 学习用时： 20小时 收获总结： 对python数据容器里的函数和methods要多加记忆，以便遇到问题随时拿来使用。 第二个作业是统计词频，善用这种方法有利于学习数据分析，以后会多加注意。 day06 学习内容： day06 函数 学习用时： 20小时 收获总结： day06的作业是在day05作业的基础上修改的，所以统计英文词频的函数略加修改即可。而且稍稍优化了一下。 统计中文词频时，就要换个思路，参考别人的代码时，都会有去除标点符号一项。但使用正则表达式时则直接略过这一步，相当于降维打击了。 day07 学习内容： day07 模块 学习用时： 5小时 收获总结： 本次作业只需在day06作业上加以修改即可完成。 其中text因为是中英文混合，所以原先的代码不能直接拿来用，统计英文字符时需要先剔除中文字符。统计中午字符时同理。 封装模块时要细读作业要求，main.py与mymodule同目录。 day08 学习内容： day08 异常处理 学习用时： 5小时 收获总结： 本次作业在day07作业上加以修改，在三个函数里加上类型判断，可选type()以及isinstance()。 在main.py里，加上try: except:，如果输入的不是字符串，比如列表，则打印出错误提示。 day09 学习内容： day09 标准库 学习用时： 8小时 收获总结： 本次作业在day08作业上加以修改，先在函数里多加一个变量，再使用python自带标准库里的Counter()，统计出的结果直接为字典形式。可转换成列表。 在main.py里，需要先import json，使用open()打开文件时需要填写本地的绝对路径，路径前面以r开头，引号内为路径。 day10 学习内容：&lt;day10 第三方库&gt; 学习用时：&lt;3小时&gt; 收获总结： re.findall(r’[\u4E00-\u9FFF]’, text)该用法取出所有中文字符 re.sub(‘[^\u4e00-\u9fa5]’,’’,text)该用法将所有非中文字符，替换为空，包含英文字符和标点符号等 os.path用法#path = os.path.abspath(file) 显示main.py的绝对路径#path = os.path.dirname(os.path.abspath(file)) 显示main.py所在文件夹的目录path = os.path.join(os.path.dirname(os.path.abspath(file)), ‘tang300.json’) 文件读取：with open(path, “r”, encoding=’UTF-8’) as f: #open可直接读取本地文件里的内容read_one = f.read() #read()将文件内容读取，并存在read_one 每次作业都是基于上次作业的基础完成的，通过不断升级快捷易用的工具，以便得到更高效率的解决方案。这便是编程的魅力之一吧！ re.findall用法，统计字频时可以使用，统计词频时需要用re.sub。 day11 学习内容：&lt;day11 实战演练1&gt; 学习用时：&lt;6小时&gt; 收获总结： yagmail（邮箱库）用法：发送邮件 12yag = yagmail.SMTP(sender, password, '服务器地址') #发件人，密码以及服务器yag.send(recipients, '标题', word_str) #收件地址，标题以及要发送的内容 requests（网络请求库）最基本的用法：获取该网页内容 1response = requests.get('https://mp.weixin.qq.com/s/pLmuGoc4bZrMNl7MSoWgiA') pyquery（xml 文档解析库) 12document = PyQuery(response.text) content = document('#js_content').text() #将网页内容转换成文本 这些第三方库都有着强大的功能，以及配套的详细的用法教程，本次作业只是用了点皮毛，后面更多的玩法有待发掘。 pyquery库的用法未参考教程，直接拷贝作业要求上的代码，复盘时需要再读读原教程。 day12 学习内容：&lt;day12 实战演练2&gt; 学习用时：&lt;6小时&gt; 收获总结： littlecodersh/ItChat： 微信个人号接口、微信机器人及命令行微信，三十行即可自定义个人号机器人。 liuwons/wxBot: 类似的基于Python的微信机器人 zixia/wechaty: 基于Javascript(ES6)的微信个人账号机器人NodeJS框架/库 sjdy521/Mojo-Weixin: 使用Perl语言编写的微信客户端框架，可通过插件提供基于HTTP协议的api接口供其他语言调用 HanSon/vbot: 基于PHP7的微信个人号机器人，通过实现匿名函数可以方便地实现各种自定义的功能 yaphone/itchat4j: 用Java扩展个人微信号的能力 kanjielu/jeeves: 使用springboot开发的微信机器人 用一个库时，不会的地方先读文档，一般情况下，文档里都会有关于用法的详细解释。 遇到的难点与问题（是否解决） 可惜了我三个微信号都登不上web微信，好在有教练的帮助完成了任务，只是不能继续体验微信机器人的更多玩法有点可惜。ps：网上搜了很多类似案例，目前暂时没看到什么好的解决方案。。。 day13 学习内容：&lt;day13 实战演练3&gt; 学习用时：&lt;8小时&gt; 收获总结： matplotlib用法 123456plt.bar((word_data[i][1],),(word_data[i][0],), facecolor='#9999ff', edgecolor='white') #绘制柱状图plt.title('中文词频(TOP1-10)') # 显示标题plt.xlabel('单词') # 显示x轴名称plt.ylabel('词频') # 显示y轴名称plt.legend('直方图') # 显示图例plt.savefig('word_dict.png', dpi=300) # 保存图片 tplotlib的功能很强大，值得深入学习，本次使用的依然是只是皮毛，以后学习数据分析时会继续研读文档。 遇到的难点与问题（是否解决） 网上的文档和教程都很丰富，经过搜索到第一种解决方案，先将统计的结果转换成csv文件:1234with open('dict.csv', 'w') as csv_file: writer = csv.writer(csv_file) for key, value in word_dict.items(): writer.writerow([key, value]) 然后使用panda库读取csv文件，再使用matplotlib绘图。但此种方案实现起来有点复杂。 第二种解决方案，将统计结果转换成字典，遍历字典里的键值当做坐标值—出自知乎 day14 学习内容：&lt;Python14天入门营总结&gt; 学习用时：&lt;&gt; &lt;总结&gt; 2019年7月26日，我读到了新生大学的一篇关于自学编程的文章，作者在标题里说他写出了通过未来的代码，这引起了我的好奇心。点进去读完后，我就报名了，当晚就开始了学习。 事实上，我早就购买了李笑来老师的自学是门手艺一书，并读完了Part one，还在xue.cn上做习题。但是却和以往一样，坚持了一段时间后，我停了下来，原因正如李笑来老师所说：在最初“学”的阶段，社交也是极为重要的。而一个人的学习就是很难坚持下来，没有社交，且目标不明确，所以我选择了加入自学营，和一堆人一起学习。 自学营设计的14天作业，难度是循序渐进的，我觉得最大的优点是每次作业都是基于上次作业的基础完成的，而且通过不断升级快捷易用的工具，以便得到更高效率的解决方案。这是让我们不重复造轮子，用前人的智慧解决自己的难题。而且基于Python有那么库可用，更是这个编程语言的优势所在。 最后两次作业是学习wxpy库的使用，它可以让我们实现微信个人号的自动化操作，https://github.com/youfou/wxpy ，功能非常强大，可惜了我几个微信都无法登录，好在有教练的帮助，最后也完成了作业。 &lt;下一步计划&gt;两个选择： 重读自学是门手艺，用2到3个星期的时间读完，并在GitHub上同步打卡学习进度。 自学 MIT OCW 6.0001 课程，用一个月的时间看完，并打卡。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100205-自学训练营18群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100205-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A518%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：谢挺英学号：1901100205 工作背景个体私营 自我介绍编程小白，偶然看到公众号上一篇关于编程的文章。觉得自学能力真得很重要，主要还是要锻炼自学能力。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100167-自学训练营18群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100167-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A518%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 姓名：徐响 学号：1901100167 学习内容：Python 14 天入门 学习用时：未知 学习笔记 Day1-9收获总结 print(‘%s%s=%s’%(x,y,xy),end=’\t’)在这种print函数中，前面字符串中%s会一一对应后面%（）中的元素。后面的end=‘\t’可以把每个结果之间以空格分开。 num1 =int(input(“number1:”))input接受键盘输入的内容，括号里的字符串为提示字符串。 range函数和for while一样也是循环range（x）：从0到x每次加1range（x，y）：从x到y加1range（x，y，z）：从x到y依次加z 列表函数，reverse（）将列表元素倒序排列[a]=[1,2,3,4,5]print(a[-1]) ###取最后一个元素[5]print(a[:-1]) ### 除了最后一个取全部[ 1 2 3 4 ]print(a[::-1]) ### 取从后向前（相反）的元素[ 5 4 3 2 1 ]print(a[2::-1]) ### 取从下标为2的元素翻转读取[ 3 2 1 ]是取二维数组中第一维的所有数据对于X[:,1]是取二维数组中第二维的所有数据对于X[:,m:n]是取二维数组中第m维到第n-1维的所有数据对于X[:,:,0]是取三维矩阵中第一维的所有数据对于X[:,:,1]是取三维矩阵中第二维的所有数据对于X[:,:,m:n]是取三维矩阵中第m维到第n-1维的所有数据数制： 进制转换Int（） 十进制Bin（） 二进制Oct（） 八进制Hex（） 十六进制 str字符串方法map=str.maketrans(‘*-.’,’ ‘)text=text.translate(map)maketrans函数可以替换字符串中的特定字符，但是参数中前后位置要相同，前面写了几个字符，后面也要有几个字符替换，可以用空格。text.split()split（）函数可以把一个字符串分割成列表，括号内可以指定某种特殊字符作为分割标志，也可以什么都不写，凡是遇到空格，分行等等都会分割。print str.split( ); # 以空格为分隔符，包含 \nprint str.split(‘ ‘, 1 ); # 以空格为分隔符，分隔成两个strset=(‘’.join(‘%s’%id for id in set1))把列表变成字符串，用join函数，第一个参数用‘’包括的东西就是合成字符串之间的间隔，一般来说是空格。a = text.split()dic={ }for x in a:dic.setdefault(x,0)dic[x]+=1之前的字符串已经被split分割成一个一个词的列表，要统计每个词出现的次数，先设一个空字典，然后用for 遍历这个字典，这里Setdefault(x,0)dic[x]+=1可以把每个没出现的key都加到字典里去，然后再次出现就键值加一。for k in sorted(dic,key=dic.getitem,reverse=True):b=sorted(dic.items(),key=lambda x:x[1],reverse=True)这两个都可以排序。 collections.Counter但后面知道更好的是用标准库中的collections中的Counter函数来实现排序c=Counter(dic[])c=Counter(‘str’) ##可以用各种格式，str，dict，set，tuple等等来输入Counter其中可以使用most_common（‘填写限制个数’）replace函数可以用来替换字符串中的指定字符如text=text.replace(‘better’,’worse’) list操作但如果在列表里，要移除或者替换有某种特征的元素，就要用for遍历for x in a:if ‘ea’ in x:a.remove(x)另外对于列表操作cmp(list1, list2)比较两个列表的元素len(list)列表元素个数max(list)返回列表元素最大值min(list)返回列表元素最小值list(seq)将元组转换为列表list.append(obj)在列表末尾添加新的对象list.count(obj)统计某个元素在列表中出现的次数list.extend(seq)在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）list.index(obj)从列表中找出某个值第一个匹配项的索引位置list.insert(index, obj)将对象插入列表list.pop([index=-1])移除列表中的一个元素（默认最后一个元素），并且返回该元素的值list.remove(obj)移除列表中某个值的第一个匹配项list.reverse()反向列表中元素list.sort(cmp=None, key=None, reverse=False)对原列表进行排序list()函数还可以将字符串或者元组转换成列表。 sys模块让模块可用import syssys.path.append(‘路径’)from xxximport stats_wordsys.path包含一个目录（以字符串形式）列表，解释器就在这些目录中寻找模块。Sys.path.append添加目录 异常捕捉异常，用途是使某些错误操作不至于导致程序整体崩溃，提出修改意见，保留修改的空间，Raise exception/TypeError/等等（）括号里可以写上提示语句。在函数里用了raise里之后，在调用这些函数的时候，使用try/except/else/finally捕获这些错误，再做其他处理 os.path用法file_path=os.path.join(os.path.dirname(os.path.abspath(file)),’文件名’)file_path就是文件的绝对路径打开文件的时候，遇到with open(‘文件名’,’r’,encoding=’utf-8’) as f:找不到文件的时候就可以使用with open(file_path,’r’,encoding=’utf-8’) as f:用绝对路径代替文件名。 Day10收获总结 第三方库的安装，在anaconda prompt终端中使用pip命令下载，然后在程序中用import调用，因为环境问题，在Windows中的命令终端无法操作，只有在anaconda的终端中才能操作。 打开文件的时候，若用open （***）则在最后需要用f.close();若用with open（） as f,则不需要f.close().12with open(file_path,'r',encoding='utf-8') as f: a=f.read() Day11收获总结 在需要输入密码的程序中可以用getpass函数 123456789101112131415import getpasssender=input('fajian:')password=getpass.getpass('mima:')recipients=input('shoujian:')requests函数和pyquery函数配合使用，requests请求网页，pyquery将抓取网页上的内容。import requestsr=requests.get('https://mp.weixin.qq.com/s/pLmuGoc4bZrMNl7MSoWgiA')from pyquery import PyQuerydocument=PyQuery(r.text)content=document('#js_content').text()&lt;!-- # 用python发邮件的格式： --&gt;import yagmailyag=yagmail.SMTP(user=sender,password=password,host='smtp.163.com')content1=str(a)yag.send(to=recipients,subject='Day11comevback',contents=content1) a为一个列表，要把a变为一个字符串。本来可以用b=(‘’.join(a)),但例如本例中列表a内容是[(a,1),(b,2),(c,3)…],这样的元组元素，不能直接转字符串，要使用如下形式：b=(‘’.join(‘%s:%s\n’)%id for id in a);特别要注意join后面的括号中%s的数量等于a每一个元素中的数量。 Day12&amp;13收获总结 wxpy模块使用wxpy将python对接到微信，有用。但我使用了19年，17年，13年注册的微信号，都根本登录不了wxpy，没有在网上找到可行的解决方法，只有碰运气，有的老微信号可以。 123456# 基本操作import wxpyfrom wxpy import *bot=Bot()myself=bot.selffriends=bot.friends() @bot.register 就是每一个功能的实现，在括号中不同参数的调用，对应了不同的对象和功能。例如作业中，实现一个接收 分享 类型的消息，然后使用词频统计的函数，得到结果返回给对方。 123456789101112@bot.register(friends,SHARING)def url(msg): # 从收到的消息（msg，SHARING类型）中抓取到文章内容转变为str格式 r=requests.get(msg.url) document=PyQuery(r.text) content=document('#js_content').text() # 利用stats_word函数中的stats_text.cn/en功能获取词频，排序，及取前多少个词 a=stats_word.stats_text_cn(content) # 把得到的消息回复给对方 msg.reply(a) return aembed() 其中，最关键的是回复函数msg.reply，一开始没用，就什么也没返回。另外friends（自定）=bot.friends()是选定对象，每个@bot.register功能后面的括号里，都要选定对象，没有选定的话，功能无法实现。 mabplolib库的使用将day12的词频统计功能使用mabplolib画成一个条形图表:12345678910111213import matplotlib.pyplot as pltfrom matplotlib.pyplot import plot,savefigplt.rcParams['font.sans-serif']=['SimHei']#这一行使得中文字可以显现b=Counter(dict(a)) #上个任务中得到的list类型结果，使用这个Counter(dict(a))将其变为Counter形式，也就是一种字典形式k=list(b)v=list(b.values()) #这两行是分别取Counter形式的b的key值形成列表k，value值形成列表v*plt.bar(k,v) #用这两组值形成一个条形图。plt.xlabel('词语')plt.ylabel('次数')plt.title('高频词统计')#给x，y，和总体命名。plt.show()plt.savefig('C:\\Users\\Administrator\\Desktop\\a.jpg',bbox_inchs = 'tight')# 这里是关键，得到了图的结果，但是没有保存，也没有指针，无法引用也无法发回给对方，所以需要使用plt.savefig(路径/文件名.后缀)来保存到本地一个地址。之后的引用需要用这个地址和文件名 将得到的图发还给对方 1msg.reply_image('C:\Users\Administrator\Desktop\a.jpg') day14 自学训练营总结 经过自学训练的13个任务，我对于编程有了更直观，有效的理解，不同于在学校学习C语音。在学校学习C的时候，完全不理解这是在干什么，只是按照指令，应付考试，考完之后就全忘了。而自学训练营 对于自学，我的感想是，要付诸实践东西，最适合自学的，换个角度说，自学某种技能，最好是要学以致用，首先要明白为什么学，做什么用，然后才可能在使用中强化记忆，最后变成自己的能力。特别是对于编程这样的一种普通人类思维很不熟悉的机器思维，更需要不断练习，要找到可以运用的地方。 我自己经过14天训练营，任务在教练的帮助下基本都能完成，但是除去给我的任务，我还并没有去通过我学到的东西做一些其他工作，写其他的代码，所以我觉得我现在掌握的知识还是很脆弱的，如果不用就会被遗忘。所以我在这个训练营结束之际，还找了一些其他的课程，参加学习，不能忘掉python的基础语法，要赶紧学习python的更多用途。 另外每天的任务给出的参考文档，英文文档我看着实在是太费力了，所以很多时候我都是自己在中文互联网中寻找解决方案，读的都是二手信息。这是这十几天我做的不好的地方，本以为有一定英语基础，但其实根本很难看懂英文文档，想要复习时候索引起来更是不方便，但实际上我知道英文世界的技术交流才是主流，所以想要进入编程领域，也要克服语言问题。 最后我还依然是一个菜鸟，对很多问题还一头雾水，对我所学习的编程还没有一个清楚的感性认识，每次一看网上的交流讨论，看到那些术语名词，非常茫然，另外我对于计算机科学还有一个疑虑：是否应该了解底层原理，再去学习应用功能，我对于计算机和编程语言的底层原理一无所知，我也能学会一些编程技巧，我们是踩着巨人和众人的肩膀上，在编程中我们也不会每个函数都自己写，而是会大量调用别人写好的函数，包，但不了解底层原理，我始终有种恐慌感，不知道是否应该这样。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100302-自学训练营学习20群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100302-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A520%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：何同辉学号：1901100302 工作背景湖南人文科技学院准大一 自我介绍一枚普普通通的高中毕业生，没有学习编程的经历，但希望学习编程，对自己以后的生活有所改变]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100123-自学训练营学习16群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100123-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A016%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Ellen -17学号：1901100123 工作背景医药临床监测服务行业 自我介绍想学习编程思维，为自己的人生多加一种可能。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100098-Python自学训练营16-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100098-Python%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A516-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：姜玲zero学号：1901100098 工作背景会计 自我介绍大家好，我叫zero，是一个女孩一个男孩的妈妈，住在内蒙古鄂尔多斯，是一名会计，从得到结识笑来老师，开始了自我升级之旅，想借助学习一门世界语言，零基础，学习期间给自己定个小目标，能跟下来，希望得到大家的鼓励和帮助，谢谢！]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030029-自学训练营5群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901030029-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A55%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：苏海琳学号：1901030029 工作背景目前是本科大三学生，未从事工作 自我介绍简单的个人介绍：本人爱看书，喜欢运动，享受成长带来的喜悦，希望和更多的战友在成长的路上奔跑。为什么想要学习编程：摆脱新时代文盲的标签，学习一项新技能，掌握自学的能力&lt;个性签名:人至践，则无敌&gt;]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>在校学生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050027-给这次旅程画上一个句号]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901050027-%E7%BB%99%E8%BF%99%E6%AC%A1%E6%97%85%E7%A8%8B%E7%94%BB%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%8F%A5%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[Day14 给这次旅程画上一个句号这篇文章比起单纯的讨论这个project，更像是一次自我剖析，所以不算是一个‘好’的README。 越接近最后一刻收尾变得尤为艰难，因为特别想给这段路程画上一个’完美’ 的句号。最后的实战练习感觉进入了状态，一鼓作气，但又很难像Day5作业那般在开头从0探索，面对新建的file随意的编写。没开始的时候觉得开始艰难，在路途中时又觉得坚持下去不容易，临近结束又觉得做个总结也有着纠结。开始让我思考为什么总脱离不了‘艰难’这种情绪。所以就让我从翻开以往的笔记开始吧。 petalsaya.getnote([0:12])Day1（4/7）迈出第一步，Github学习前先读了书，尽早开始了自由模式，在笔记中写道: 探索也是一种乐趣。 Day2 （4/9）本地环境配置，编写了最最基础的一句反馈函数print Hello World，安装了三次Anaconda，真的是各种状况频出呢。 Day3 （4/14）一个小小的计算器，先看一下完成日期，距离Day2的作业间隔五天了呢，不过我在其中做了2个优化：欢迎语句和计算器的循环，现在可以称赞那时的自己一句了不起。 Day4（4/15）这个是9x9乘法表，循环流程是Python逻辑的基础，推荐回顾笑来老师‘入口’和‘控制流程’两章哟。 Day5（4/20）数据容器，写的最纠结的一次作业，Day3是因为事情忙无法继续编写，Day5可能是花费心力最多的一次，做了很多的尝试，也为之后三天的作业打下了坚实的基础。 Day6 - Day8（4/22 - 23）都是在优化Day5的作业，这边三天合在一起，分别是Day6的函数，Day7的模块，以及Day8的异常处理，这两天给我一种柳暗花明的感觉。 Day9（4/26）标准库让我稍稍费了一点心，因为Day5编写的内容没走寻常路，用了operator.itemgetter()，返回的是tuple格式。吐槽一句：Day10-12用了collection.counter，返回的是List格式，Day13还是需要转tuple分别提出两个值进行画图。 Day10（4/26）看了同学的code，对比下，发现自己的语言写的啰嗦，臣服于collection.counter让我看到了编程简洁的魅力。 Day11 - 13（4/27 - 29）实战练习，在开始我以为越到后面越艰难，不是的，连续三天一口气完成了！从未有的畅快吧，外部应用模块的功能实在是太强大了，jieba,wxpy,matplolib等等，每个都有其独特的功能。编程所产生的互动，那种及时的反馈，真的是一种美妙的感觉。 对了，我在Day8写笔记的时候还立了一个Flag：总结一下自己看到帮助特别大的博客，乘此机会，一口做气的完成。 （列出的内容仅是帮助到我的部分，当然博客中包含了更多原创的博文。） 博主：Ruthless；python数据类型详解 博主：Python；字符串类型及操作 博主：风泽茹岚 ； Python 统计汉字的频率 博主：失心疯 ；单词堆中查找特定单词（正则表达式） 博主：jinruoyanxu；正则表达式-匹配中英文、字母和数字 廖雪峰的官方网站 ；装饰器 （包含很系统的对Python介绍哟） 仅仅是博客就收获良多，还不包括Google上其他的资料，一个属于自学者的时代。恭喜自己成功摘完一个Flag，顺便再立一个：回头一字不落的看完6.的全文。 以下为碎碎念警告：自问自答篇：Q：为什么有些人想做的比别人好，却能做到；而有些人却不能？A：人都有厌恶损失的情绪，那就索性在开始的时候大量投入，阅读各种的相关资料也好，和辅导员们交流也好，迅速达成多维度链接，这也算一种快速入门的技巧吧，也是为什么Day5之后的作业进度反而加速了。 Q：有趣的一面又是什么？孔雀开屏式的展示么？A：做自己。做那种让你舒服，开心的事情，投入进去，万一一不小心就开屏了呢，并不是所谓的展示，而是一种不自知的状态。 感想篇：不知道各位有没有体验过笑来老师所说的心流状态，时间仿佛加速了，不再是隔段时间看一下手机，而是完完全全的投入，美妙至极。但如果过度追求这种状态，期待一直保持，所以也造就了一味地延迟开始或者改变，因为不开始，才不会有不完美的出现，这可能是造成我心里波动的一个元凶。在加入训练营之前，我已经很长时间没有体验过这种感觉了。这种高度的集中，尤其是后面几天，我是特别特别享受的，包括现在在打这段话的时候。 我有的时候在想，什么是所谓的规律生活。我，是个生活极其不规律的人，在写这篇的时候是在凌晨，包括很多时候我写代码时也是，不知道是不是单纯享受这种安安静静的时光，还是想标杆立意。不过，我现在能区分的是一味地熬着不睡和实实在在的享受工作是不同的感觉。不过，我还是倾向于正常的作息，早睡早起，而一觉醒来的白天，工作起来则更为高效。可能这种时候，就需要一种平衡了吧。我仔细想想，如果一个人厌恶熬夜（比如之前的自己）那么熬夜这种行为就该停止；如果是因为干一件事入了迷，此时此刻可以去享受这种快感。有意识的选择，一觉起来就不会去后悔，是不是也未尝不可。当然这也是一种给自己熬夜合理化的办法吧，不过，现在和之前还有一点是不同的，就是不会一味地缩减睡眠时间。睡眠是一切一切的良方，题外话，美食也是哟，或者所有美好的东西都是，都值得去追寻。我有的时候惊讶于为啥能写出看着特别正能量的东西，有时却连自己都不能控制的进入‘丧’的状态。不过，事后，我会对自己说：你是得到了自己的批准进入了‘丧’的状态，来自于潜意识的。还有如何正确面对身体和心理的反馈特别重要。如果特别特别想改变，其实最好的方法大家都知道，就是立刻去做。‘丧’的时候凡是有一点清醒意识都可以“求救”，外人拉一把的力量不可忽视。所以我在Day11的总结里有写上一句给自己的话：不骄傲自大，也不妄自菲薄。因为过度的正能量是骄傲自大的一面，而‘丧’则是妄自菲薄的一面。 真的，太久没有这么写下来了，写作很像编程，就是把思路一缕一缕的记录下来，逻辑融洽。而且Code是给别的编程员读的，所以如何写的有逻辑性也尤为重要。同时，在打字的时候，有一种打字速度跟不上思路的感觉呢。 其实回顾这么多，想感谢的人也不少，自学营的各位：小温温，小楠姐，白哥，糖总，小伙伴们还有最初的何教练；同时呢还有Day11和Day12帮我测试微信功能的基友；还有糖果和笑来老师提供的平台（逐渐官方）。嘿嘿，写上这么多，再在名单上加上自己吧。感谢各位，这趟旅程玩得很开心~ 最后，我想放一段话：年轻人，无论面对多么艰难的战局，理论上都有最恰当的解决办法。越是混乱，越是想自暴自弃的时候，越是不能忘记这一点。By: 文豪野犬PetalSaya 2019/4/30]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030032-自学——为自己而学]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901030032-%E8%87%AA%E5%AD%A6%E2%80%94%E2%80%94%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%80%8C%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[自学——为自己而学 ####通过短短的14天自学python，我能够清楚的感受到自己的变化是非常大的。这个大可以说大到颠覆了我的世界观，人生观，价值观。你可能会觉得不就才14天学习训练，这怎么可能？吹牛也要打草稿呀。也是，那就麻烦你耐心看我打打草稿。 在看之前，先让你看下，我参加训练营前后的对比。 学习python语言编程前： 开营自我介绍： 学习python语言编程后： 最后一次编程作业，是用微信机器人做一个词频统计应用： 参加自学python训练营，在这个过程中，我都有以下这些收获。一、收获了python编程语言基础知识，编程这个世界的大门，我，打开了。 1、体悟到了，编程最重要的核心就是运算与流程控制。 想要用程序实现任何想要实现的功能，都绝对离不开运算。而想要实现智能多样化的功能，也必然离不开流程的控制。所谓编程，只不过是把想要用计算机实现的功能，用机器语言按照一定的顺序运算的一个流程，这个流程也可以叫线程。线程这个概念相信你很熟悉。 2、学会先把问题进行拆分。 最开始的时候，以为一上机就开始敲代码，然后到最后输出结果。这样往往没有结果。而后多次实操之后，开始学会了对问题先进行拆分，拆分之后，再用自然语言（中文）把整个流程梳理一遍，写出伪代码（伪代码这个概念学习编程后google我才知道）。而后，在用计算机语句把把整个流程敲进去，运行。对于新手的我来说，即使再简单的代码流程，也会不断出错，而后不断调试，我相信谁开始都是这样的，我也相信用着用着就自然而然的熟悉了。三思而后行，这个道理我觉得放在此处再适合不过了。 3、造物的理念。 为什么要编程？就是因为想更好的提高做事效率且现实中不存在这样的工具。想要实现什么功能，自己defined，配合已有的功能组件，针对性的创造算法（函数、方法）实现想要的功能。真的可以说是无中生有的，这难道不是在造物吗？学会了基本的造物理念，真的改变了我旧有的世界观。我以前觉得世间的一切，都是由特定的人在特定的时机创造的。而今，我也有能力去创造，就是这么自信。 4、明确编程知识在纵向结构上来说是有边界的，无非就是那么几块知识点。 我不知道你有没有过这样的感受。在学习编程之前，因为道听途说太多敢于编程难得言论，总觉得编程很难，因为它最起码要有英语能力，而后，需要很多的专业知识。就会觉得编程知识难到没有边界。越想越不着边际，大多数时候想学去学，因为脑子里总有这样的感觉萦绕，于是学着学着就放弃了。最终，从来都没有掌握好编程这个技能。这次的完整的学习，让我明白了，如果这就是全部的学习内容，那编程的知识也就那么几块。而且，学习下来，我也非常相信，编程的知识就这么几块，无非就是数据结构、流程控制、函数、模块、异常处理、标准库、第三方应用库。因为有了这些知识，你就可以去创造了。当然，短短的十几天学习，很精通那是不可能的。但，我可以确切的告诉自己，我入门了。因为，我能够做出一些简单的应用。这就够了。从此，我再也不会觉得编程的知识难到没有边界，它是有边界的，任何知识都有边界的。对于技能的精通，肯定还需要不断的对每个知识块深入的学习。一切刚刚开始，一切终于开始了……。 二、改变了对英语学习的看法，体会到了用英语的好处。1、对于编程专业性的英语单词的认知。 因为意思单一让人容易理解，记得牢，当再次看到学习过的单词能够一眼就明白它在文档中的意思，从而相对容易的理解整个英文句子所表达的意思，非常的有成就感。 2、改变了以往面对英语难的心理状态。 之前，一看到英语，就犯困，而且是头痛的那种困。即使那个东西再好，也不想在继续。而通过这段时间对于编程文档的学习，只要通篇翻译理解后，心里就会有这样的感受：其实，英语也就那么回事。不断用就行了。学会跟英语做朋友，真的能够体会到，它一定会把我带到一个我不曾想到过的世界。 3、对于英语的语句识别越来越有感觉。 我坦诚的告诉你我英语零基础。这段时间，不断用英语学习，能够清楚的感受到英语的语法习惯，大部分时候一个句子首先是主谓宾，而后再做谓语补足语。在句子遇到of后，正常情况下是翻译of后面的内容之后，再加个“的”，就变成of后面的内容是of前面的什么什么。这是自我感受和理解，当然肯定是存在不足的。但是，对于一个英语小白来说，我敢说这是一个非常大的跨越。其实反过来想，英语只不过是一门语言而已，相对中文来说，只是换了个表示符号和表达习惯上的略微差异而已。 4、明确了英语只有不断反复使用才能记得牢和用得好。 人嘛，在心智不成熟的情况下，总是想着做任何事情一步登天，而现实往往是不能如愿以偿。英语同样是这样的道理，别想着看一遍就能够记住（除非你是记忆力极强的天才）。要想记住英语单词，这次的学习，最大的感受就是不断的使用，而因为不断地用，陌生的单词反复出现在自己的眼前。一回生，二回熟，三回是朋友。别总说，你记不住单词，那是因为你用的少，看得少，抑或学习过单词就根本没有用过。 三、锻炼了自己的耐心与细心 学习是为自己而学，以作业为向导，反向寻找知识点来解决问题。对于英语python都是零基础的我来说，首先要解决英语这一个障碍，其次还要深入的思考理解解决问题需要用到的知识点。这些知识点，不曾出现过在自己的脑海中，而是需要自己一点点的去阅读获取。一时半会就是很难把需要用到的知识点找全，而且如果快速的浏览往往很多重要的知识点，它就好像跟你躲猫猫一样，你没有看到它，而它却看到了你。可是，这样的结果，就是对知识点，没办法做到理解，更别说运用了。为了解决问题，你需要逼迫自己再次阅读文档，细心耐心的反复看，只有在这样的时候，那些被你跳过的，遗漏的知识点，才会一个个的蹦跶出来。到最后面，这些一个个的知识点，通过耐心细心之后，已经能够在你的脑海中留下印象，而后因为知识点越来越多，他们自然而然的就串联起来，形成了解决问题的能力。 四、改变了自己对用浏览器的看法和搜索习惯1、用google浏览器而不用国内的百度、搜狗和360等等浏览器。 在此之前，我经常用搜狗搜索引擎来寻找自己遇到的问题。很多时候，越搜越迷糊，因为大多数时候搜出来的都是一些广告，即使有有解决方案，也很多是解不答题。通过这次自学python，我习惯了用google，因为每次google几乎都能够解决我遇到的问题，我没有理由不喜欢甚至爱上google。说再多，相信你很难感受得到，因为这个东西，只有你去搜你才能够真正体会到。我给你看下google对于同一个问题的搜索结果和搜狗搜出来的结果对比。如图： 可以看出来，google更像是一个问题解决库的通道，而搜狗更像是一个商场入口。 2、这个过程中学会了遇到问题，先自己思考，思考不出结果时，把“笼统”的问题拿到google搜索。 不断查阅，不断发现重要的知识点和解决问题的方法。调试bug时，如果遇到不理解的报错，就把报错的类型直接复制而后google，再次搜索。搜着搜着，你就能够很清楚的明白自己遇到的是什么问题。而后再用言语精确的描述遇到的问题，再搜索，这个时候，肯定能够找到想要的答案。遇到的问题，就怕问的精准，只要精准，google就一定会给你精准的解决方案。 3、从此以后，可以说习惯了有事问google。 只要用心提炼问题，耐心查找，你的问题99.99%已经有了答案。Google是一个非常大的图书馆，而不是商场。 五、锻炼自己的思考能力，也就是锻炼自己的大脑。学而不思则罔，思而不学则殆。 学习新得东西，是为了自己能够掌握它，运用它。但前提是你必须把这个新的东西通过思考而后理解。理解它的来龙去脉，理解它的功能，一个个知识点不断思考不断突破，而后再把这些思考串联起来，运用。我们做作业的目的就是把自己的思考，通过完成作业的目的来给自己寻求反馈。在这个过程中，我对自己思考是否深入的最基本判断条件就是作业是否能够通过自己的思考理解完成。完成作业最重要的标志就是，能否把代码运行好，实现想要实现的功能。 六、体会到要学好做好一件事情，需要寻找好的工具做辅助。1、工欲善其事必先利其器。 学好、做好一件事情，利用好的工具，可以做到事半功倍。这次学习编程，我们用的编程工具时anaconda中的vscode（visual studio code可视化代码工作室）。这个工具，自认为对新手来说是非常友好的。它可以让你在编程的时候，把代码敲好之后，直接就可以在同一个窗口运行。之前，自己也尝试过学习python编程，在敲代码前，需要建一个单独的py文件，而后运行的话，需要通过开始调用idle这个python GUI，显得非常的麻烦，效率一点都不高，很不友好。而vscode敲代码运行代码的效率完全可以碾压python自带的编程工具。 2、通过编程社交平台这个工具，可以极大提升学习效率。 我们运用github这个代码托管平台工具，来实现对遇到的编程问题进行提交issue来相互探讨与解决。·每个人遇到的问题，都有可能是自己遇到的问题或是自己将要遇到的问题。通过查看issue，能够精确的获取自己问题的解决方法。 3、也就是上面提到的浏览器问题，用google绝对可以让自己变得更聪明。 你看，我的收获不少吧，可能你还会觉得这些收获都是我编出来的。嗯，有这个可能。但是，如果我告诉你，我在收获这些东西的时候，都为此做了一些什么，你大概率就会相信了。 自学python这个过程具体做了哪些事情？1、时间精力的投入，这是最基本的条件。 文章开头，你应该知道我的职业是什么。不过某种意义上来说，我能够入门还要感谢这份工作。这份工作，概括为955吧，每天早上八点半上班，下午五点半下班，中午十二点到两点半休息。上班的时间加起来一天有六个半小时。而我的工作是简单的计算机运行维稳，一般情况下，整个单位的计算机是非常乖巧的运行，不出问题。自然我的上班时间就只能乖乖的坐着了。这下可好了，我可以利用这上班的时间，自学python。因为，编程零基础，所以为了理解编程的每个知识点，就必须投入大量的时间去思考理解。每天的作业都是通过上班和下班后的时间慢慢的持续的学习才理解而完成，每天如是。这样算下来，一天投入到编程的时间可以说超过十个小时。也因为有了这么多的时间投入，我才能够理解到那些重要的编程知识，才能够入门python编程语言。 2、每天不断总结，自我对话，每天3000字，总结整个作业用到的知识点。 这一点，我是看过笑来老师曾经的一篇文章，那篇文章，说的就是他从20多年前就开始尽量每天写3000字。他说他写的那3000字不要求写得有多好，即便是麻将桌上的段子都可以写进去。但是也不可能是为了凑够3000字而凑数字。因为要写出3000字，你的大脑就必须在不断地思考才行。起初，我第一眼看到3000这个数字，就心生畏惧。因为，自己一直以来都非常害怕写作，总觉得写出来的东西，“别人”看了会说不够好。注意，这个“别人”就是我一直不敢动手写文章的罪魁祸首。看了笑来老师每天写3000字的这文章之后，被他的理由征服了。于是，从2019.2.26开始，我尽量每天写3000字。把自己想说的话，都写出来，想到什么写什么。第一天，第一篇，我花了足足三个半小时，才写完，从晚上9点开始写，一直写到凌晨12点30.打字速度慢，语句表达困难等，都是非常浪费时间的操作。不过写完之后，有一种莫名的成就感和愉悦感。只不过，手有点僵而已。但是还是非常开心。 于是，不知不觉一个星期过去了。每天写3000字，好处真的如笑来老师所说。于我而言，我发现我多了一个朋友，那个朋友就是过去每一分每一秒的自己。知心，我们两个无话不谈，我把自己遇到的问题，敲打出来，自己跟自己对话，写着写着，问题解决的方案居然自动跳了出来，跳出来之后，我再敲打出来，而后，在生活工作中实践。实践最大的改变，就是对待老婆的态度以及跟她两人世界的缠绵，这里就不明说了，推荐你去看看笑来老师的那本‘书’《挤挤都会有的-写给女生的性高潮指南》。而且，我发现我的打字的速度，明显提高了很多，到现在有时候3000字可能不到2个小时就写完了。因为3000字不是一时半会就能写完，每天写那么多，每次坐在凳子上写，一坐就是2个小时以上，不自觉的就锻炼了我的做事耐心。最重要的是我能够感受到自己思考能力在不断加强。到现在早已经习惯了3000字，对这个数字没有任何的畏惧感。我知道我的表达能力非常的欠缺，写出来的话，啰嗦。但是，这又何妨呢？我能够通过这些文字让自己更好的去理解这个世界的万事万物就够了，真的。其实，我说这些并不是在晒什么，而是，我想告诉你的是，既然你想写作，那就直接写吧，有什么话都写出来，持续写就可以了。你会发现写的好处的，不要去在意自己的言辞，也不用去在意别人的眼光。给你看看我走过的这一个多月： 请自动忽略标题。。。。 所以到了3月24，开始自学python，我每天就把自己在自学过程中，所理解到的知识点，再次通过自我对话，写出来，发现自己对知识点的理解似乎又有所增加。把自学过程中遇到的问题也记录下来，把问题刻入自己的脑海中，心心念念。我非常相信对问题心心念念，而后必有回饷的言论。真的，很多时候，在学习第二天的编程知识之后，前一天的问题，好像自动被解决了一样。解决了心里问题，心情自然舒畅。 3、不断调整自己的学习方法与思路。 自学第一天，刚好是碰上星期天，可以有一整天的时间来学习。于是，慢慢的看文档学习，每个英文单词都不断的查询，然后全部单词查完后，自己尝试理解，不理解的话，再把整个句子都放进翻译词典里翻译，再一个个的对照着理解。自然，这个过程是非常耗费时间的。于是，一遍不算太长的文档都花费5-6个小时，才搞完。不过，能够通过不断翻译理解，最终看懂文档，心里的成就感是非常强烈的。但是随着学习内容的进一步增加，对于我这种英文零基础的人来说，可能一整天对着英文文档都不一定能够理解全，理解透，那么很自然就会导致作业没法及时完成。 于是，打开word，开始自我对话，反思自己的学习路径和方法，反思参加这次训练营的最本质目的。也就是笑来老师常说的，做一件事情，什么最重要？这样的价值观。最终，自我对话做出了这样的思考：英语固然重要，但是参加这次“自学python训练营”最重要的是通过自学python编程习得自学能力，同时习得编程能力，再者是学会用英语（用英语的好处我在第一天已经体会到了)。有了这样的思考之后，从第二天开始，对于文档的学习，我选择用中文。更多的是用心认真的去理解作业涉及到的知识点，一点点的死磕。对作业的完成，不明的就google，不断search，search，research。因为有了这样的选择，我每天都能够按时完成作业，每个作业需要实现的功能，我都通过自己敲代码实现。一直坚持到python知识学完。自我觉得在训练营期间跟上训练营的节奏才是最重要的，因为只有跟上节奏，你才能够知道自己走到了哪一步，你才能够体会到编程知识结构的边界，你才能够因为跟上节奏而不断的向前前进。现在回头一看，我很庆幸自己能够做出这样的选择，因为很多同行者，在走着走着的时候，已经不见踪影了。不过，每个人都有每个人的选择，以上只是我个人的思考后的选择而已。 4、调整情绪，感受自己的变化，给自己鼓励。 转眼14天快过去了，感慨自己在英语和编程都是零基础的基础上，都能够拿到毕业证书。不断调整自己的学习方法，固然很重要。但是，在这个过程中，对于从来都没有过自学经验的我来说，有两次就差点放弃跟上训练营的节奏。我清楚的记得那是在数据容器和流程控制那两天。因为，阅读和作业量都相对前面的作业量要大很多，又因为自己理解知识点的速度慢，所以那两天都是到了晚上10点之后才开始做作业，敲打好代码之后，不断尝试，报错，再尝试，报错再尝试，这个时候，放弃的念头已经开始涌上心头。但，很快，我就用这么一句话说服了自己：过往，多少次自学，就是因为中途畏难放弃了，才导致今天还一事无成。卧槽，这对我来说，绝对是鸡血。于是，马上把放弃的情绪甩在一边，告诉自己一定可以。当然，最后面自己的确可以。淌过了那两天，慢慢发现自己学习编程越来越有感觉，什么循环、分支、定义函数、缩进、字母大小写等等等，都能够在脑海中重现它们。走到今天，我知道，我已经重生了，我不在是过去自己。因为，现在的我习得了自学能力编程能力。 5、总结自学过程。 通过训练营，我心里已经有了这么一个自学的方法论，因为是自己的方法，那就是一种能力。开始学习新东西–&gt;先google学习学习方法–&gt;找到好的学习辅助工具–&gt;用实战演练作为学习的驱动器–&gt;阅读官方文档–&gt;思考过后用google–&gt;解决问题–&gt;回顾总结知识点。提出问题，思考解决问题的方法，解决问题。按着这么一个流程走，就实现了需要获得的新技能。把学习流程化，遇到不理解的问题，不断循环反复，理解之后，进行下一步。不断践行，不断成长。成长为自己想要的那个自己。在自学这条路上，没有什么是学不会的。 到现在，不知道你对我开头说的那些话，是否还觉得我在吹牛，如果觉得是，那就是吧。不过，我还会一直的吹下去的。 当然这个过程，自己还存在很多不足的地方。 1、因为过往的学习生活工作习惯，遇到问题，先苦思冥想，虽然惯性在不断地被改正，但还是存在这样的问题。 2、对于社交学习这块做得不到位，更多的时候都是遇到一个问题死磕，从而浪费大量的时间，学习效率不高 3、细心程度还不够，还需要不断的刻意训练。有些时候，因为一个缩进就导致程序无法运行，很多时候因为一个字母的大小写问题，而一直报错，很多时候因为遗漏了个参数，而一直不得正解。 ##寄语 专注做一件事情，最后一定会有所收获。14天训练营时光，转瞬即逝，逝去的是时光，收获的是自学能力和编程能力。感谢这一路一起陪伴的同学和辅导员白雨童和教练。也非常感谢自己在不断挣扎的时候，在书里遇到了笑来老师。因为您，我才开启了我的思考人生。一切才刚刚开始，一切终于能够开始了。路很长，我要不断学习自学再学习，不断践行践行再践行。加油！]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010071-关于入门我是被一脚踹进来的]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901010071-%E5%85%B3%E4%BA%8E%E5%85%A5%E9%97%A8%E6%88%91%E6%98%AF%E8%A2%AB%E4%B8%80%E8%84%9A%E8%B8%B9%E8%BF%9B%E6%9D%A5%E7%9A%84%2F</url>
    <content type="text"><![CDATA[关于入门我是被一脚踹进来的作者：李龙斌(自学训练营学习2群) 学完14天编程营最直观的感受就是： 通往编程的门是窄的，我被编程营一脚踹进来了，然后我拿着手里的三两贝壳，望着远方的大海愣住了。 之所以有这个感受，是因为听过自学小能手许岑讲过他自学钢琴的故事。许岑为了逼自己，买了最贵的钢琴，找了最牛的老师。钢琴老师并没有一板一眼的从头教他弹钢琴，而是问了他一件事。 你学会钢琴后最想弹的是哪首曲子？ 许岑说了，然后钢琴老师在接下来一段时间里教会了他弹这首曲子。许岑先是不解，后来开心极了。因为能够直接弹奏他最喜欢的曲子，所以他学起弹钢琴来更有兴趣了，即使从最基础的练起也不太容易放弃了，最近听说的是许岑一天要练十个小时左右的钢琴。 所以我们参加这个14天的编程训练营不是为了让我们在能14天内就编程打遍天下无敌手，而是通过一系列作业让我们快速入门的，甚至在最后通过一个微信机器人实例让所有学到这的人知道怎么用起来。当编好的机器人把朋友分享过来的文章拆解成文字并返回一张统计图片的时候，自己获得的那种幸福感是极其强烈的，接下来就会想着怎么把学到的这个东西用到其它地方去，让自己获得更多的快乐，会上瘾！ 如果14天编程营没有让你享受到入门的乐趣，那是编程营的错;如果你从此就以为自己掌握了编程，那是你的错。 一路兵荒马乱的跑完14天的课程，我虽然勉强入门了，但自己的基础是不牢靠的，前面也说了，当然这也是李笑来老师一直强调的。 速成绝无可能，但快速入门是可以的。 《自学是门手艺》如果现在再去看的话，一定已经打开了一层封印，我可以理解更多的东西了，我后面要做的事情估计也是老生常谈了。 书读百遍，其义自见。无他，唯手熟尔。 最后要感谢的是一路前进过程中的各种小伙伴们，还有教练和助教的默默鼓励和支持。每次自己写的程序出了问题的时候或者编不下去的时候，看着一个营的小伙伴在默默提交作业，自己都在想，那么大的人了，赶紧滚去再写。 每次写完作业和总结交上去的时候总会得到教练、助教和辅导员的鼓励，开始的时候不觉得怎么样，但到后面编程编到怀疑人生的时候得到鼓励还是觉得心里面暖暖的，然后就一路摸爬滚打向前了，以后我也要经常去鼓励他人，期待在远方的时候我们再见！ day13这个做图一开始看着挺令人犯难的，因为前一天返回的数据不知道怎么拿来用，看了下别的同学的成果才知道，需要把结果字典化。 123result = dict(text) keys,values = zip(*r_dic.items())# 利用keys和value把词组和词频分开来用 然后再利用阅读材料中给定的表格编制样本，稍微调整改一下参数，就运行起来了，登录自己的小号，发文章测试了下，得到如下结果： 其中在测试的时候图标中的文字一度不能显示为中文，是一些框框，看了issues中的同学的方法才解决的。直接在issues中的Filters搜索：1710可以找到这个问题。win系统解决方案如下： 12plt.rcParams[&apos;font.sans-serif&apos;]=[&apos;SimHei&apos;] # 加在下一句前面ax.barh(y_pos, frequency, xerr=error, align=&apos;center&apos;, color=&apos;green&apos;, ecolor=&apos;black&apos;) Day12今天的内容直接开始玩微信自动回复了，好玩。按照介绍编好了自动回复程序试运行起来，然后直接跳出一个二维码出来，扫描后微信网页登录。初次运行的时候老是跑不起来，然后检查了下自己的代码，发现是代码输入有问题。再次运行的时候，显示已经登录，然后给我匹配的朋友发了句： 请给我分享一篇文章 感觉自己特别像个机器人，但是朋友文章分享过来后返回的内容有问题，再次查看，还是有输错的代码，再次重输调试。最后终于运行成功，给对方返回了day11的字词统计，中英文一起统计，瞬间幸福感爆棚。 从今天开始，感觉前几天的内容串起来了，一遍又一遍的让我们调试自己编写的函数，就是让我们对函数有更加深入的了解，从而在调用别人的函数的时候不会有太大的生硬感，然后对python编程有了更加深入的了解。 内心对这些开源程序大牛更加佩服了，他们搭好一个又一个积木，让后面的人能拼出更牛的作品，而且是完全免费开源的，开源世界真是太棒了。 Day11今天的作业就比较好玩了，直接上手了实用的内容。采铜是一个我很喜欢的作者，没想到今天的作业是要把采铜一篇爆文中所采用的办法用python程序来实现，而且一劳永逸，内心不禁泛起了欢乐，不知道采铜知道了会怎么想。 我想今天的内容已经接触到了网页爬虫，用的是这个库： requests 比较厉害，抓到网页后需要处理，尝试只在抓取后用print()函数测试抓到了什么，结果显示空白。然后需要用到的是这个库: PyQuery 这个库我也用print()函数测试了下，第一次处理打印出来的是一大堆网页编码，文章混杂在其中，必须要用到作业中的第二步处理方法，打印出来的就是文字了。 然后就是愉快的用我们自己前几天编好的函数进行处理了，其中一步会用到 str() # 将结果转化为str类型 这一步必须进行，否则的话邮件是发不出去的，会报错。 然后就是编辑设置getpass和yagmail进行结果邮件发送了，必须注意的是要设置邮箱smpt码，然后用这个码发送要方便点。 Day10day10的作业是要求词频统计，要求引入一个外部的库结巴,听起来很傻，但确实一个厉害的断词的库。结巴一共有三种模式： 全模式、精确模式、搜索模式 作业要求的是精确模式。这是一个很神奇的库，有点类似于我们小学时候老师教的断句。 我/来自 /云南省/曲靖 以前是我们用自己的小脑袋来识别断句，现在是教会程序断句，我们直接调取来用就行了。 想想我们现在所调试的函数，封装起来的话也算是勉强拿的出手给别人用用的库了吧。 最后就是open(),close()与with语句。在使用open()函数的时候，一定会加一句file.close(),例如《自学是门手艺》第一部分第7章的例子： 123f = open(&apos;test-file.txt&apos;, &apos;w&apos;)print(f.name)f.close() 因为文件用完必须被关闭，不然的话会占用系统资源，且系统同一时间能打开的文件是有限的。 因为每次都这么写都太繁琐了，所以python把这个close()函数包裹进了with语句中去，直接写： 12with open(...) as f: f.write(...) 就好了，不用再加上close()函数在结尾了。 Day9改写了好几天的函数，对函数有了一点点更加深入的认识.今天布置的作业是要在前几天作业的基础上加上collections.Counter most_common([n])这个函数，当看到这个函数中这一行介绍时有点难过 12&gt;&gt;&gt; Counter(&apos;abracadabra&apos;).most_common(3) # doctest: +SKIP[(&apos;a&apos;, 5), (&apos;r&apos;, 2), (&apos;b&apos;, 2)] 意味这我前几天写的函数是一个重复啰嗦的函数，而我只要调用已经封装好的函数，我写的那几行代码完全可以删掉了。于是我原本的函数： 12345678910111213141516import redef stats_text_en(t_en): if not isinstance(t_en,str): raise ValueError(&apos;输入的不是文本格式，请重新输入：&apos;) &apos;&apos;&apos;英文词频统计&apos;&apos;&apos; a = t_en.replace(&apos;,&apos;,&apos;&apos;).replace(&apos;.&apos;,&apos;&apos;).replace(&apos;:&apos;,&apos;&apos;).replace(&apos;;&apos;,&apos;&apos;).replace(&apos;&quot;&apos;,&apos;&apos;).replace(&apos;!&apos;,&apos;&apos;).replace(&apos;?&apos;,&apos;&apos;).replace(&apos;、&apos;,&apos;&apos;).replace(&apos;，&apos;,&apos;&apos;).replace(&apos;。&apos;,&apos;&apos;).replace(&apos;“&apos;,&apos;&apos;).replace(&apos;”&apos;,&apos;&apos;).replace(&apos;：&apos;,&apos;&apos;).replace(&apos;；&apos;,&apos;&apos;).replace(&apos;\n&apos;,&apos;&apos;).replace(&apos;！&apos;,&apos;&apos;).replace(&apos;？&apos;,&apos;&apos;).replace(&apos;/&apos;,&apos;&apos;).replace(&apos;*&apos;,&apos; &apos;).replace(&apos;--&apos;,&apos; &apos;) a = a.lower() a = re.sub(&quot;[^A-Za-z]&quot;, &quot; &quot;, a) a = a.split() b = &#123;&#125; for i in a: count = a.count(i) r1 = &#123;i:count&#125; b.update(r1) c = sorted(b.items(),key=lambda x:x[1],reverse=True) print(&apos;英文单词统计频率如下： \n&apos;,c) 可以精简成如下函数： 1234567891011import collectionsimport redef stats_text_en(t_en,count): &apos;&apos;&apos;该函数返回一个英文单词词频统计，样式为（word,count）&apos;&apos;&apos; if type(t_en) == str: text_en = re.sub(&quot;[^A-Za-z]&quot;, &quot; &quot;, t_en.strip()) enlist = text_en.split() return collections.Counter(enlist).most_common(count) else: raise ValueError(&quot;输入不为字符串&quot;) 还有就是几乎可以嗅到一件可怕的事，那就是我好几天就看到counter函数了，而我只要在官方文档里查查看就可以试着拿来用，而我没有，这就意味这我的“未经声明，不能引用”的内置程序启用了，得赶紧删除了。 ======= upstream/master Day8短跑过半了，坚持，坚持！ Day7又是在前一天的基础上完成任务，虽然看着很简单的，但依然折腾了一天，开始是在jupyterlab上测试，老是显示错误，后面在Terimal中测试又可行。我把anaconda,jupyterlab等全部升级了一遍后不显示错误了，但还是有地方不对，因为第二个调用函数，虽然执行了结果，但会返回连个None,None.不清楚，不明了。 Day6心得如下： 1.进行到这一部分的时候干了一件蠢事，因为一看到要做一个函数，心理比较慌，下意识的去看了下别人是怎么做的，意图参考，然后我渡过了最难过的2天。 别人的鞋不合脚呀 想了一下午才想明白，其实day6的内容早在day5就完成了一大半，我只要把day5的内容改装一下封装进day6的函数就可以了呀，真是蠢到家了，然后在1个小时内就把两个函数写出来了。 2.别人的作业也不是不可看 但要合理借鉴 我参考过两个同学的作业，一个同学写的简单，但两个函数只能单独统计。就是一个函数只能统计纯英文，另一个函数只能统计纯中文。 然后是1班同学的，那叫一个复杂，直接调用了collections（集合） 和 re（正则表达式）模块，看不懂，想抄都没有办法。 我的作业本来也是两个函数分开统计纯英文或者纯中文，但我实在想改进一下，让函数能够区分中英文，在统计英文的时候去掉中文，统计中文的时候去掉英文。然后就注意到了尖子生的正则表达式。 虽然不懂，但不妨碍我拿来用。 试了一下调用正则表达式模块，果然可以用，心理高兴极了，吃饭都嫌麻烦，调试了半天。 3.我现在把这个正则表达式函数列出给大家看看，以防大家可以用到。 123456import re # 调用正则表达式模块a = &quot;simple is better than complex简单比复杂更好&quot;b = re.sub(&quot;[^A-Za-z]&quot;, &quot; &quot;, a) # re.sub(pattern, repl, string, count=0, flags=0)c = re.sub(&quot;[A-Za-z]&quot;, &quot;&quot;,a) # 注意A前面的^,对比下结果你应该明白这个符号是干嘛的print(b)print(c) 输出结果 12simple is better than complex 简单比复杂更好 另外，大家感兴趣可以根据我的学号去看看我的作业，在大作业仓库的exercises文件夹中，应该相对简单一点。 Day5一天不敲代码，现在总觉得心里面空唠唠的。今天是清明节假期，敲代码上瘾。 这一次的收获： 1.慢下来总能对代码有所理解的，学习后面的内容总能对前面的内容有更进一步的认识和理解。 2.怕麻烦真的好费钱呀 怕麻烦的人的钱都被不怕麻烦的人赚走了 3.假期要拿来好好学习，要好总结下《自学是门手艺》第一部分的内容。 Day4今天有点难过，任务是编一个乘法表，要求用for…in..等语句完成任务。我翻看了这一章介绍后，感觉无从下手，就像给你工具，材料，然后让你砌墙时，从来没砌过墙的你拿着工具盯着作业场地有点茫然。没有办法，还是先看看别人是怎么完成的吧。搜到几个教程，很花哨，有花式排列乘法表的，有加了制表函数，做成带框表格的。没有理那些YYJH,我还是找了个自己看得懂的慢慢琢磨。 老司机才炫技，新手还是乖乖跟着开慢车吧。 心得要点1.for循环跟range()函数是个固定搭配，例如： 12for i in range(10): print(i) 这个表达式会列出0-9这10个数字。 2.过程中我是先照者别人的写一遍，可以执行后，我又换个参数自己慢慢写一遍，看不懂的地方我就挪挪位置，换个方式，改变下参数看看会有什么变化，以便自己可以更理解这个写法。比如最开始的乘法表我把&lt;print ()&gt;这一行去掉了，也能运行，但结果是没有阶梯排序的乘法表。虽然还是不理解是什么原理，但我知道了这一行的重要性。同理我把去偶数乘法表最下面的&lt;y += 1&gt;,和&lt;x += 1&gt;去掉后,引发了程序的无限循环，看来这两行也挺重要，应该是终止循环的语句。 3.在第二个去除偶数的任务中，参照了别的编程营小伙伴的作业，但觉得他们那个编写方法看不明白，我就想起了不是有break语句吗，怎么都没人用，我就自己尝试了下，写入： 12if x % 2 == 0: # 如果x除以2余数为零，说明是偶数，那么就终止 break 敲入结果一看，果然把左边的偶数干掉了，不禁有点小开心，貌似是比小伙伴们找到了个更好的解决方案。 Day3今天的课程是要编写一个计算器，如果说前两天是带你认识工具的话，今天直接就要你用工具做出一个产品来了。画风不对呀，虽然有说明书，但怎么感觉中间少了n个要学的东西，懵了。 还好我们有“老师”–“谷歌，必应”，大作业仓库，厚着脸皮先看看尖子生是怎么写的，再把别人的计算器“拆了”，自己组装一下。 看了下别人的程序实现，有超级复杂的，调用了tkinter模块，直接输出了一个计算机可视化界面，跟win上的类似；也有超级简单的，只调用了int(),input(),print()函数利用if语句就实现了；也有隔壁的尖子生，直接定义函数实现的。 我照着最简单的方法敲了个最简单的计算器，不仅有“加、减、乘、除法”，我自己加上了“幂、余”都能实现，然后我发现原代码不支持小数计算，翻看了一下函数那章，换了个float()浮点数函数就可以实现小数运算了，代码如下： 12345678910111213141516171819# float()支持小数运算# 如果用int()函数的话就只支持输入整数# input()接收键盘输入a=float(input(&apos;请输入数值1&apos;)) b=input(&apos;请输入运算符号&apos;)c=float(input(&apos;请输入数值2&apos;))if b==&quot;+&quot;: print(a+c)elif b==&quot;-&quot;: print(a-c)elif b==&quot;*&quot;: print(a*c)elif b==&quot;/&quot;: print(a/c)elif b==&quot;**&quot;: print(a**c)elif b==&quot;%&quot;: print(a%c) 然后我试了试第二种方法，也是可以用的： 123456789101112131415choice = float(input(&apos;请选择运算： \n1.加\n2.减\n3.乘\n4.除\n5.幂\n6.余\n请选择你的算法： &apos;))num1 = float(input(&apos;请输入第一个数： &apos;))num2 = float(input(&apos;请输入第二个数： &apos;))if choice == 1: print(&apos;&#123;&#125; + &#123;&#125; = &#123;&#125;&apos;.format(num1, num2 ,num1+num2))elif choice == 2: print(&apos;&#123;&#125; - &#123;&#125; = &#123;&#125;&apos;.format(num1, num2 ,num1-num2))elif choice == 3: print(&apos;&#123;&#125; *&#123;&#125; = &#123;&#125;&apos;.format(num1, num2 ,num1*num2))elif choice == 4: print(&apos;&#123;&#125; / &#123;&#125; = &#123;&#125;&apos;.format(num1, num2 ,num1/num2))elif choice == 5: print(&apos;&#123;&#125; ** &#123;&#125; = &#123;&#125;&apos;.format(num1, num2 ,num1**num2))elif choice == 6: print(&apos;&#123;&#125; % &#123;&#125; = &#123;&#125;&apos;.format(num1, num2 ,num1%num2)) 以用带练，多学多用！ DAY2今天在运行hello world程序的时候踩了个莫名其妙的坑，那就是输入print函数括号里面的点符号踩的坑。我开始输入的是esc下面那个`，因为为看着别人好像也是输入的这个，然后程序一直报错，我快疯了，后面换了”才没有报错，最后我才发现是这个’（“不用shift的’)。 建立hello_world.py文件的方法有三种：1.在vscode中可以直接通过点击建立。 2.通过终端建立，在cd 文件夹后，输入 12touch hello_world.py` 这个方法在windows中会报告错误，没找到解决方案，我是在电脑上用virtualbox安装了ubuntu系统然后在Ubuntu系统中的终端上实现的。 3.直接在jupyterlab中建立一个hello_world.ipyb文件。 执行hello_world.py的方法有三种：1.打开终端，cd打开hello_world.py程序所在的文件夹,执行 1python hello_world.py 可以看到输出结果 2.在vscode中右键单击hello_world.py再点击在终端中运行也可以看到输出结果 3.在jupyterlab中直接shift+enter，也可以直接看到输出结果。 DAY1今天进行了自学营的第一次训练，本来以为自己已经早就熟练掌握了github的创建仓库，提交更改之类的，但是今天发现自己仍然只是知道一部分。参加自学营前参加了刘娟娟的”you can you up,no bb”以为自己闯过了第一关，守关人跟我说你并没通过的时候，我理直气壮的跟他说，我完成了呀。守关人并没有说什么，让我去了第二关，今天才知道我真的是没有通过，人家一看截图，没有分支，没有commit，真是懒得理我。学习真的是切记骄傲啊。]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020025-给人生嫁接一次新的可能]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901020025-%E7%BB%99%E4%BA%BA%E7%94%9F%E5%AB%81%E6%8E%A5%E4%B8%80%E6%AC%A1%E6%96%B0%E7%9A%84%E5%8F%AF%E8%83%BD%2F</url>
    <content type="text"><![CDATA[给人生嫁接一次新的可能手艺人的画面小时候家里有一片苹果园，父母经常会整日在里面劳作，做些除草、打药的”粗放”型农活，即使像”人工授粉”这样听起来很精细的活，也没什么技术含量，基本上一学就会。唯独有一种活我却从来都没有尝试过，甚至都没有尝试过去学习一下—-那就是”嫁接”，在我们家，他几乎是父亲”独占”的”手艺”。尽管父亲各种农活都是把好手，还会结网、补网、撒网以及使用其他各种工具捕鱼，但是，只有给果树嫁接的时候，他在我眼里才是真正的手艺人。 当我回忆起苹果园里的时光的时候，差不多总有一个特写是父亲在午后并不强烈的阳光下半眯着眼睛，把两支原本并不相干的树枝小心翼翼的对齐放到一起，然后非常有仪式感的用布绳慢慢的不松不紧的把两根树枝的连接处细密的缠起来。也许我只亲眼见过有限几次甚至也许只有一次，但是，整个过程就是在我脑子里留下了深深的印象，甚至都能用定格动画在我脑中反复回放，也许，就是因为其中蕴藏的就是专注之美、创造之美、新生之美。 参加这次培训营之后，我的脑子里又不断闪现这个片段，我告诉自己，也许现在我也在学习”嫁接”——技能嫁接。因为直观的来看，学习一项新的技能，本身就是在”老树”上嫁接新枝，生长存活合一后，开出不一样的花结不一样的果，既是同一棵树，也不再是同一棵树。另外，巧合的是，编程其实也是如此，也是把一串代码”嫁接”到另一串代码上，看是否能够存活生长发挥功用。 嫁接即新生想学编程不是一天两天了，为此也做过很多努力，跟着网络课程自学过，也花大价钱报过班，但是说实话，感觉只有这次是无限接近学会的一次，我无比坚信这次一定能习得一些东西，或者说已经习得很多东西。 仅仅通过阅读学会技能仅仅通过阅读习得一项技能，首先是可能的，其次是必须的。 参照笑来老师通过阅读学会游泳、台球的经历，我在参加此次训练营之前就上wikiHow上查了“如何学会自由泳”、“如何学会蝶泳”，目的是为了纠正我野路子“自创”的“我式自由泳”和“我式蝶泳”，效果十分明显，所以，我知道阅读“正版教材”本身对技能提升有重要意义，但是对一项全新的技能来说，”仅仅通过阅读就能习得”这一点我还有一些怀疑。然而这次训练营基本上打消了我的顾虑，真的是靠自己阅读，遇到问题再搜是不是有同学遇到过解决了，实在没有再提问，再找教练，然后通过继续阅读解决问题。 “一字不差”才是阅读笑来老师在得到专栏《通往财富自由之路》当中无数遍的强调过”一字不差的阅读”的重要作用，我也坚持过一段时间，但是后来渐渐的又回归到”一目十行”自以为”高效率”的老路上来了。可是在此次训练营的学习过程中，我再次按照要求一次不差的阅读，即使是已经读过的材料，一字不差的再次看的时候，仍然发现和领会前一遍忽略掉的重点，而有时候为了省时间直接跳跃到重点步骤，结果遇到不可避免的坑到最后还是再回来重新再一字不差的阅读，然后爬坑。一字不差的阅读，对于想仅靠阅读就学会技能的人来说，重要性怎么强调都不过分。 以后对于我来说，只有两种文字材料：一种是不值得读的(关掉算了)，其他的都是必须一字不差的读完的，哪怕花费很多时间，只要值得读，就值得通过一字不差的读尽可能的榨取文字的”剩余价值”。 开个大宝箱很多人（尤其是很多男生）买宜家家具的最大乐趣就在于按照说明书一步一步一个部分一个部分的组装起来，那感觉就好像我们是从砍树开始做出来的一样，如果没有说明书，可能我们组装过程就不会很顺利，更有可能我们直接就”做不成”一件家具，更别提从中获取成就感。 程序的官方文档就是这样一份说明书，它告诉你你需要知道的一切，”我是什么，我能做什么，你应该怎么把我嫁接到你的程序上成为你的程序的一部分，你应该怎么嫁接才能保证’成活率’最高’’等等等等，有时候详细到”琐碎“的地步，不过正好是锻炼你一字不差的阅读的好机会，不是吗？ 官方文档，就像是公开的武林秘籍，照着炼最起码不会走火入魔。尽管我不玩游戏，但是我有种强烈的预感，那些善于阅读游戏说明书的人，更有可能游戏玩得更好。 忍受”生长痛”学习一项新的技能，就是跨入一个相对全新的领域，用原有的技能应对新的挑战并在此过程中把新技能变成原有技能，毫无疑问，整个过程就像果树嫁接一样，需要把原来的枝条和嫁接枝条都割开，布绳拆开嫁接的部位是有”生长瘤”的，也一定像孩子长大一样是要经历”生长痛”的。一切的”过早引用”，一切的bug，一切的不舒服，一切的想放弃全都是”生长痛”，等捱过了最初的看似”难以忍受”的疼痛之后，渐渐的就不那么疼了，之后也就不再疼了。 老树要活只有不断的发新枝张新芽，或者嫁接新枝长新芽，人也是一样，既然技能不能自己长出来，就只能忍受”生长痛”嫁接上去了。对自学者更有利的一点是，编程不用像果树嫁接一样等到来年春天才能根据发芽情况判定嫁接是否成功， 代码嫁接简单的多，shift+enter就能立即知道结果，而且如果错了，大概率的还能知道错在哪里。 时间去哪儿了？时间是一切的根本。 一字不差的阅读文档需要时间，理解代码含义需要时间，把代码嫁接到自己的项目上需要时间，debug以及调试需要时间，技能毫无疑问是靠时间这位朋友堆出来，有一次承诺爱人一个小时后就能完成作业关上电脑，结果再一抬头已经三个小时过去了，所以，如果有人问我学习的十几天，时间都去哪了，我想我的大部分时间真真的都埋葬在代码里，在实现功能的时候，它开出了最美的花、结出了最甜的果。 反过来想，即使不堆新的技能，时间不也是匆匆溜走？ 致谢感谢笑来老师，感谢教练，感谢辅导员以及所有帮助过我的人，你们让此次嫁接成为可能，并为以后继续嫁接打开了一扇门，再次感谢。 是的，未来的道路可能仍然会很困难，可是没有困难哪来的成长？没有新技能新思维新格局，怎么敢坦然说自己在成长？]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100276-自学训练营学习20群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100276-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A020%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：赵诗琪学号：自学训练营学习20群 工作背景在校学生 自我介绍在新生大学里看到自学营学员的故事开始对编程感兴趣，想提高自学能力和编程，在这之前没有学过编程]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学是一门手艺</tag>
        <tag>在校学生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100291-自学训练营学习20群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100291-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A020%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：陈浩亮学号：1901100291 工作背景前从事医疗行业的信息化售前方案支撑 自我介绍我大学读的是软件开发专业，实习的时候参与过项目的编程后，从大学毕业至今已经10年，都没有再接触过编程。因为读了李笑来老师的《自学是一门手艺》，才开始想学习Phython。希望通过学习Phython，学会自学的同时掌握多一项技能，最终能够变现。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学是一门手艺</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE8-2]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 9+ Python编程导论（第2版）（第8章8.2继承） 学习用时: 1.5小时 学习笔记收获总结： 继承提供了一种方便的机制，可以建立一组彼此相关的抽象。它使程序员能够建立一个类型的层次结构，其中每个类型都可以从上层的类型继承属性。 子类不仅继承父类的所有属性，还可以如下处理： 添加新的属性。 覆盖——也就是替换超类中的属性。 函数isinstance是内置在Python中的，其中第一个参数可以是任何对象，但第二个参数必须是一个type类型的对象。函数当且仅当第一个参数是第二个参数的一个实例时，才返回True 程序开发与维护过程中，向原来的类添加新类或新属性是很常见的，对程序精心设计，使修改程序时所需的代码量最少。 替换原则： 子类应该被看作对超类行为的扩展 超类中的重要行为必须被所有子类支持。 如果客户代码使用超类实例能够正确运行，用子类实例替换超类实例时，代码应该也能正确运行。 遇到的问题和解决方法：有点找不到感觉，需要考虑复习前面的章节。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE8]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 8+ Python编程导论（第2版）（第8章8.1数据抽象） 学习用时: 3小时 学习笔记收获总结： 面向对象编程 的关键是将对象看作数据和可以在数据上执行的方法的集合。 def可以定义新函数，class定义新类型。 抽象数据类型是一个由对象以及对象上的操作组成的集合，对象和操作被捆绑为一个整体，可以从程序的一个部分传递到另一个部分。 分解使程序具有结构，抽象则隐藏细节。隐藏合适的细节是数据抽象的根本目标。 int,list,float,string,dict 这些都是抽象数据类型。 在Python中，我们使用类实现数据抽象。 类定义会创建一个type类型的对象，并将这个类的对象与一组instancemethod类型的对象关联起来。 类定义最上方的docstring描述的是这个类提供的抽象，而不是关于如何实现这个类的信息 类支持两种操作： 实例化： 创建类的实例。 属性引用： 通过点标记法访问与类关联的属性。 类定义中存在一个函数定义时，被定义的函数称为方法，并与这个类相关联。（有时被称为类的方法属性）,定义方法同样使用def。 表示不变性定义了数据属性中的哪个值对应着类实例的有效表示。_init_方法负责建立不变性，其他方法负责维持不变性。 _str_是类定义中最后一个方法，它是一个特殊的方法。执行print命令时，会自动调用与待输出对象相关联的_str_方法。 数据抽象鼓励程序设计者以数据对象作为程序设计的中心，而不是以函数为中心。 程序是函数的集合与程序是类型的集合会导致两种截然不同的程序组织原则。 数据抽象一般会比单个函数包含更多的功能，这能使我们更深刻地意识到编程的本质： 编程不是一个编写一行行单独代码的过程，而是一个组织抽象的过程。 遇到的问题和解决方法：对本课所需时间预估错误，分成两次完成。需要认真理解很多内容，多花些时间很有必要。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片]]></title>
    <url>%2Funcategorized%2Fimage-index%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE7-3]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 7+ Python编程导论（第2版）（第7章） 学习用时: 2小时 学习笔记收获总结： 异常(exception)：不符合规范的东西。在Python中异常十分常见，标准Python库中的所有模块都使用异常，在很多不同的环境也会抛出异常。 IndexError: trying to access beyond list limits TypeError: trying to convert an inappropriate type mixing data types without coercion operand doesn’t have correct type NameError: referencing a non-existing variable local or global name not found SyntaxError: Python can’t parse program AttributeError: attribute reference fails ValueError: operand type okay, but value is illegal IOError: IO system reports malfunction (e.g. file not found) 未处理异常：程序因为一个异常被抛出而终止时，叫做抛出未处理异常。 异常没必要导致程序终止 异常被抛出时，可以也应该由程序处理 未处理异常才是真正的异常。 try-except代码块来处理异常。except后面可以接一个异常元组 例如except(ValueError, TypeError): 将异常用作控制流 异常不仅仅是错误，还是一种方便的控制流机制，可以使程序更简洁 raise语句可以强制引发一个特定的异常。 raise exceptionName(arguments) exceptionName通常是内置的异常，e.g ValueError 大多数时候参数都是一个字符串，用来描述引发异常的原因。 断言(assertion) assert 语句提供了一种确保程序状态符合预期的简单方法。 assert Boolean expression assert Boolean expression, argument 断言是一种非常有用的防御性编程工具，可以用来确保函数参数具有恰当的类型。 断言也是一种非常有用的调试工具，可以确保中间值符合预期，或者确保函数返回一个可接受的值。 遇到的问题和解决方法：无]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08-12-1901100244-自学训练营-Python入门-Day05-学习心得]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100244-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-Python%E5%85%A5%E9%97%A8-Day05-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100244 操作系统：Windows 10 version 1903 (64-bit) 学习内容：字符串的基本处理，词频统计，数组操作，进制转换 学习用时：6 小时 收获总结 了解了字符串相关的替换、删除、大小写转换等工作的方法； 了解了由字符串分词生成列表的方法； 了解了列表的排序方法； 了解了字典的生成和排序方法； 明确了列表、元组、字典的联系和区别； 了解了切片的使用方法； 了解了数字类型和字符串类型的转换方法； 了解了由列表拼接字符串的方法； 了解了十进制数到二进制数、八进制数、十六进制数的转换方法。 遇到的难点与问题1. 字符串样本的形式任务手册中给出的字符串样本是著名的《Python 之禅》（The Zen of Python），其最早由蒂姆·彼得斯（Tim Peters）在 Python 邮件列表中发表，它包含了影响 Python 编程语言设计的 19 条程序编写原则。 《Python 之禅》被内置到了 Python 的 this 模块中，只需要运行 import this 就会被输出。 但手册中所呈现的字符串样本又与内置的内容有所区别，表现在： 开头多了一个空行； 标题和正文间多了一个空行； 有错别字（“ambiguity”写成了“ambxiguity”）； 结尾多了一个空行。 另外，原始的文本由于种种原因，使用了“打字机风格”，具体表现在： 单引号（‘、’）和缩略号（’）使用了直引号（’）进行替代； 破折号（—）使用了两个连字符（–）进行替代； 强调使用了成对星号（*）进行表达。 原始文本还有令人纠结的一点，就是破折号左右的空格。破折号左右要不要留空格是个见仁见智的问题，但至少应当全文一致，可原始文本的三个破折号用法各异，这就难以解释了。 这些问题虽然从完成任务的角度来说无需关心，但从排版的角度来说，足够让人产生如鲠在喉的感觉，况且 Python 3.x 默认使用的编码已经是 Unicode，完全可以在文本上解决引号、破折号等问题。 本着这样的想法，我在原始文本的基础上，考虑了排版规则，结合维基百科的 The Zen of Python 页面的内容，生成了作为练习使用的字符串文本。 此外，我顺着《Python 之禅》找到了一系列的《Python 增强提案》（Python Enhancement Proposals，缩写为 PEPs），这其中的《Python 编码规范》（Style Guide for Python Code，编号为 PEP 8）应该是学习 Python 编程的必读文本，其他的提案也可以选择性地读一读。 另可参见：维基百科的 Python 之禅页面蛇宗三字经（The Zen of Python）写在最前面：The Zen of PythonPython 的众多 PEP 之中，除了 PEP 8，还有哪一些是值得阅读的？维基百科的英文破折号（—）页面别再用「六个点」当省略号了，这些标点都有更规范的输入方式中文排版需求Mathematical Alphanumeric SymbolsVS Code 写 Python 时的代码错误提醒和自动格式化Linting Python in Visual Studio Code 2. 英文分词分词是个大问题。 简单的文本，可以通过空格分词，但稍微复杂一点的文本，处理起来就很耗神。 怎么叫“复杂”？包括但不限于： 小数（1.25之类）； 复杂词形（$10、10% 之类）； 缩略语（U.S.A. 之类）； 包含连字符的词汇（self-teaching 之类）； 特殊符号（…、– 之类） 转义符（\n 之类）。 还好，本次练习要处理的文本，不算太复杂。 不过要完成的目标（去掉文本中包含“ea”的单词），还是对分词有些要求的。举例来说，“idea—let’s”这样的部分，就得把“idea”去掉，别的内容保留，之后还要处理破折号两侧可能出现的多余空格。 简单的分词用 split() 函数就行，但本次用作分词的分隔符不只一个，故而选择通过加载正则表达式模块（re），通过 re.split() 函数完成分词。这里有两个要注意的地方： 间隔符表达式如果带括号（(…)），生成的列表里就包括分隔符，反之则不包括； 正则表达式字符串建议在前面加上标记 r，举例来说，我使用的表达式为 r&#39;(\s|,|\.|—)&#39;。 更复杂的分词可以通过加载其他的分词工具完成，具体可以参见《Python 文本数据分析初学指南》的“4.2 英文分词及词性标注”部分。 3. 正则表达式正则表达式（Regular Expression，常简写为 regex、regexp 或 RE）是计算机科学的一个概念，其使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。^Wiki_cs_RE 简单地说，如果需要查找或替换某个具体的字词，使用普通的查找或替换工具就可以了，但如果需要查找或替换的，是符合某些特定规则的字符串，就需要依靠正则表达式了。 快速地了解一下正则表达式，可以阅读陆超编写的《正则表达式30分钟入门教程》，深入学习，可以参考杰弗里·弗里德尔（Jeffrey E. F. Friedl）撰写的 500 多页的大部头《精通正则表达式》和余晟撰写的《正则指引》，还可以通过使用 Regester 和 RegexBuddy 等软件进行练习和测试。 无论如何，正则表达式的语法都很难读写，令人头疼，可为了它能实现的功能，只能认了。 上文已经说过，在 Python 里使用正则表达式需要加载正则表达式模块（re），不过在我用的时候遭遇了这么几个问题： 后向引用我认为包含撇号（’）的单词（如 ’s、’re、don’t 等），应该单独特别处理，而非简单地和它周围的词混在一起。举例来说，“Let’s”应该断成“Let”和“’s”，“don’t”就应该是一个整体。好在要处理的文本只有 3 个撇号，都是断开就行的，我就简化处理了——在撇号之前加空格把它和关联单词分开。完成这个任务需要使用“后向引用”，其默认的表达方式应该是类似“\1”、“\2”这样的，但我调了数次都报错，又作了一番功课才明白在这里应该用“\\1”、“\\2”。捎带要提一下的是，VS Code 里的查找/替换功能也可以用正则表达式，但它的后向引用要写成“$1”、“$2”这种形式。 转义序列“转义（escape）”是指用多个字符的有序组合来表示原本需要的字符的手段，“转义序列（escape sequence）”则指在转义时使用的有序字符组合。^Wiki_cs_Escape_Sequence转义序列通常用作表示那些“无法直接输入”的字符，比如回车符、换行符、制表符等等。在 Python 里，转义序列是用“\”开头的一系列字符组合，常用的有：换行符“\n”，制表符“\t”。但在正则表达式里，也会用到转义序列，正则表达式的转义序列还比 Python 多些，如：空白符“\s”，数字“\d”，单词边缘“\b”等。转义序列很有用，可也会带来麻烦，比如要输入 &#39;C:\new\&#39; 这个路径的字符串，其中的 \n 就会被转义，要避免这一问题，有两种方式：一，使用“\\”来表示不需要转义的反斜线（\），也即写为 &#39;C:\\new\&#39;，二，使用“r”标记告诉 Python 此处不转义，也即写为 r&#39;C:\new\&#39;。当在 Python 里用正则表达式时，问题就更严重了，因为 Python 本身会处理一层转义，正则表达式又会处理一层转义，故而要向正则表达式里传递一个不转义的“\”，字符串要写成“&#39;\\\\&#39;”，这实在是很麻烦，在这种情况下，建议更多地使用“r”标记来处理正则表达式。Python 官方发布的静态代码检查工具 Flake8 现在已经把所有 Python 不支持的转义序列标记成错误，提示“invalid escape sequence ‘x’ (W605)”，解决的办法也是在相应字符串加“r”标记。除了“r”外，字符串可用的标记还有“u”、“f”等，具体使用可以参见《The Python Language Reference》的“2.4.1. String and Bytes literals”和“2.4.3. Formatted string literals”部分。 特殊字符正则表达式里的“\s”困惑了我一阵子。我一开始用它来匹配空格了，发现不好用。搜索了一下才明确，“\s”可以匹配任意的空白符，包括制表符（\t，即&#39;\u0009&#39;）、换行符（\n，即&#39;\u000A&#39;）、回车符（\r，即&#39;\u000D&#39;）、换页符（\f，即&#39;\u000C&#39;）、竖向制表符（\v，即&#39;\u000B&#39;）、半角空格（“ ”，即&#39;\u0020&#39;），如果是 Unicode 的正则表达式，\s 还可以匹配全角空格（“ ”，即&#39;\u3000&#39;）。半角空格没有转义序列，要怎么匹配呢？查了好一会儿我才反应过来，直接输入“ ”就可以了……顺便我还了解了一下各种不同编码的转义序列表达法，前面“\u”开头的那些字符串，就是 Unicode 编码的转义序列表达法，具体细节可以参见《JavaScript 转义字符》（JavaScript character escape sequences），《字符编码笔记：ASCII，Unicode 和 UTF-8》，《Unicode 与 JavaScript 详解》等文，具体字符的转换可以用站长之家提供的Unicode编码转换工具。 4. 字典的统计和排序生成字典不难，有这么几个值得记录的点： 使用“not in”而非“not...in”更具体地说，if w not in text 和 if not w in text 是等价的，但前一种写法更易读。现在 Flake8 会把“not...in”标记出来（E713）并给出修改为“not in”的建议，同理，“is not”和“not...is”也有同样的问题（E714）。PEP 8 对此也有说明。另可参考《Python 中 not 的用法》一文。 字典、元组、列表字典不能直接排序，需要用 item() 函数把字典转成一个由元组构成的列表，然后再用 sorted() 函数排序。这里可能出现的波折是混淆了 sort() 和 sorted()。简单说，由字典转成的列表，不能用 sort() 排序，只能用 sorted() 排序。更多的信息可以参考《Python 中列表、元组及字典的排序》、《Python 中方法 sort() 和函数 sorted() 的区别》、《Python 中排序函数 sort() 和 sorted() 的区别》等文。 lambda 表达式使用 sorted() 排序会用到 lambda 表达式，这个稍稍有些不易理解。lambda 表达式定义的是一个“匿名函数”，是为了简化代码而使用的。举例来说， 1lambda x: x[1] 和 12def g(x): return x[1] 的功能是一样的。更进一步说， 1sorted(text, key=lambda x: x[1]) 和 12345def g(x): return x[1]sorted(text, key=g) 的功能也是一样的。显然，在使用 sorted() 的时候，lambda 表达式可以实现更简练的代码。不过，lambda 表达式会在一定程度上降低程序的可读性，所以要慎用。什么时候用 lambda 表达式，Goodpy 在《Python lambda 介绍》一文给了些很好的建议： lambda 并不会带来程序运行效率的提高，只会使代码更简洁。 如果可以使用 for...in...if 来完成的，坚决不用 lambda。 如果使用 lambda，lambda 内不要包含循环，如果有，我宁愿定义函数来完成，使代码获得可重用性和更好的可读性。 另可参考：Python: 使用 lambda 应对各种复杂情况的排序，包括 list 嵌套 dictPython dict() 函数 5. 切片的使用切片是从字符串、列表、元组中抽取部分内容的操作。它很常用，不过有些地方会让人有些困惑，记录如下。 首先要明确每一个元素的位置编号，以列表 li = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] 为例—— 列表元素 ‘A’ ‘B’ ‘C’ ‘D’ ‘E’ ‘F’ ‘G’ 正序编号 0 1 2 3 4 5 6 逆序编号 -7 -6 -5 -4 -3 -2 -1 注意正序编号是从 0 开始的，逆序编号是从 -1 开始的。 切片的语法是 list[start:stop:step]，即 名称[开始:结束:步伐]。这其中： 步伐可以省略，默认值为“1”； 开始和结束的值可以省略，默认值为列表的两端（不是第一个元素和最后一个元素）； 开始和结束中间的冒号不可省略； 步伐既可以为正值，也可以为负值，正值表示正序取值，负值表示逆序取值； 步伐为正值时，开始位置应在结束位置左侧，步伐为负值时，开始位置应在结束位置右侧，否则不会取出任何元素； 开始和结束的值既可以用正序编号，也可以用逆序编号，两种编号可以混用； 开始位置的元素会取出，结束位置的元素不会取出； 所用位置编号可以超出列表的元素位置编号； 所有的冒号两侧都没有空格。 还以列表 li = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] 为例—— 行号 代码 结果 注释 1 li[:] [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] 从列表左端取到列表右端，即取了整个列表 2 li[::1] [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] 从列表左端取到列表右端，步伐为“1”，即取了整个列表 3 li[::2] [&#39;A&#39;, &#39;C&#39;, &#39;E&#39;, &#39;G&#39;] 从列表左端取到列表右端，步伐为“2”，即每 2 个元素取 1 个元素，取出第 0、2、4、6 号元素 4 li[::3] [&#39;A&#39;, &#39;D&#39;, &#39;G&#39;] 从列表左端取到列表右端，步伐为“3”，即每 3 个元素取 1 个元素，取出第 0、3、6 号元素 5 li[::-1] [&#39;G&#39;, &#39;F&#39;, &#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;, &#39;A&#39;] 从列表左端取到列表右端，步伐为“-1”，把整个列表逆序 6 li[::-2] [&#39;G&#39;, &#39;E&#39;, &#39;C&#39;, &#39;A&#39;] 从列表右端取到列表左端，步伐为“-2”，取出第 -1、-3、-5、-7 号元素 7 li[2:5] [&#39;C&#39;, &#39;D&#39;, &#39;E&#39;] 从编号为 2 的元素（含）取到编号为 5 的元素（不含），步伐为默认值“1”，取出第 2、3、4 号元素 8 li[2:5:1] [&#39;C&#39;, &#39;D&#39;, &#39;E&#39;] 从编号为 2 的元素（含）取到编号为 5 的元素（不含），步伐为“1”，取出第 2、3、4 号元素 9 li[2:5:-1] [] 从编号为 2 的元素（含）取到编号为 5 的元素（不含），步伐为“-1”，没有取出元素 10 li[5:2:-1] [&#39;F&#39;, &#39;E&#39;, &#39;D&#39;] 从编号为 5 的元素（含）取到编号为 2 的元素（不含），步伐为“-1”，取出第 5、4、3 号元素 11 li[0:6] [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] 从编号为 0 的元素（含）取到编号为 6 的元素（不含），步伐为默认值“1”，取出第 0、1、2、3、4、5 号元素 12 li[0:-1] [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] 从编号为 0 的元素（含）取到编号为 -1 的元素（不含），步伐为默认值“1”，取出第 0、1、2、3、4、5 号元素 13 li[0:] [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] 从编号为 0 的元素（含）取到列表右端，步伐为默认值“1”，取了整个列表 14 li[0:9] [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] 从编号为 0 的元素（含）取到编号为 9 的元素（不含），步伐为默认值“1”，由于最大元素编号为 6，取了整个列表 15 li[9:0:-1] [&#39;G&#39;, &#39;F&#39;, &#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;] 从编号为 9 的元素（含）取到编号为 0 的元素（不含），步伐为默认值“-1”，由于最大元素编号为 6，取出第 6、5、4、3、2、1 号元素 16 li[9:-9:-1] [&#39;G&#39;, &#39;F&#39;, &#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;, &#39;A&#39;] 从编号为 9 的元素（含）取到编号为 - 的元素（不含），步伐为默认值“-1”，由于最大元素编号为 6，最小元素编号为 -7，取出第 6、5、4、3、2、1、0 号元素 17 li[0::-1] [&#39;A&#39;] 从编号为 0 的元素（含）取到列表左端，步伐为“-1”，取出第 0 号元素 18 li[:0:-1] [&#39;G&#39;, &#39;F&#39;, &#39;E&#39;, &#39;D&#39;, &#39;C&#39;, &#39;B&#39;] 从列表右侧取到编号为 0 的元素（不含），步伐为“-1”，取出第 -1、-2、-3、-4、-5、-6 号元素 19 li[1:-2:-1] [] 从编号为 1 的元素（含）取到编号为 -2 的元素（不含），步伐为“-1”，没有取出元素 20 li[-2:1:-1] [&#39;F&#39;, &#39;E&#39;, &#39;D&#39;, &#39;C&#39;] 从编号为 -2 的元素（含）取到编号为 1 的元素（不含），步伐为“-1”，取出第 -2、-3、-4、-5 号元素 21 li[0:3:-1] [] 从编号为 0 的元素（含）取到编号为 3 的元素（不含），步伐为“-1”，没有取出元素 22 li[:3:-1] [&#39;G&#39;, &#39;F&#39;, &#39;E&#39;] 从列表右端取到编号为 3 的元素（不含），步伐为“-1”，取出第 -1、-2、-3 号元素 字符串和元组的操作与列表类似。 要翻转（逆序）一个名为 li 的列表有两种途径，一种是用 li.reverse()，另一种是用 li[::-1]。但要翻转字符串和元组就只能用切片了。这样来看，切片的方法比较通用。 字典不能切片，不过可以用把字典的关键字转成列表，对列表切片，再用查询重新生成字典的方法实现切片，具体的操作可以参考李阳良的《Python 字典切片》一文。 6. 不同类型的转换由数字构成的列表不能直接拼接成字符串，得把列表的每个元素都转成字符串才行。 类型转换调用相应的函数就能完成，遍历列表的每个元素可以使用 for...in...if 语句。 Python 里可用的转换函数有这些： 函数 说明 int(x[, base]) 将 x 转换为一个整数，强制类型转换 long(x[, base]) 将 x 转换为一个长整数 float(x) 将 x 转换到一个浮点数，强制类型转换 complex(real[, imag]) 创建一个复数 str(x) 将对象 x 转换为字符串，强制类型转换 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效 Python 表达式，并返回一个对象 list(s) 将序列 s 转换为一个列表，强制类型转换 tuple(s) 将序列 s 转换为一个元组，强制类型转换 set(s) 将序列 s 转换为一个集合，强制类型转换 chr(x) 将一个整数转换为一个字符，Python 3.x 可以用其处理 Unicode 字符了 unichr(x) 将一个整数转换为 Unicode 字符，Python 3.x 将其合并进了 chr(x) ord(str) 将一个字符转换为它的整数值 bin(x) 将一个整数转换为一个二进制字符串 oct(x) 将一个整数转换为一个八进制字符串 hex(x) 将一个整数转换为一个十六进制字符串 这里的 eval(str) 在第 3 天做计算器的时候也提到过。str(x) 和 repr(x) 有联系也有区别，具体可参见叶俊贤的《Python 中 str() 与 repr() 函数的区别》一文。还有一些数据类型转换的细节，可以参考范桂飓的《Python基本语法——强制数据类型转换》一文和 Davidham 的《Python 中的强制类型转换》一文。 其他参考资料：《Python进阶》（Intermediate Python），穆罕默德·耶苏布·乌拉·哈立德（Muhammad Yasoob Ullah Khalid）著，刘宇（@liuyu），老高（@spawnris），大牙码特（@suqi），明源（@muxueqz）等译给非 Python 开发的 Python 快速自学资源整理 总结 巩固了一些英文标点的用法 字符串内容的查找、替换、删除 字符串的大小写转换 英文单词词频统计与输出 数组的基础操作 不同进制数字的转换]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08-11-1901100244-自学训练营-Python入门-Day04-学习心得]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100244-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-Python%E5%85%A5%E9%97%A8-Day04-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100244 操作系统：Windows 10 version 1903 (64-bit) 学习内容：打印两种形式的九九乘法表 学习用时： 小时 收获总结 了解了条件判断（if...elif...else）语句的用法； 了解了循环（for...in、while、break、continue）语句的搭配和使用； 了解了生成数字序列的方法（使用 range() 函数）； 巩固了格式化输出（print() 函数）的方法。 遇到的难点与问题1. 去除多余的输出通过两层循环嵌套输出大九九并不困难，但在这个基础上去掉一半输出小九九就稍有难度了。 我个人是通过做一次条件判断，只输出一数小于或等于另一数的情况完成了任务。 任务的第二部分要求去掉九九表的偶数行，这个困扰了我一阵子。 判断是不是偶数行不难，求余（“%”）就行了，加个 if 判断一下再输出就可以完成任务。 但任务要求用 while 循环来实现。 开始我就只用 while 加了一个判断，运行的时候发现会导致无限循环，又看了看文档，明白得配合 break 用，但 while 和 break 具体加在哪里颇费了一番思量。来回试验了好久，甚至手绘了流程图，我才实现了需要的输出。 2. 不同的输出形式任务中的要求输出是这样的—— 但这个输出有几个不尽如人意的地方： 对齐不正，第 4 行和第 5 行的空隙由于进位歪了； 符号不当，乘号应该写作“×”，使用星号（*）替代是不得已而为之，不应当作正式用法； 顺序不佳，习惯中的九九表应该是小数在前大数在后，此处颠倒了。 这几个问题的解决方法倒很简单： 把 print() 函数的结尾符设置为制表符即可（不知为什么教程里特意写了这么一句但示意输出却用的是 3 个空格）； 把 print() 里的“*”改成“×”即可； 把 print() 里的变量顺序调整一下即可。 除此之外，我还试了一下另一个方向的九九表—— 这是常见的九九表的转置，也是最初的大九九去掉另外一半的效果，不过这么排版对对齐有进一步的要求，也算是额外的练习了。 3. 不同的循环方式除了原本的要求外，我还试验了其他完成任务的方式，如： 用变量控制 range() 函数的右边界以省略两数大小判断； 把循环区间设定为 [1, 3, 5, 7, 9] 以省略 while 循环； 用 if 替代 while 实现判断； 用 if...continue 替代 while...break 实现判断。 算是把不同的循环方式都练习了几遍。 总结 输出了不同形式的九九表 改善了原始的输出形式 用不同方式完成了任务 通过逐步尝试优化代码]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-MIT-自学 lecture9]]></title>
    <url>%2FMIT60001%2F1901030012-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AE%AD%E7%BB%83%E8%90%A5-lecture9notesday42%2F</url>
    <content type="text"><![CDATA[学员信息 学号: 1901030012 学习内容: MIT第9课视频文稿p2-5 学习用时: 20mins Notes no.: Day42 学习笔记 selfWe defined the class in the sort of general way, OK? So we needed a way to be able to access data attributes of any instance. So we use this self variable, OK? And the self variable we used to refer to any instance– to the data attributes of any instance in a general way without actually having a particular instance in mind, OK? methodsthe bottom line of the class definition is that your class defines all of the data– so data attributes– and all of the methods that are going to be common across all of the instances. So any instance that you create of a particular object type, that instance is going to have this exact same structure, OK? The difference is that every instance’s values are going to be different. So when you’re creating instances of classes, you can create more than one instance of the same class. So we can create a Coordinate object here using this syntax right here. So you say the type, and then, whatever values it takes in. And you can create more than one Coordinate object. Each Coordinate object is going to have different data attributes. Sorry, it’s going to have different data attribute values, OK? Every Coordinate object is going to have an x value and a y value. But the x and y values among different instances are going to vary, OK? So that’s the difference between defining a class and looking at a particular instance of a class. So instances have the structure of the class. So for a coordinate, all instances have an x value and a y value. But the actual values are going to vary between the different instances. Use OOB(Object-oriented Programming)so ultimately, why do we want to use object-oriented programming? So, so far, the examples that we’ve seen were numerical, right– a coordinate, a fraction. But using object oriented programming, you can create objects that mimic real life. So if I wanted to createobjects of– an object that defined a cat and an object that defined a rabbit, I could do that with object-oriented programming. I would just have to decide, as a programmer, what data and what methods I’d want to assign to these groups of objects. So I’m grouping sets of objects that are going to have the same attributes together. And attributes– this is also a recap of last time– come in two forms, right, data attributes and procedural attributes. So the data attributes are basically things that define what the object is. So how do you represent a cat as an object? And it’s up to you, as the programmer, to decide how you want to do that. Procedural attributes were also known as methods. And the methods are essentially asking, what can your object do, OK? So how can someone who wants to use your object– how can someone interact with it? getters and settersAll right, so now we have this class, Animal. We’ve done the first part here, which is to initialize the class, right? So we’ve told Python how to create an object of this type. There’s a few other methods here that I’ve implemented. Next two we call getters, and the two after that we call setters, OK? And getters and setters are very commonly used when implementing a class. So getters essentially return the values of any of the data attributes, OK? So if you look carefully, get_age() is just returning self.age , and get_name() just returns self.name . So they’re very simple methods. Similarly, set_age() and set_name()– we’re going to see what this funny equal sign is doing here in the next couple of slides. But setters do a very similar thing where they’re going to set the data attributes to whatever is passed in, OK? #学习Python有力量，我已经可以和Alucard沟通某些我原来完全不知道要怎么沟通的话题，因为原来在他提到的那些概念、理论时我完全不能听到大脑里，因为我完全不熟悉，，，现在，我感觉我不会因为害怕而宕机不听了，我会尝试提问，还是in a smarty way。hiahiahia。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010001-MIT-自学 《Python编程导论第二版》]]></title>
    <url>%2FMIT60001%2F1901010001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E7%BC%96%E7%A8%8B%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学员信息 学号： 1901010001 学习内容： 《Python编程导论第二版》 学习用时： 25min 学习笔记 今天花了20多分钟，和猫法师@catynchyna 1901030012，一起找我按照书本敲的两段代码为啥跑不起来。 因为需要在中英文之间频繁切换，我的两段代码都是输入法出现了问题。这让我重新认识了编程是个严谨的世界。哪怕只是一个标点的问题，都会成为一段代码的bug。 如果代码出现报错，报错位置的前后两行都要检查，最快捷的方式是确认在英文输入法下重新写。 出现问题直接截图和战友交流，问题说不定就能顺利解决。把问题都存起来，多了就容易放弃学习了。这都是很自然多因果关系。这个时候，一个靠谱的学友就很重要了。谢谢我的猫法师@catynchyna 1901030012，对我出现的学习问题比我自己还上心。要坚持下去，要配得上我这么好的学友猫法师@catynchyna 1901030012！]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-MIT-自学 lecture9]]></title>
    <url>%2FMIT60001%2F1901030012-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%90%A5-lecture9notesD41%2F</url>
    <content type="text"><![CDATA[学员信息 学号: 1901030012 学习内容: MIT第9课视频文稿p2 学习用时: 20mins Notes no.: Day41 学习笔记 Github Pulling changes from a remote repository git pull is a convenient shortcut for completing both git fetch and git merge in the same command: 12$ git pull *remotename* *branchname*# Grabs online updates and merges them with your local work Because pull performs a merge on the retrieved changes, you should ensure that your local work is committed before running the pull command. If you run into a merge conflict you cannot resolve, or if you decide to quit the merge, you can use git merge -- abort to take the branch back to where it was in before you pulled. Syncing a fork 2.1 Open Terminal. 2.2 Change the current working directory to your local project. 2.3 Fetch the branches and their respective commits from the upstream repository. Commits to master will be stored in a local branch, upstream/master. 1234567$ git fetch upstream &gt; remote: Counting objects: 75, done. &gt; remote: Compressing objects: 100% (53/53), done. &gt; remote: Total 62 (delta 27), reused 44 (delta 9) &gt; Unpacking objects: 100% (62/62), done. &gt; From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY &gt; * [new branch] master -&gt; upstream/master 2.4 Check out your fork’s local master branch. 12$ git checkout master&gt; Switched to branch &apos;master&apos; 2.5 Merge the changes from upstream/master into your local master branch. This brings your fork’s master branch into sync with the upstream repository, without losing your local changes. 12345678$ git merge upstream/master &gt; Updating a422352..5fdff0f &gt; Fast-forward &gt; README | 9 ------- &gt; README.md | 7 ++++++ &gt; 2 files changed, 7 insertions(+), 9 deletions(-) &gt; delete mode 100644 README &gt; create mode 100644 README.md If your local branch didn’t have any unique commits, Git will instead perform a “fast-forward”: 12345$ git merge upstream/master&gt; Updating 34e91da..16c56ad &gt; Fast-forward &gt; README.md | 5 +++-- &gt; 1 file changed, 3 insertions(+), 2 deletions(-) 从Maestro给我们的参考资料入手，硬着头皮看了一遍，然后还是各种不知道该问什么问题。都不明白么？好像也不是。。。傻傻搞不明白这里面的具体操作，我就重新打字打一遍又看一次，well，好像没有那么陌生了，隐约觉得这个就是那天Maestro云淡风轻d秀肌肉使用的眼花缭乱的命令行技能？？？那我准备开始试着执行了哦。然后我就有第一个问题： 3.1 打开的Terminal是Mac的么？还是可以在VSCode里面的terminal里呢？ 果然哦，我在Mac的Terminal里输入的时候不知道要怎么输入 remotename 和 branchname，因为在~根目录下吧，所以报fatal: not a git repository (or any of the parent directories): .git。然后我在VSCode里面，显示的是我本地已经clone下来的selfteaching-learning-notes.github.io文件目录，然后git pull就居然就显示： 1234cat at cattekimbp in ~/Documents/GitHub/selfteaching-learning-notes.github.io on source $ git pull Already up to date.(base) 尝试在Mac的Terminal里输入我猜的 remotename 和 branchname，我觉得我.git文件路径的问题么？是命名的问题么？我要去睡觉了，说不定我能梦到我在Google解。哈哈哈哈。加油，白天喝了咖啡再来玩。。。我觉得我似乎找到了一点儿玩的赶脚了。吾厘Maestro 万岁！！！yeah！]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08-10-1901100244-自学训练营-Python入门-Day03-学习心得]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100244-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-Python%E5%85%A5%E9%97%A8-Day03-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100244 操作系统：Windows 10 version 1903 (64-bit) 学习内容：使用 Python 编写计算器 学习用时：5 小时 收获总结 对 Python 可实现的功能大致有了些了解； 了解了获取键盘输入信息的方法； 了解了定义函数的方法； 了解了用 if…elif…else 函数控制流程的方法； 知道了用 while 函数控制流程的方法； 知道了 print 函数格式化的方法； 知道了 eval 函数的用法； 知道了 try…except 函数的用法。 遇到的难点与问题1. 看完参考资料后找不到入手点看完手册给的参考资料后，我感觉一头雾水，似乎该知道的都写了，但又不知道怎么完成作业。 最主要的问题是：计算器是 Python 内置的功能，还要怎么实现？难道说“输入 Python 启动 Python 解释器，输入要计算的算式后回车”就算完成任务了？但这怎么用 .py 文件实现呢？ 2. 通过搜索完成任务后感觉路数不对我试着 Google 了一下“Python Calculator”和“Python 计算器”，发现了大量的方案，有相对简单的，也有相对复杂的。 本着先易后难的原则，我参考了《Python Program to Make a Simple Calculator》、《如何在Python 3中做一个简单的计算器程序》、《Python 简单计算器实现》等文章，做了第一个版本，实现了：通过 3 次键盘输入，分别获取两个数字和运算符，然后输出运算结果，另外，在除数为 0 的时候，提示错误。 我把这个版本交给教练后，教练表示这样就算完成任务了，但我觉得路数不大对，主要的原因是：操作不直观、和最初的想法距离较大。 3. 通过搜索找到理想方法后逐步完善我在 ZingpLiu 的《Python实现计算器》一文中读到了这样一句话： 前几天有个面试题目：计算字符串”1 + (5 - 2) * 3”，结果为10，不能用eval()。 这个“不能用eval()”引起了我的注意，我就去查了一下 eval() 是什么，从 Python eval() 函数的介绍页面了解到，eval() 就是把其中的表达式直接给 Python 解释器并输出计算结果，这其实就是我之前想找的方法。 eval() 加上 input() 和 print()，一行代码就可以实现计算器了： 1print(eval(input())) 我问了一下教练，这样算不算完成任务，教练告诉我也算，“任务不是目的，目的是学习知识”。 不过我觉得，这样完成任务，简洁是简洁了，但还是有些遗憾，比如： 每次运行只能计算一次，输出结果后就退出了； 如果输入了错误的内容，会报错直接退出； 显示的形式不太美观。 可能有安全隐患。 第一个问题。我一开始参考了上面提到了《如何在Python 3中做一个简单的计算器程序》一文，另外加了个函数 again() 专门用于在计算完成后询问是否要计算其他算式，输入 Y 就重新开始计算，输入 N 就退出。试了几次后觉得这样太繁琐了——每次计算完都得另外按个字母，简洁的方法应该是，计算完直接开始下一次计算，给某个特定输入就退出。我又看了一遍文档，注意到了 while，搜索之后从《Python While 循环语句》知道了，用 while 1: 可以实现无限循环，结合 if 和 break 就可以实现输入某个特定字母后退出。 第二个问题。我在手册给出的《X分钟速成Y，其中 Y=python3》一文中找到了 try/except 块的介绍，又通过参考《Python 异常处理》一文，外加试错，找了 3 个特定的错误情况，设定输出错误提示并重新开始循环，避免了意外的报错退出。 第三个问题。我通过调整 print() 函数的格式化做了优化。 第四个问题。由于 eval() 是直接把其中的字符串当作输入值传给解释器了，这就可能遇到某些别有用心的人构造特别的输入，从这里入手访问甚至读写网站的文件，这一安全隐患通常是靠限制 eval() 可接受的内容来避免的。我在这里通过 import 引入了 math 模块，再用其构造了字典，继而约束了 eval() 可接受的输入。 总结 编写了一个简单的计算器 用不同方式完成了任务 通过逐步尝试优化代码]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08-09-1901100244-自学训练营-Python入门-Day02-学习心得]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100244-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-Python%E5%85%A5%E9%97%A8-Day02-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100244 操作系统：Windows 10 version 1903 (64-bit) 学习内容：配置本地运行开发环境 学习用时：6 小时 收获总结 成功安装了 Anaconda3 及其他软件/程序； 掌握了 VS Code 扩展的安装方法； 配置了使用 VS Code 撰写 Python 程序和 Markdown 文档的相关扩展； 编写了第一个 Python 程序（Hello, World!）； 明确了提交作业的流程； 配置了 JupyterLab。 写日志的时间远多于学习时间，不知怎么评价…… 遇到的难点与问题1. Anaconda 的版本选择本次学习特别强调，学习对象是 Python 3.x，不解答任何 Python 2.x 的问题。 这个要求事实上是暗示要安装 Anaconda3，而非 Anaconda2。实际上现在在 Anaconda 官方网站的下载页面上直接下载的 Windows 版安装包就是 Anaconda3，但助教为了方便学员，特别提供了清华大学开源软件镜像站的 Anaconda 下载页面，这个页面上有各种版本的 Anaconda，我就多想了些，觉得 Anaconda 官方网站应该也有类似的下载页面，又回忆起 2015 年的 XcodeGhost 事件，认为从安全的角度考虑，能用官方下载就不用第三方下载，就算用第三方，下载后也要想办法和官方提供的包进行 MD5 对照检查。在这种思路的引导下，我找到了 Anaconda 官方网站的所有版本下载页面（https://repo.anaconda.com/archive/），这里有各种版本及其 MD5，我就从这个页面下载了最靠上的 64 位 Windows 版安装包，下载的时候完全没有意识到这是个 Anaconda2 的包。 下载完成后我就一股脑完成了安装，安装界面上的 Python 2.7 也没有警示到我，直到有同学在学习群里贴安装截图询问的时候，我才发觉不对——为什么他的截图上显示的是“Anaconda3”，而我这里是“Anaconda2”？有什么区别？ 快速 Google 了一下我就明白了，我弄错安装包了，而且更无奈的是，Anaconda2 和 Anaconda3 没法共存，所以我能做的就是——卸载 Anaconda2，另装 Anaconda3。好在我发现得早，没做更多的设置，也就没有太多的返工。 另外，我在搜索的过程中，发现了另一个 Python 3.x 强于 Python 2.7 的地方：多语言支持，简单说，就是中文支持更好。我觉得就这一条也值得用 Python 3.x。 2. PATH 的设置PATH 指的是“环境变量”，很多人都没听说过这个东西，所以也值得一记。 设置环境变量的目的，是让某个位置的程序在任何位置都能运行。 举例来说，装好 Anaconda3 后，随带的 Python 所在的路径是 C:\Users\&lt;UserName&gt;\Anaconda3\python.exe，在没有设置环境变量的情况下，Python 只能在这个文件夹下运行，在其他位置运行——比如 GitHub Desktop 管理的 hello-world 文件夹 C:\Users\&lt;UserName&gt;\Documents\GitHub\hello-world\ ——的时候，需要输入完整的路径才可以。也就是说，运行一下“Hello, World!”程序，就需要在其所在的文件夹输入这样的指令： 1C:\Users\&lt;UserName&gt;\Anaconda3\python.exe hello-world.py 这显然相当麻烦。如果把 Python 所在的位置加入了环境变量，同样的工作，只需要这样输入就行了： 1python hello-world.py 影响其实还不仅如此，不设置环境变量的话，很多程序自动化的功能，都会因为找不到需要的文件失效，所以设置环境变量是必不可少的一步。 Anaconda3 在安装的时候对此有所提示——不过按照安装包的说法，是不建议使用上面这个复选框的，我就选择了安装完成后手动设置。 设置的方法是：i. 依次打开【控制面板】-【系统和安全】-【系统】-【高级系统设置】-【环境变量(N)…】ii. 在【系统变量(S)】区域双击【Path】iii. 使用右侧的【新建(N)】按钮添加如下几行 12345C:\Users\&lt;UserName&gt;\Anaconda3C:\Users\&lt;UserName&gt;\Anaconda3\ScriptsC:\Users\&lt;UserName&gt;\Anaconda3\LibC:\Users\&lt;UserName&gt;\Anaconda3\Library\binC:\Users\&lt;UserName&gt;\Anaconda3\Library\mingw-w64\bin 注意此处的 &lt;UserName&gt; 需要更换为自己的账户。如果修改了默认安装的文件夹，那就按实际文件夹位置填写，要对应包含这几个位置，不要有错漏。 3. VS Code 的配置学习手册为这一部分给出的参考文档 VS Code 官方配置 Python 环境教程其实不大适用于这一阶段，说重一点，光这一篇教程就足以劝退不少新人了。 其实如果按手册前文的要求，通过 Anaconda Navigator (Anaconda3) 安装好了 VS Code，那么 Python 的环境基本已经配置好了，更多的由于环境配置出现的问题，其实应该通过配置系统环境变量（见上文）解决。 个人认为，为了 Python 配置 VS Code 更值得参考的文档是 VS Code 扩展市场的介绍，以及 VS Code Python 入门教程。 扩展市场是发挥 VS Code 强大潜力不可或缺的一部分。其实从 Anaconda 装好 VS Code 后，Python 扩展已经默认安装了，故而只说 Python 的话，对这部分也可以不了解。不过如果需要其他功能，如 VS Code 的中文界面、Markdown 支持、颜色/图标等个性化界面配置、快捷键调整等等，都得靠从扩展市场装扩展才行，所以知道怎么操作扩展市场，是用好 VS Code 的重要一环。 如果前面该做的步骤都做完了的话，入门教程里先决条件（Prerequisites）那部分可以跳过去，从在项目（工作区）文件夹中启动VS Code（Start VS Code in a project (workspace) folder）往下看就行了。 也不用看太细（太细也搞不明白），差不多照猫画虎弄弄就行。 值得记录的几点：i. 验证 Python 安装，在命令提示符里输入 python --version 就行，会提示现在安装的 Python 版本。入门教程里那个 py 开头的命令我怎么都没能成功运行，既然目的已经实现，我也就不纠结它了；ii. 项目文件夹用文件资源管理器新建就行，不必纠结于命令行。对于本次学习来说，用 VS Code 菜单上的【文件(F)】-【打开文件夹…】打开昨天创建的作业文件夹就行（如 C:\Users\&lt;UserName&gt;\Documents\GitHub\selfteaching-python-camp\exercises\&lt;StudentID&gt;，其中 &lt;UserName&gt; 是账户，&lt;StudentID 是学号 ）；iii. Python 解释器（Python interpreter）也可以跳过去，有问题了再琢磨这部分也不迟；iv. 配置并运行调试器（Configure and run the debugger）后面的眼下都可以先不看了，将来有需要再回来查吧。 另外，我为了更好地用 VS Code 写日志，买了本全面讲解 Markdown 的书《了不起的 Markdown》（毕小朋著，北京：电子工业出版社，2019.8）（CSDN 相关页面、简书相关页面、百度试读页面、亚马逊电子版购买页面、京东（纸质版）购买页面），里面有一章专门讲了 VS Code，很值得一读。 4. “Hello, World!”程序学习手册要求通过搜索引擎自行完成“Hello, World!”程序的编写，这其实不难，搜索“Python Hello World”很快就能找到相关介绍，可能造成困扰的是，不少介绍用的是 Python 2.7，和 Python 3.x 的语法并不一样，照着写就可能会出问题，这个只能多看多试了。 上文提到的 VS Code Python 入门教程里其实就有编写“Hello, World!”程序的逐步说明，所以如果认真过了一遍入门教程，这一步也就完成了。 需要注意的几个点：i. 括号（“()”）一定要是半角英文括号，成对出现；ii. 引号单引号（’）、双引号（”）、三引号（’’’或”””）有区别有联系，应注意识别，参见：https://blog.csdn.net/woainishifu/article/details/76105667；iii. 如果想写中文的话（比如“你好，世界！”），需要在程序第一行添加 1# -*- coding: UTF-8 -*- iv. 建议在程序开头用注释的形式写明程序用途，如 123456# -*- coding: UTF-8 -*-# Filename : 1001S02E02_hello_python.py# author by : @shen-huang# 输出“Hello World!”` “Hello, World!”现在已经可以算是个模因（meme）了，任务之外，了解一下它的相关信息还是蛮有意思的。 5. JupyterLab 的配置在 Anaconda Navigator 中启动 JupyterLab 就坑了我一下，先是无法启动，重启之后成功启动了，打开了默认浏览器，由于我在系统里设置的默认浏览器是 IE（为了控制微信PC版的网页跳转），出来的页面什么都没有，把网址复制到其他浏览器又要提供 Token，Token 我又找不出来，这就卡住了。 好在笑来老师写过一篇《JupyterLab 的安装与配置》，从安装 Anaconda 开始讲了 JupyterLab 的配置过程。 可我照着做的时候遇到了网络错误，痛快解决还是要设置代理——i. conda 代理用文本编辑器打开 C:\Users\&lt;UserName&gt;\.condarc 文件（&lt;UserName&gt; 是自己的账户），在结尾添加代理，如 123proxy_servers: http: http://127.0.0.1:1080 https: http://127.0.0.1:1080 注意 Anaconda 只能用 HTTP 代理。另可参见：How to enable proxy servers with anaconda python?ii. pip 代理在账户文件夹（C:\Users\&lt;UserName&gt;）下新建文件夹“pip”，在其中新建文本文档“pip.ini”（注意扩展名），用文本编辑器将文档打开，在其中填写相关设置，如 12345[global]trusted-host = pypi.python.org pypi.org files.pythonhosted.orgproxy = http://127.0.0.1:1080 其中 trusted-host 是可信任的安装路径，如果不是很在意的话，也可以使用中国大陆地区的镜像位置（如 pypi.douban.com、mirrors.aliyun.com 等），速度也会快不少，使用中国大陆镜像的话，proxy 的设置也可以不用做的。另可参见：How to use pip on windows behind an authenticating proxy?pip 添加 trusted hostlinux 设置 pip 镜像 Pip Warning：–trusted-host 问题解决方案 调试 JupyterLab 配置文件（jupyter_notebook_config.py）的时候又卡住很久。 笑来老师给了4个可选的配置，分别是 1234#c.NotebookApp.token = ''#c.NotebookApp.open_browser = False#c.NotebookApp.notebook_dir = '~/'#c.NotebookApp.default_url = '/tree' 要启用某一项，把对应行首的#号去掉就行了。 第1项没有问题，我只在自己的计算机上用 JupyterLab，没有安全问题，启用这一项即可。 第2项设置的是启动 JupyterLab 的时候是否打开浏览器，我一时间没弄明白这是什么意思，就把它启用了，造成的效果就是从 Anaconda Navigator 里启动 JupyterLab 时进度条走完就没反应了，从 Anaconda Prompt 里输入 jupyter notebook list 可以看到服务已经启动，而且还没法用 jupyter notebook stop 命令终止服务。我来回试了数次才反映过来，直接在浏览器里访问 http://localhost:8888 就能看到 JupyterLab 了，如果要关闭的话，通过菜单【File】-【Shut Down】即可。笑来老师提到了一个使用习惯：把一个平时不怎么用的浏览器专门用在 JupyterLab 上，那如果想要在 Anaconda Navigator 里启动 JupyterLab 时直接跳出特定浏览器要怎么办呢？还是要靠修改 jupyter_notebook_config.py 文件。i. 首先保证 c.NotebookApp.open_browser = False 没有启用，就是行首有#号；ii. 在任意位置（尾部即可）添加要使用的特定浏览器 123import webbrowserwebbrowser.register('Kinza', None, webbrowser.GenericBrowser(r'C:\Users\&lt;UserName&gt;\AppData\Local\Kinza\Application\kinza.exe'))c.NotebookApp.browser = 'Kinza' 其中&#39;Kinza&#39;是浏览器的名字，&#39;C:\Users\&lt;UserName&gt;\AppData\Local\Kinza\Application\kinza.exe&#39;是浏览器可执行文件的位置，注意前面有一个 r 字符，表示后面的字符串不转义。很多文档不用 r 而用 u，实践证明，如果路径是全英文的，那还是用 r 比较好，用 u 可能会报错。 第3项用于设置 JupyterLab 可访问的根目录，如果 JupyterLab 是从 Anaconda Navigator 启动的话，这一目录实际上是 .jupyter 文件夹所在的位置，这就又平添了几分麻烦。我所用的一台计算机，配置的是固态硬盘+机械硬盘，我根据日常的习惯，把系统装在了固态硬盘（盘符为 C）上，又把账户下的默认文件夹（桌面、文档、图片、视频、音乐、下载等）移动到了机械硬盘（盘符为 D）上。这一设置导致 Anaconda 和 GitHub 文件夹默认都装在了 D 盘，而 .jupyter 文件夹默认在 C 盘生成，JupyterLab 启动之后看不到 GitHub 文件夹。笑来老师建议把这一项设置成 &#39;~/&#39;，但这一设置在 Windows 上不适用，我摸索了一阵子，把它设置成了 &#39;D:\\&#39; 才成功打开 GitHub 文件夹里的《自学是门手艺》。 第4项用于切换 JupyterLab 和 Jupyter Notebook，我没用过 Jupyter Notebook，也没什么可怀旧的，就没启用这一项。 6. JupyterLab 系统服务配置如果想要将来用 JupyterLab 方便一点，不必每次都从 Anaconda Navigator 启动，还是把 JupyterLab 配置成系统服务比较好。macOS 的配置方法笑来老师写了，Windows 的配置方法如下。 获取创建服务的应用程序 instsrv.exe 和 srvany.exeinstsrv.exe 和 srvany.exe 是 Windows Server 2003 Resource Kit Tools 工具集中的两个程序，配合使用可以将任何 EXE 程序作为 Windows 服务运行。下载地址为：https://www.microsoft.com/en-us/download/details.aspx?id=17657。instsrv.exe 和 srvany.exe 可以在安装后的安装文件夹找到，也可以用 7-Zip 等软件直接解开安装包得到。为方便使用，建议将这两个文件放到 C:\Windows\System32\ 文件夹和 C:\Windows\SysWOW64\ 文件夹下。 创建 JupyterLab 运行项如上文所说，JupyterLab 的具体设置是依赖 jupyter_notebook_config.py 文件的，为了方便启动，将其复制到 jupyter.exe 所在的文件夹 C:\Users\&lt;UserName&gt;\Anaconda3\Scripts\ 下，然后创建文本文档，命名为“jl.cmd”，在其中写入启动 JupyterLab 的指令 1jupyter lab jupyter_notebook_config.py 并保存退出。 创建服务以管理员身份运行命令提示符，输入 1instsrv.exe JupyterLab C:\WINDOWS\System32\srvany.exe 完成服务设置打开注册表编辑器（【开始】-【运行】-【Regedit】），定位到： 1计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\JupyterLab 在其中新建一个字符串值“DisplayName”，设置为“JupyterLab 服务”，这是对本服务的描述，可填写方便辨别的内容，也可省略。在其中新建一个项，名为“Parameters”，再在其中建立 Application、AppDirectory、AppParameters 三个字符串值。Application 的值为作为服务运行的程序，这里设置为 C:\\Users\\&lt;UserName&gt;\\Anaconda3\\Scripts\\jl.cmdAppDirectory 的值为作为服务运行的程序所在的文件夹位置，这里设置为 C:\\Users\\&lt;UserName&gt;\\Anaconda3\\ScriptsAppParameters 的值为作为服务运行的程序启动时的参数，这里暂不设置。注意 &lt;UserName&gt; 要换成自己的账户名，所有的反斜杠都是两个。 启动服务打开服务（【开始】-【Windows 管理工具】-【服务】），可找到其中 JupyterLab 项，将其启动类型设置为“自动”，再启动这个服务，以后就可以不通过 Anaconda，直接在浏览器里访问 http://localhost:8888/lab? 来使用 JupyterLab 了。 注意，服务和进程并不完全关联，启动服务会启动 JupyterLab 进程，但停止服务并不会终止进程，要彻底退出，需要在停止服务后再在管理员身份的命令提示符中运行 TASKKILL /F /IM jupyter.exe /T 杀掉进程。如果在停止服务前杀掉了进程，还需要再停止服务，才能重新启动服务。 参见：windows服务注册使用instsrv.exe+srvany.exe将应用程序安装为windows服务Windows下安装Jupyter，作为后台服务运行 7. 把 JupyterLab 设置为桌面应用一直靠用浏览器访问 http://localhost:8888/lab? 来使用 JupyterLab 也有些不便，一方面不直观，另一方面浏览器的分页、地址栏、收藏夹也会占掉不少空间，可以通过使用 Chrome 应用模式启动一个很像桌面应用的 JupyterLab。 简单的方法是在命令提示符里运行： 1"C:\Users\&lt;UserName&gt;\AppData\Local\Google\Chrome\Application\chrome.exe" --app=http://localhost:8888/lab? 然后就会出现这样的一个 JupyterLab： 更优雅的形式，是给这行命令建一个快捷方式：在合适的位置（如开始菜单的 Anaconda3 (64-bit) 文件夹里）新建一个快捷方式，对象位置填写为&quot;C:\Users\&lt;UserName&gt;\AppData\Local\Google\Chrome\Application\chrome.exe&quot; --app=http://localhost:8888/lab?快捷方式的名称填写为JupyterLab点击“完成(F)”即可。 如果觉得默认的图标不好看，可以更改，JupyterLab 的图标可以在这里下载：https://github.com/jupyterlab/jupyterlab_app/tree/master/dist-resources 把这个快捷方式固定到任务栏上点击打开，会另外弹出一个图标运行 JupyterLab，此时在之前快捷方式的图标上点击右键，选择“从任务栏取消固定”，再把新弹出的图标固定到任务栏，在上面点击右键，再在弹出菜单中的浏览器程序图标上点击右键，选择“属性”，把目标修改为”&quot;C:\Users\&lt;UserName&gt;\AppData\Local\Google\Chrome\Application\chrome.exe&quot; --app=http://localhost:8888/lab?“，点击“更改图标(C)”以修改图标，在“常规”选项卡中更改名称为“JupyterLab”，最后点击“确认”就可以了。改完可能不会当即生效，等一等就行。 其实把 JupyterLab 设置为桌面应用并不一定要用 Chrome，基于 Chromium 的浏览器都可以，由于 Chrome 我很常用，就另外装了个不常用的浏览器“Kinza”来做这件事，其他可选项可参见：https://zh.wikipedia.org/wiki/Chromium。 我在这一步也犯了不少傻，先是用了批处理文件，为了不跳命令提示符窗口又用了 VBS，为了固定到任务栏上好看又把 VBS 转成了 EXE，结果发现点击任务栏上的图标后会弹出另一个图标运行 JupyterLab，合不起消不掉，相当尴尬，最后才想起来直接设置快捷方式就行了，真是……汗。 其他参考资料：在应用模式下启动Google Chrome这样能将网站添加到Win10任务栏在 Windows 上安装和配置 Jupyter Lab 作为桌面级应用程序 8. 闲话Python、Anaconda、Jupyter 这些名字其实都有不少讲究，了解一下不失为一件趣事。 Python 的名称来自于著名的英国BBC电视喜剧《蒙提·派森的飞行马戏团》（Monty Python’s Flying Circus），Python 的创始人吉多·范罗苏姆很喜欢这套电视剧，就用其中的“Python”做了程序的名字。另外，“Python”还有巨蟒的含义，故而其徽标设计为了两条缠绕的蛇。 Anaconda 的含义则是一种南美洲热带无毒大蛇“森蚺（rán）”，其作为一个 Python 发行版，使用了一个关系很紧密的名字。Anaconda 的徽标设计与名字一致，是一条头尾相接的蛇。 Jupyter 从 IPython 衍生而来，现在的名字来源于其支持的核心编程语言 Julia、Python、R，是取了三个名字中的字母拼成的，另外“Jupyter”与“Jupiter”谐音，“Jupiter”则有“木星”的含义，这一名字还暗含了对伽利略记录木星卫星发现的笔记本的致敬。Jupyter 的徽标是木星及其卫星的抽象表达，同时还暗指了三个核心编程语言。 另可参见：维基百科的 Python 页面维基百科的 Monty Python 页面谁设计了Python的徽标？维基百科的 Anaconda 页面Anaconda needs a new logo维基百科的 Project Jupyter 页面维基百科的 IPython 页面维基百科的伽利略·伽利莱页面维基百科的《星际信使》页面清华大学开源软件镜像站新闻页意大利书商伪造伽利略著作以假乱真，藏书圈风声鹤唳 总结 学习 Python 需要的环境配置 Python 程序的撰写、调试方法 JupyterLab 的配置]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010001-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT60001-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名： 王蕊 学号： 1901010001 自我介绍 积极打磨自己成长型人格的终身学习者 抱着“学了有什么用”的心态，探索编程对自己人生意义的行动者 社交学习的实践者]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>自学训练营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010161-自学训练营学习2群-day08学习心得]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901010161-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A02%E7%BE%A4-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901010161 学习内容：try except finally raise（异常处理） 实际学习用时：8小时 学习心得接到任务时觉得自己能很快完成，没想到被一个内置函数绊住了。查了很多资料，总不得要领，最终只好在群里求助，没想到教练绿巨人一下子就帮我解决了难题。教练说：“一般建议不要拿python的内置函数作为变量名。”其实这句话在前面学习的过程中就学到过，但直到现在才真切地体会到了这个知识点的作用。我就是觉得“if type(text) == str:”没有问题，的确没问题，问题出在了后面。我把一个描述性的变量名当做了一个不可改动的设置，从没想过要调整一下这个变量名，导致变量名与内置函数发生冲突。这个让我想到了笑来老师的钥匙肯定不在钥匙孔里的比喻。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
        <tag>学习心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-MIT-自学 lecture9]]></title>
    <url>%2FMIT60001%2F1901030012-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AE%AD%E7%BB%83%E8%90%A5-lecture9notes40%2F</url>
    <content type="text"><![CDATA[学员信息 学号: 1901030012 学习内容: MIT第9课视频文稿p1- 学习用时: 20mins Notes no.: Day40 学习笔记 和@王蕊一起看她的代码问题 没有看到原始书本上的代码，目前我还不能完全理解那段代码的具体问题，报错是显示syntax error，那么是某些部分的语法有问题，我理解是不是强行使用int(str)让某文本对象变成整数的问题？我们准备等晚一点她给我发一下那本书的代码页面照片。我再思考一下，然后一起分析。实在搞不定就群内求助。 复习一下Pull Request 对于静态页面打卡的问题，根据@王蕊整理遇到的困难，再一起梳理一下： 2.1 熟悉打卡模版格式Markdown文档要求的规范格式，通过自行练习输入的方式尽量完成。 2.2 使用Github Desktop与网页仓库进行push and pull，commit。 2.3 观察自己推到网页仓库的.md文档的格式显示的具体问题。 2.4 在本地仓库再次熟悉.md文档规范要求，调整后再update。再commit。 2.5 确认自己的文本符合规范后，准备new pull request。 2.6 @Maestro 然后留言等待审核merge，分享自己的最终文本显示页面链接到俺们营里。 types vs. classes object-oriented programming and classes So implementing the class meant defining your own object type. So you defined the object type when you defined the class. And then you decided what data attributes you wanted to define in your object. So what data makes up the object? What is the object, In addition to data attributes, we also saw these things called methods. And methods were ways to tell someone how to use your data type. So what are ways that someone can interactwith the data type, OK? So that’s from the point of view of someone who wants to write their own object type. So you’re implementing a class. 物理接近的好处就是，鲜活更具有说服力吧，keep alive。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010001-MIT-自学 《Python编程导论第二版》 第一章 启程]]></title>
    <url>%2FMIT60001%2F1901010001-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学员信息 学号： 1901010001 学习内容： 《Python编程导论第二版》 学习用时： 40min 学习笔记 第一章里作者说用计算思维解决工作、学习和生活中的问题。emmm，这个提示很美好！拆开来看，这里面有几个要素，计算思维、遇到的问题。通过学习教材来掌握计算思维。直到目前为止，我都想象不出来，我碰到的那些问题怎么可能用计算的思维来解决呢？这个问题有待学了之后来解决，是我学下去的理由。 知识可以分为两类：陈述性知识和程序性知识。陈述性知识由对事实的描述组成。例如，“如果y*y=x，那么x的平方根就是数值y。”这就是对事实的描述。程序性知识说明“如何做”，描述的是信息演绎的过程。例如，亚历山大的海伦第一次提出如何计算一个数的平方根。 算法是一个有穷指令序列，描述了这样一种计算过程，即在给定的输入集合中执行时，会按照一系列定义明确的状态进行，最终产生一个输出结果。算法包含一些测试指令，用来确定整个过程何时结束；还包含一些顺序指令，用来确定指令执行的顺序。有些时候，还会根据测试结果跳转到某些指令。 现代计算机的核心是可以执行任意合法指令集的程序，被称为解析器，计算机能够计算任何可以使用基本指令集描述的问题。【如果我能用指令将我的问题表达清楚，就可以让计算机来帮我得到结果。这是我目前最大的猜测。】 程序被存储在计算机的某个位置上，在运行的时候你必须告诉计算机要到哪里去找这个程序。 程序里的代码块也不一定非要按照从前到后的默认顺序执行。如果需要跳转到指令序列的其他位置继续执行，可以使用控制流。 编程语言是用来描述可被计算机执行的指令的工具。 计算机只会做你通过编程语言描述的指令。所以运行结果的好坏只能是程序员自己的问题。 现代编程语言提供了更大、更方便的初始指令集。【结合着李善友教授的话，就是已经有现成的公理给我使用了，我只要够勤奋就能用这个公理推导出很多的结论。】 编程基本思想的核心仍然是组装操作序列的过程。 编程语言有基本结构、语法、静态语义和语义。基本结构就是单词，语法则用来描述哪些单词放在一起可以组成通顺的句子，静态语义定义了哪些句子是有意义的，语义则定义了句子的实际含义。 程序语言的语义只有确切的一种。程序员要表达的意思有可能和程序的含义不一样。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE6]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 6+ Python编程导论（第2版）（递归） 学习用时: 3小时 学习笔记收获总结： 递归(recursion)： algorithmically:a way to design solutions to problems by divide-and-conquer or decrease-and-conquer reduce a problem to simpler versions of the same(recursive case) Semantically: a programming technique where a function calls itself in programming, goal is to NOT have infinite recursion must have 1 or more base cases that are easy to solve must solve the same problem on some other input with the goal of simplifying the larger problem input ITERATION vs. RECURSION recursion may be simpler, more intuiSve recursion may be efficient from programmer POV recursion may not be efficient from computer POV 吴军-递归–计算机思维和人的思维最大的不同 很多时候，计算机的思维方式是自顶向下的，即递归（逆向思维）。人的思维方式是自底向上的递推（正向思维）。 递归的便利性来自于它本身是一个简单重复的过程。这样可以把一个复杂的问题分解成很多层简单的问题。 递归算法和堆栈那种先进后出、后进先出的数据结构是对应的。 在具体编写程序时，很多情况是使用递归的原则设计，递推的原则实现。先搞清逻辑再进行物理设计。 递归算法有如下三个特点： 递归过程一般通过函数或子过程来实现。 递归算法在函数或子过程的内部，直接或间接地调用自己的算法。 递归算法实际上是把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数或过程来表示问题的解。 recursion: base case recursive step 遇到的问题和解决方法：花了很多时间去理解递归、递推和迭代之间的不同。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100239-自学营训练19群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100239-%E8%87%AA%E5%AD%A6%E8%90%A5%E8%AE%AD%E7%BB%8319%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[奇点基本信息姓名：奇点学号：1901100239 工作背景体制内工作人员 自我介绍我是一个喜欢读书和学习新东西的人，因为学习笑来老师的《通往财富自由之路》希望可以变成一个拥有多纬度竞争的人，所以来学习python ，同时也是希望和一群优秀的人多学习，因为老师说你像成为什么样的人就多和怎么样的人接触。希望学完课程以后可以了解编程知识，因为自己的编程是零基础。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>入门营</tag>
        <tag>体制内工作人员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE6-2]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 6+ Python编程导论（第2版）（字典） 学习用时: 1.5小时 学习笔记收获总结： 字典(dict)类型的对象与列表很相似，都是可变的，区别在于字典使用键对其中的值进行引用，可以将地点看作一个键/值对的集合。 字典类型的字面量用大括号表示，其中的元素写法是键加冒号再加上值。 dict中的项目是无序的，不能通过索引引用。 字典是Python最强大的功能之一，它可以大大降低编程的难度。 多数编程语言都不包含这种提供从键到值的映射关系的内置类型。（使用散列技术，与字典大小无关） 可以使用for语句遍历字典中的项目，但分配给迭代变量的值是字典键，不是键/值对。迭代过程没有定义键的顺序。 keys方法返回一个dict_keys类型的对象。e.g. dict_keys([‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, 1, 2, 3, 4, 5]) 可以使用for语句遍历dict_type类型的对象，也可以使用in检测其中的成员。list()可以很容易的转换为列表。 字典键必须是一个可散列的对象。所有Python内置的不可变类型都是可散列的，所有可变类型都是不可散列的。所以使用元组作为字典键很方便。 与列表一样，字典有很多非常有用的方法： len(d):返回d中项目的数量 d.keys():返回的中所有键的视图（view对象） d.values():返回d中所有值的视图 k in d:如果k在d中，则返回True。 d[k]:返回d中键为k的项目（返回的是值） d.get(k, v):如果k在d中，则返回d[k],否则返回v d[k] = v:在d中将值v与键k关联。如果已经有一个与k关联的值，则替换 del d[k]:从d中删除键k for k in d:遍历d中的键遇到的问题和解决方法：不理解书上说的迭代没有定义键的顺序，所以结果可能是。。。。，但是我输出很多次都是按照字典的键的顺序。书上用的词是可能会输出。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE7]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 7+ Python编程导论（第2版）（第6章testing） 学习用时: 3小时 学习笔记收获总结： 测试指通过运行程序以确定它是否按照预期工作。 调试则指修复已知的未按预期工作的程序。 在设计程序时就要考虑如何使程序易于测试和调试，关键是将程序分解成独立的部件，可以在不受其他部件影响的情况下实现测试和调试。 测试前的准备： ensure code runs remove syntax errors remove static semantic errors Python interpreter can usually find these for you have a set of expected results an input set for each input, the expected output Class of testing Unit testing(单元测试) Regression testing(回归测试) Integration testing(集成测试) Testing approaches: intuition about natural boundaries to the problem random testing black box testing: explore paths through specification glass box testing: explore paths through code 如果一个白盒测试套件可以测试程序中所有潜在路径，可以认为它是路径完备的，路径完备的测试套件也会漏掉bug。 白盒测试的一些经验： 测试所有if语句的所有分支 必须测试每个except子句 for loop: 未进入循环 循环体只被执行一次 循环体被执行多于一次 while loop： 包括for loop所有用例 包括对应于所有跳出循环的方式的测试用例。 对于递归函数，册数用例应包括函数没有递归调用就返回、只执行一次递归调用和执行多次递归调用的情况。 遇到的问题和解决方法：对书上的测试驱动程序和测试桩的理解不清晰。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE7-2]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 7+ Python编程导论（第2版）（第6章） 学习用时: 2小时 学习笔记收获总结： 关于bug的基本事实如果你写的程序有bug，那肯定是你自己的问题。 运行时错误的两个维度： 显性——隐性：一个错误是否显性的取决于检查程序行为的周密程度。 持续——间歇：持续性错误在每次使用相同输入时都会发生；间歇性错误仅在某些时候出现，即使相同输入在相同条件运行。 防御性编程：显性的和持续性的错误是最好的情况，所以优秀的程序员在编写程序时，会尽量是错误是显性的和持续性的。 Debugging tools: built in to IDLE and Anaconda Python Tutor print statement 最重要的调试工具 use your brain, be systematicin your hunt PRINT STATEMENTS good way to test hypothesis when to print enter function parameters function results use bisection method put print halfway in code decide where bug may be depending on values 调试的科学方法：要将实验过程记录下来。 study available data form hypothesis repeatable experiments pick simplest input to test with Logic error(hard) think before writing new code draw pictures, take a break explainthe code to someone else a rubber ducky Do(testing) Write a function Test the function, debug the function Write a function Test the function, debug the function Do integration testing DO(debugging) Backup code Change code Write down potential bug in a comment Test code Compare new version with old version 谨记测试和调试的目标是得到一个没有错误的程序，而不是修复某一个错误。 遇到的问题和解决方法：测试和调试的思路非常重要，应该主动添加到建立编程的良好规范里面，好的习惯和风格会在未来节省大量时间和精力。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08-08-1901100244-自学训练营-Python入门-Day01-学习心得]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100244-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-Python%E5%85%A5%E9%97%A8-Day01-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100244 操作系统：Windows 10 version 1903 (64-bit) 学习内容：GitHub 的基本使用 学习用时：4 小时 收获总结 明确了使用 Git 和 GitHub 的目的——Git 用于版本控制，GitHub 用于网络协作； 掌握了拉取请求（Pull Request）相关的操作； 了解了 GitHub 的工作流程。 遇到的难点与问题1. “任务2.3 在 develop 分支中创建一个名为 develop.txt 的文件，提交一个 commit” 创建文件的操作方式在“参考资料1”中没有； 新手在尝试创建 develop.txt 时可能会漏掉“.txt”，应予强调； 底部“Commit changes”区的提交信息（a commit message）比较重要，不填写或仅依靠默认内容有可能导致无法提交，造成困扰，应予强调； “提交一个 commit”表意不明，“commit”本身含义即为“提交”，这一词原本还没有名词词性（GitHub 直接把它当名词用了），故原文的写法令人难以理解，考虑上下文及用例（make a commit、add commits，参见 https://guides.github.com/introduction/flow/ ），可改为：“填写相关说明（在页面底部），并提交新文件（Commit new file）”，或者：“填写相关说明（在页面底部），并创建一个提交（commit）”； 2. “任务2.4 从 develop 提交一个 Pull Request 到 master 分支，并将其合并(merge)” “develop”写为“develop 分支”比较好，避免误解； 拉取请求（Pull Request）是 GitHub 协作的核心操作之一，但这个词理解起来颇费思量，简单的解释可以是“请求代码合并”、“请求对方拉你的代码”（ 参见 https://www.zhihu.com/question/21682976 ），比较详尽的解释建议参考 GitHub 官方的说明网页（ https://guides.github.com/introduction/flow/ ）； “(merge)”写为“（Merge）”比较好，与页面一致。 3. “任务3 在 GitHub 的仓库中提交 Issue”Issue 的位置与“参考资料2”中的截图不一致，应是 GitHub 改版导致的，寻觅了一小会儿。 4. “任务4.2 通过 下载地址 安装 Github Desktop 桌面客户端，完成后登录自己的账户” “GitHub Desktop”已经有“桌面”的含义，再说“桌面客户端”有语意重复之嫌，或写为“GitHub Desktop 客户端”即可； GitHub Desktop 登录后如果没有克隆任何仓库到本地的话，主菜单出不来，很难找到登出的地方（我错误地登录了一个旧账号，故需要登出），Google 后了解到，可以通过按快捷键 Ctrl + , 进入 Options 完成登出操作。 5. “任务4.4 在本地电脑的 hello-world 仓库中创建一个名为 local.txt 的文本文件” “文本文件”或应写为“文本文档”，与 Windows 的表述一致。 为了避免建立扩展名错误的文件（如local.txt.txt），应将文件资源管理器设置为显示文件扩展名（【查看】→勾选【文件扩展名】） 6. “任务4.5 通过 Github Desktop 将本地仓库新增的文本文件提交为一个 commit”“提交一个 commit”和“提交为一个 commit”有什么区别？两种表述法都很不清晰，建议改写，或可写为：“填写相关说明（在软件左下角），并提交（Commit to master）”。 7. “任务5.3 通过 Github Desktop 将自己账户下 fork 的作业仓库 clone 到本地电脑” 这一步耗时甚久，大约 180 MB 的文件，下载速度只有 10~20 KB/s，前后花了约两个小时，手册应该对这种情况予以提醒； Google 了一下，知道了出现这种情况的实际原因—— GitHub 相关的一些域名被限制了（如 http://github.global.ssl.fastly.net）； 不同人给了不同的解决方案，如：改 hosts，利用开源中国提供的代码仓库（码云 Gitee）转移，给 GitHub Desktop 设置代理； 个人认为相对彻底的解决方案应该是 GitHub Desktop 整体走代理，方法有两种，一是开 VPN，二是配置 GitHub Desktop； 考虑眼下的实际情况，VPN 不算靠谱，所以就只能配置 GitHub Desktop 了，试验发现，GitHub Desktop 不从系统设置中取代理服务器，用修改配置文件的方法才能设置代理 Windows 版 GitHub Desktop 设置代理的方法如下：i. 用文本编辑器打开 C:\Users\&lt;UserName&gt;\.gitconfig 文件，注意 &lt;UserName&gt; 要换成自己的账户，或者直接搜索“.gitconfig”也可以，这个文件只有扩展名，开头就是一个“.”；ii. 在文件末尾添加代理信息，SOCKS5 代理类似这样： 1234[http] proxy = socks5://127.0.0.1:1080[https] proxy = socks5://127.0.0.1:1080 HTTP 代理类似这样： 1234[http] proxy = http://127.0.0.1:1080[https] proxy = http://127.0.0.1:1080 其中127.0.0.1是代理地址，1080是端口号，proxy前面有一个制表符（Tab），注意，这里的代理地址仅为范例，以具体情况为准。 macOS 版 GitHub Desktop 的 .gitconfig 文件在 ~/，可以在终端（Terminal）用 Vim 打开文件并编辑，步骤为：i. 在终端（Terminal）输入 vi ~/.gitconfig 并回车；ii. 按i键进入插入（insert）编辑模式；iii. 在文件末尾添加代理信息，格式和 Windows 的一样；iv. 按ESC键退出插入编辑模式，输入:wq，回车保存。这部分参考了：https://www.jianshu.com/p/5e74b1042b70。 对比i. 设置前ii. 设置后 总结 搞清楚“拉取请求（Pull Request，简称 PR）”的目的和意义 GitHub Desktop 进入 Option 的方法 GitHub Desktop 代理设置]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020029-自学训练营MIT6.0001Day11~20]]></title>
    <url>%2FMIT60001%2F1901020029-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT60001-Day11-20%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020029 学习内容：MIT6.0001课程打卡11-20天 学习用时：16.5 学习笔记第11天：20190704学习时间：1小时学习内容：MIT Lecture 6(主题：递归，字典)(15min-25min) + PPT(p15-p20)学习收获：1、复习中学学过的数学归纳法：证明与自然数n有关的数学陈述，需分两步验证。先证明当n取最小值时，命题成立；然后假设n=k时命题成立，那么能证明n=k+1时，命题也成立，则两步验证综合起来，可以推出对一切自然数n，命题都成立。2、同样的逻辑可以应用到递归函数，递归设计也是递推原理，在整个程序中，反复实现同一个原理。3、经典的汉诺塔案例，用递归思维来写出代码，简洁好看。 12345678910def printMove(fr, to): print(&apos;move from &apos; + str(fr) + &apos; to &apos; + str(to))def Towers(n, fr, to, spare): if n == 1: printMove(fr, to) else: Towers(n-1, fr, spare, to) Towers(1, fr, to, spare) Towers(n-1, spare, to, fr) 4、要学习的重点：遇到问题时，如何递归地思考解决方案，如何将问题分解成更小版本的同样的问题。 第12天：20190705学习时间：1小时学习内容：MIT Lecture 6(主题：递归，字典)(25min-33min) + PPT(p21-p39)学习收获：1、理解斐波那契数列，它是两个递归调用，有两个基本案例。 1234567def fib(x): “““assumes x an int &gt;=0 returns Fibonacci of x””” if x ==0 or x ==1: return 1 else: return fib(x-1) + fib(x-2) 2、非数问题的递归思考，关于回文，递归代码如下： 1234567891011121314151617def isPalindrome(s): def toChars(s): s = s.lower() ans = &apos;&apos; for c in s: if c in &apos;abcdefghijklmnopqrstuvwxyz&apos;: ans = ans + c return ans def isPal(s): if len(s) &lt;= 1: return True else: return s[0] == s[-1] and isPal(s[1:-1]) return isPal(toChars(s)) 3、理解“分而治之”的智慧：递归算法通过将难题打破分解成一系列子问题，子问题比原始问题容易解决，并且子问题的解决可以被组合起来解决原始问题。 第13天：20190706学习时间：1小时学习内容：MIT Lecture 6(主题：递归，字典)(33min-48min) + PPT(p40-p58)学习收获：1、终于学到这节课的最后一部分了，关于字典数据类型。2、字典以“键 : 值”(“key:value”）对的形式成对存在；用{ }呈现；每对“key:value”之间用“，”分隔；检索是通过“key”来访问“value”，如果“key”不存在，则报错。3、字典的操作：3.1、添加键值对用 dict[key] = value；3.2、删除键值对用 del(dict[key])3.3、查询dict中是否有key，用key in dict，如果有返回True，没有返回False；3.4、用dict.keys()返回dict中的所有的keys组成的元组，用dict.values()返回dict中所有values组成的元组。4、字典的特征：4.1、值可以是任何类型(可变的和不可变的)；可以是重复的；可以是列表甚至是另一个字典。4.2、键必须是独一无二的；是不可变类型；浮点类型做键时需仔细4.3、字典是无序的。5、字典在捕获中间值时可以极大的提高效率，最后的这块斐波那契代码案例理解不了，只能先记住字典有这个功用。 第14天：20190708学习时间：1.5小时学习内容：MIT Lecture 7前20分钟(testing、debugging)+ PPT(1-17)学习收获：1、周末去外地参加大学宿舍同窗20年聚会，20年没见了，激动开心外加感慨良多,一直在路上,昨天未打卡。2、回归常态学课，是Ana老师，开心！第7节讲程序的测试和调试，测试是找出程序中的错误，调试则是修复未按预期工作的程序。3、学会防御性编程：给函数写说明书、模块化程序、检查输入输出条件，用测试和调试达成目标。4、什么时候进行测试？保证代码去除语法、静态语义错误，可以运行；针对输入，有一套预期的结果时，即可进行测试。5、测试的执行：单元测试：测试每一个独立单元，每一个函数是否正常工作。回归测试：发现bug，对bug进行测试，抓住再次引入的错误。集成测试：测试整个程序能否按预期运行。6、具体的测试方法：直观的界定问题的自然边界；如果没有自然边界，可以进行随机测试；黑盒测试：通过说明书探索测试路径；白盒测试：通过内部代码探索测试路径；7、常见错误类型：IndexError、TypeError、NameError、SyntaxError8、不要做的事：写整个的程序、测试整个的程序、调试整个的程序。9、要做的事：写一个函数、测试函数调试函数；写一个函数，测试函数调试函数；一直这样直到进行集成测试。10、不要直接修改代码，记住bug位置，测试代码，忘记bug位置或修改了哪些代码，然后恐慌；而是要备份代码后，再修改代码，备注潜在的bug，测试代码，对比新旧版本。养成好习惯很重要。 第15天：20190709学习时间：2小时学习内容：MIT Lecture 7后20分钟(EXCEPTIONS, ASSERTIONS)+PPT(18-35)学习收获：1、尝试看英文字幕理解课程，还是有难度，那层玻璃纸还是有点厚。2、异常(EXCEPTIONS)的类型：IndexError、TypeError、NameError、SyntaxError、AttributeError、ValueError、IOError3、Python代码处理异常的方法：3.1、使用try-except代码块，一旦try代码块内抛出异常，直接跳到except代码块执行程序；3.2、可以用各自独立分开的except子句来处理特殊类型的异常，比如在try代码块后分别跟except ValueError：、except ZeroDivisionError：、except：三个代码块来实现；3.3、使用else：，在try代码块执行结束没有异常出现时执行else body；3.4、使用finally：，finally body总是在try，else和except子句之后执行，对于清除代码有用；3.5、把异常当作控制流，当不能产生符合函数规范的结果时，用raise语句引发一个异常。raise （）4、断言（ASSERTIONS)4.1、使用assert语句确保程序状态符合预期；4.2、如果不符合预期，assert语句会引发一个AssertionError异常；4.3、断言是非常好的防御性编程工具。存在的问题：1、想了好几天要开始做psets了，心理上总有点逃避，没了外界约束(训练营)，大脑总想偷懒。2、理解课程开始变的很慢，一节课要反复听，才能写出一点收获，课程里的example都没有仔细理解。3、do excises、do excises、do excises 第16天：20190710学习时间:2小时学习内容:MIT Lecture 8（OOP)+PPT(1-9)学习收获：1、理解对象objects：Python支持多种数据，每种数据是一个对象，每个对象有：一种类型；一种内部数据表示法；一套与对象交互的程序。并且一个对象是一种类型的实例。2、理解面向对象编程OOP：Python中的一切都是对象(有一种类型)，可以创造某种类型的新对象，可以操作对象，可以破坏对象。3、理解什么是对象？对象是一种数据抽象，通过数据属性获得内部表达，通过方法（程序/函数）实现与对象的交互，定义行为但是隐藏细节。4、理解OOP的优点：将数据及对数据的操作捆绑在一起形成很好的交互；分而治之，可以分别对每个类进行操作和测试，增加模块性减少复杂性；类使代码容易重复使用。5、用类可以创造和使用自己的类型：注意区分创造一个类和使用类的实例的不同，创造类包括定义类的名称、定义类的属性；使用类包括创造新的对象实例，对实例进行操作。6、使用class关键词定义一个新类型：例如：class Coordinate（object）：7、什么是属性？数据和程序属于类；数据属性是将数据看作组成类的其它对象，比如坐标是两个数字的组合；方法是程序属性，想象方法是函数，只和这个类工作，如何与对象交互，比如你可以在两个坐标对象之间定义一个距离，但是在两个列表对象之间定义距离就没有意义。 第17天：20190711学习时间：2小时学习内容：MIT Lecture 8（OOP）+PPT(10-20)+ps0(1-3)学习收获：1、定义如何创建类的实例：1.1、首先不得不定义如何创建对象的实例1.2、使用特殊方法init来初始化某种数据属性，例如在坐标类下： 123456class Coordinate（object）： def init(self，x，y）： self.x = x self.y = yc = Coordinate（3，4）print（c.x） 1.3、一个实例的数据属性被叫做实例变量1.4、不用为self提供参数，Python自动完成2、什么是方法？2.1、程序属性，像是函数仅在类中工作2.2、Python总是把对象作为第一个参数，惯例用self做所有方法的第一个参数名2.3、“.”操作符被用作进入任一属性，或数据属性或方法3、OOP的力量3.1、捆绑对象分享通用的属性以及对这些属性的操作3.2、使用抽象来区分如何实施对象和如何使用对象3.3、建立对象抽象的层级来从其他类对象中继承行为3.4、在Python基础类的顶层创造我们自己的对象类型4、完成ps0的1-3 123input(&quot;Enter number x: &quot;)input(&quot;Enter number y: &quot;)print(&quot;x**y= &quot;,x**y) 5.学习使用Typora，早就下载了软件，但一直不会使用，打卡一直用的page文档，今天尝试使用。 第18天：20190712学习时间：2小时学习内容：MIT Lecture 9前半部分+PPT（1-15）+ps0学习收获：上节课通过坐标和分数两个例子掌握通过类实现的抽象数据类型，本节课继续深入了解类和继承的概念。1、实现类与使用类是从两个不同的角度来编写代码： 实现类要定义类（一个新的对象类型）、定义数据属性（对象是什么）、定义方法（如何使用对象） 使用类则是创建对象类型的实例，对它们进行操作。 2、对象类型的类定义与类实例的区别： 类的名字是类型；类定义属性，self是参数；类定义数据和方法，适用于所有的实例 实例是一个专门的对象；数据属性的值在不同的实例中是不同的；实例具有类的结构 3、使用OOP和类能够模拟真实世界，将具有相同属性的对象归类处理，使同类对象具有数据属性（是什么）和程序属性（可以干什么）4、如何定义一个类： 1234class Animal (object)： def __init__(self, age): self.age = age self.name = None 5、getters和setters方法被用于类的外部读取数据属性。 12345678class Animal (object)： def __init__(self, age): self.age = age self.name = None def get_age(self): return self.age def set_age(self, newage): self.age = newage 6、点计法示例及注意事项：a = Animal(3)a.age #点计方法a.get_age() #getters方法对于一个对象实例a，用a.age可以进入数据属性，允许但不推荐；用a.get_age()是更好的进入方法。7、层级： 父类（超类） 子类（亚类）：继承父类所有的数据和行为；增加更多信息；增加更多行为；覆盖行为 8、ps0： 1234567import math input(&quot;Enter number x: &quot;)input(&quot;Enter number y: &quot;)x = 2y = 3print(&quot;x**y = &quot;,x**y)print(&quot;log(x) = &quot;,int(math.log(x,2))) 第19天：20190715学习时间：2小时学习内容：MIT Lecture 9后半部分+PPT（16-26）学习收获：1、以一系列具体的代码实例来帮助理解父类和子类的继承方法，这一部分视频内容要将代码实例拷贝到spyder中去运行一遍才好理解。2、子类继承父类的所有属性，还可以经由method添加新功能，子类可以调用添加的新功能，父类调用则会报错；子类中可以没有init，直接使用父类中的版本。3、使用哪一个方法？ 子类可以有和父类相同的方法名 对于一个类的实例，在当前类定义中寻找方法名 如果找不到，到上一层级中去找方法名（比如父类、祖父类等） 使用你向上一层级找到的第一个具有那个方法名的方法 4、类变量：类变量和它们的值在所有的类实例中被分享，用tag标签表示在def init之前。5、面向对象编程（OOP)的特点： 创造你自己的数据收集 组织信息 分解工作 用一致的方式进入信息 添加复杂的层级 像函数一样，类是一种用于编程的分解和抽象的实现技巧 第20天：20190716学习时间：2小时学习内容：MIT Lecture 10 + PPT（1-20）学习收获：1、对程序的效率有初步认识，理解如何测量算法的增长、大O表示法、复杂性类。2、程序可以有不同的实现方法，哪一种选择更高效，将程序运行的时间效率（运行快慢）和空间效率（运行时占用内存的大小）分开考虑，在二者之间获取最佳平衡方案。3、如何评估程序的效率？ 用计时器 计算操作步骤 应用量级这个抽象概念（最合适的评估方式），它能实现： 当输入非常大时想要评估程序的效率 当输入规模增长时想要表达程序的运行时间增长 想要尽可能简洁的设置增长上限 不需要精确到准确的增长，是增长的级别 我们将考虑在运行时间方面的最大因素（程序的哪一部分将花最长运行时间？） 因此，通常我们想要在最糟糕情况下，根据输入的函数规模，找到尽可能简洁的增长上限 4、测量量级用大O表示法： 大O表示法测量一种渐进增长的上限，通常叫作量级 大O或O()被用于描述最差情况 最差情况通常是程序运行的瓶颈 表达与输入规模相关的程序增长率 评估算法而非机器或执行 5、量级的类型：常数、线性、二次方、对数、对数线性、指数6、对课程的学习基本是通过努力理解并翻译PPT来完成的，很吃力，但知道自己在进步，加油！]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
        <tag>知识点总结‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100256-自学训练营学习19群-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100256-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A019%E7%BE%A4-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：岚岚学号：1901100256 工作背景公司职员、烘焙个人工作室 自我介绍”把时间当作朋友“把我一路带到编程自学营来，为什么学编程现在也不是很清楚，磨练笑来老师讲的自学能力把，可能更多是想管理自己，学习和成长总是没错的，加油吧。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>入门营</tag>
        <tag>烘焙工作室</tag>
        <tag>公司职员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020029-自学训练营-MIT60001-Day21~30]]></title>
    <url>%2FMIT60001%2F1901020029-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT60001-Day21-30%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020029 学习内容：MIT6.0001课程打卡21-30天 学习用时：18小时 学习笔记第21天：20190717学习时间：1.5小时学习内容：MIT Lecture 10 + PPT（21-39）学习收获：1、程序复杂度级别的组合： 分析函数内部语句 应用某些规则，聚焦于主项 O():的乘法法则用于嵌套语句/循环 O(f(n)) * O(g(n)) is O(f(n) * g(n)) 2、复杂度级别，下述复杂度级别按顺序由低到高 O(1)表示常数运行时间 O(logn)表示对数运行时间 O(n)表示线性运行时间 O(n logn)表示对数线性运行时间 O(n^c)表示多项式运行时间（c是一个常数） O(c^n)表示指数运行时间 3、简单的迭代循环算法是典型的线性复杂度。4、对无序列表和有序列表进行线性搜索，其总体复杂度都是O(n)，这里的n是列表长度len(L)。注意：尽管两种搜索方法的运行时间可能有差别，但增长的量级是相同的。5、用子集测试的函数例子来说明嵌套循环的复杂度是平方复杂度O(n^2)。 第22天：20190718学习时间：1小时学习内容：MIT Lecture 11前10min + PPT（1-10）学习收获：1、继续理解程序的效率，从设计开发程序的角度理解当输入规模变大时，所耗成本-时间的增长程度，考虑选择合适的算法以达成目标，继续讨论算法复杂度。2、为什么要懂得程序的效率？ 我们怎样评估当需要解决特定规模的问题时，需要花费多少时间成本。 我们怎样关联算法的时间效率，来选择算法的设计。对我们要解决的特定问题有基础的时间限制吗？ 3、以下复杂性类是复杂度从上到下依次递增的，因此我们实现算法设计时，希望在序列的顶端，如果程序复杂度随输入规模的增长呈指数递增，程序的实现将是灾难性的。 O(1) O(logn) O(n) O(n logn) O(n^c) O(c^n) 4、常数复杂度 复杂度与输入规模无关 这类程序很少有有趣的算法，但有一些代码片段可以归于此类 可以有循环或递归调用，但迭代或调用次数与输入规模无关 5、对数复杂度 复杂度的增长是一个输入的对数 例子：二分搜索、列表的二分查找 第23天：20190720学习时间：1.5小时学习内容：MIT Lecture 11(10-20min )+ PPT（10-14）学习收获：1、继续学习具有对数复杂度的二分搜索例子。2、关于二分搜索： 假定我们想知道是否一个特定元素存在于一个列表中 看上次我们可以仅仅沿着列表走，检查每一个元素 复杂度与列表长度呈线性关系 假定我们知道列表是从最小到最大有序排列 看那个有序搜索在复杂度上仍然是线性的 我们能做的更好吗？ 选一个索引，i，将列表一分为二 问是否L[i]==e 如果不等于，问是否L[i]是比e更大多更小 依据答案，搜索对e而言的左侧或右侧的另一半L 一个新版的分而治之算法出现 问题被分解成更小的版本(更小的列表)，加某些简单操作 对更小版本的答案是对原始问题的答案 二分搜索复杂度分析 当对半减小列表到只剩一个元素时结束搜索，1=n/2i，所以i=logn 递归的复杂度是O(log n)——这里n是len(L) 3、二分搜索代码的实现1： 1234567891011def bisect_search1(L, e): if L == []: return False elif len(L) == 1: return L[0] == e else: half = len(L)//2 if L[half] &gt; e: return bisect_search1(L[:half], e) else: return bisect_search1(L[half:], e) 4、二分搜索方法1的复杂度：implementation1-bisect_search1 O(log n)分半搜索调用 每一次递归调用，被搜索的范围规模被减半 如果原始规模是n，最差的情况直到搜索范围为1是当n/(2^k)=1，或当k=logn O(n)对每一次分半搜索调用拷贝列表 这是建立每一次调用的成本，所以对每一层递归这样做 O(log n)*O(n)得出O(n logn) 如果我们足够仔细，注意到被拷贝的列表长度在每一次递归调用时也被减半了 结果是拷贝的总成本是O(n)并且统治了递归调用产生的logn成本 第24天：20190721学习时间：40分钟学习内容：MIT Lecture 11 PPT（15-19）学习收获：1、二分搜索的替代方案 每一步仍然通过两个因素缩减问题的规模 但是仅记录被搜索的列表的低和高部分 避免拷贝列表 递归的复杂度又是O(logn)——这里n是len(L) 2、分半搜索代码的实现2： 123456789101112131415161718def bisect_search2(L, e): def bisect_search_helper(L, e, low, high): if high == low: return L[LOW] == e mid = (low + high)//2 if L[mid] == e: return True elif L[mid] &gt; e: if low == mid: #nothing left to search return False else: return bisect_search_helper(L, e, low, mid - 1) else: return bisect_search_helper(L, e, mid + 1, high) if len(L) == 0: return False else: return bisect_search_helper(L, e, 0, len(L) - 1) 3、二分搜索方法2的复杂度：implementation2-bisect_search2 O(log n)分半搜索调用 每一次递归调用，被搜索的范围规模被减半 如果原始规模是n，最差的情况直到搜索范围为1是当n/(2^k)=1，或当k=logn 通过列表和目录作为参数 列表从不拷贝，只是作为指示器被重新通过 因此O(1)工作于每一个递归调用 O(logn)*O(1)得出O(logn) 4、对数复杂度的数字转换为字符串的例子： 123456789def intToStr(i): digits = &apos;0123456789&apos; if i == 0: return &apos;0&apos; result = &apos;&apos; while i &gt; 0: result = digits[i%10]+result i = i//10 return result 因为没有函数调用所以仅需检查循环语句 在while循环中，迭代步数是常数 循环多少次？ 多少次一个数可以用i除以10做整数除法 O(log(i)) 第25天：20190723学习时间：3小时学习内容：MIT Lecture 11 PPT（20-39）学习收获：1、在学习过程中还是会偷懒，比如视频课听的云里雾里时，就会先把视频放在一边，去理解PPT，尝试自己翻译理解PPT，今天回头再听视频课，发现理解的多一些了，同时也校验了自己翻译时的很多错误理解。又遇到了一节课，要打卡很多天才能完成。2、这节课老师在用各种案例教我们理解算法的效率，懂得程序的复杂度概念，知道程序运行时伴随输入规模的增长，程序的计算复杂度会以怎样的方式递增，会用大O法进行评估。3、线性复杂度的算法实例：迭代和递归3.1、迭代算法的O() 复杂性可以依赖迭代调用的次数 12345def fact_iter(n): prod = 1 for i in range(1, n+1): prod *= i return prod 总体复杂度为O(n)——n次循环，每次花费常数成本 3.2、递归算法的O() 123456def fact_recur(n): &quot;&quot;&quot;assume n&gt;=0&quot;&quot;&quot; if n &lt;=1: return 1 else: return n*fact_recur(n-1) 估算递归因子 如果你计时，会发现它运行的比迭代版本慢一些，因为函数调用的原因 复杂度仍然是O(n)，因为函数调用的次数和n呈线性关系 迭代和递归因子的实现具有相同的增长订单 4、对数线性复杂度：非常强大的算法，普遍的应用在合并排序中，下节课将详细介绍5、多项式复杂度：最常见的是二项式复杂度，即复杂度按照输入规模的平方增长；通常在有嵌套循环或嵌套递归的地方出现6、指数复杂度 递归函数里有超过一个递归调用时 汉诺塔 许多重要问题本身就是指数性质的 很不幸，成本很高 将引导我们考虑近似解，这样可以更快地获得合理的答案 6.1、汉诺塔的复杂度：这里老师用数学公式推导出解决汉诺塔问题的时间成本，即增长订单为指数级的增长O(2^n)6.2、功率集的概念，解决给定一个没有重复的整数集，然后生成该集合的全部子集的方案。用递归思维来思考： 我们想生成从1到n的整数功率集 界定我们能生成从1到n-1的整数功率集 那么所有那些子集属于更大的功率集（选择不包括n）；并且当n加到所有那些子集后也属于更大的功率集（选择包括n） 非常好的递归描述12345678910def genSubsets(L): res = [] if len(L)==0: return [[]] smaller = genSubsets(L[:-1]) extra = L[-1:] new = [] for small in smaller: new.append(small+extra) return smaller+new 对此递归函数的复杂度理解，函数的计算时间包括解决更小问题的时间，加上在更小的问题里拷贝全部元素所需的时间，最终计算出功率集的复杂度为O(2^n) 7、复杂度等级 O(1)—代码不依赖于问题的规模 O(log n)—通过进程每次将问题缩减为一半 O(n)—简单的迭代或递归程序 O(n log n)—下节课会看到 O(n^c)—嵌套循环或嵌套递归调用 O(c^n)—每一层有复杂的递归调用 8、大O总结 比较算法效率 描述增长的符号 增长级别越低越好 不依赖于机器或是专门的实现 使用O 描述增长订单 渐进表示法 上限值 最差情况分析 第26天：20190724学习时间：2小时学习内容：MIT Lecture 12 视频+ PPT学习收获：1、在学习了各种搜索算法后，本节课讲解排序算法以及它们的复杂度，排序算法包括monkey sort、bubble sort、selection sort、merge sort1.1、monkey sort：也叫bogo sort 最好的情况：如果有序，复杂度为O(n) 最差的情况：如果无序，很不幸，复杂度为无限的O(?) 1.2、bubble sort：复杂度为O(n2)——这里n是len(L)1.3、selection sort：复杂度为O(n2)——这里n是len(L)1.4、merge sort：复杂度为O(n log(n))——这里n是len(L)，运用递归思维，merge sort是最快的排序实现2、课程来到尾声，我们在6.0001课堂都学到了啥？2.1、核心议题 用数据结构来表示知识 迭代和递归作为计算隐喻 程序和数据类型的抽象 使用对象类和方法类组织和模块化系统 不同的算法类，搜索和排序 算法复杂度 2.2、课程6.0001概要——希望为学习者开启一条路径，像计算机科学家一样思考和行动。 学习计算模式思维 开始掌握计算问题解决的艺术 让计算机做我们想让它做的事 2.3、计算机科学家做什么？ 他们从计算方面思考：抽象、算法、自动化执行 正像阅读、写作和数学一样，计算思维正成为每一个受过良好教育的人所需要的基本技能。 2.4、计算思维的3A： abstraction抽象 选择正确的抽象 同时在抽象的多层进行操作 定义抽象层级之间的关系 automation自动化 按照机械化我们的抽象来思考 机械化是可能的——因为我们有精确的严格的符号和模型，并且因为有“机器”可以翻译我们的符号 algorithms算法 用于描述自动化进程的语言 也允许对细节进行抽象 用于交流想法和进程的语言 2.5、计算思维的面貌 这个问题有多难，我如何最好的解决它？ 理论上计算机科学对这些以及相关问题和答案给出确切含义 递归的思考 将一个看上去困难的问题分解形成一个我们知道如何解决的问题 缩小、嵌入、转换、模拟 第27天：20190725学习时间：2小时学习内容：MIT6.0001 ps0学习心得：1、自学营虽然连滚带爬的走过，但都查阅的中文材料，现在开始老老实实啃英文，欠的债总是要还的，一个字一个字认真读。2、ps0 : the goal of this programming exercise is to make sure your python and numpy installations are correct, and you have the ability to print out results, the ability to read input from a user at the console, and the ability to store values in a variable, so the program can access that value as needed.3、Assignment：write a program that does the following in order: 1.Asks the user to enter a number “x” 2.Asks the user to enter a number”y” 3.Prints out number”x”, raised to the power”y”. 4.Pirnts out the log(base 2) of “x”. 4、代码： 123456import mathx = int(input(&quot;Enter number x: &quot;))y = int(input(&quot;Enter number y: &quot;))print(&quot;x**y = &quot;,x**y)print(&quot;log(x) = &quot;,int(math.log(x,2))) 5、运行结果： 6、7.11打卡时做过这部分的，现在能发现之前的错误并改之。另外虽然代码很简单，但是在完成的过程中，需要老老实实阅读很多hints，终于将英语用起来了。7、pkgtest.py的运行测试是这样的： 第28天：20190726学习时间：2小时学习内容：学习使用pythontutor，阅读style guide，练习pset1part A。学习心得：1、学习在线使用pythontutor，将自学营作业99乘法表的代码放进去，一步步查阅程序是如何实现的。2、pset1 part A部分自己一条条列出了变量，也可以按照用户输入条件一个月一个月的自己在纸上进行计算，但到循环这部分，感觉还是写不出代码，和在自学营一样，需要借鉴同学的打卡，才能生成最终结果，是否已经形成了依赖心理？3、代码4、运行结果 第29天：20190727学习时间：0.5小时学习内容：继续pset1part B。学习心得：1、pset1 part B在partA基础上增加了一条每半年薪资按一个固定比例调高，只要在自增长的月份上增加一条，当月份数除6的余数为0时，年薪调整为原有年薪+年薪*调薪比例即可。另外初始变量需添加一个需要用户给定的每半年薪资增长率。2、代码 12345678910111213141516171819202122232425262728# 年度薪资annual_salary = int(input(&quot;Enter your annual salary: &quot;))# 每月薪资存款比例portion_saved = float(input(&quot;Enter the percent of your salary to save, as a decimal: &quot;))# 心仪房产总价total_cost = int(input(&quot;Enter the cost of your dream home: &quot;))# 每半年薪资增长率semi_annual_raise = float(input(&quot;Enter the semi-annual raise, as a decimal: &quot;))# 首付款比例portion_down_payment = 0.25# 首付款down_payment = total_cost * portion_down_payment# 存款年化收益率r = 0.04# 起始存款current_savings = 0# 起始月份number_of_months = 1while True: # 当月存款=起始存款+月薪*每月存款比例+投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*r/12 if current_savings &gt;= down_payment: print(&quot;Number of months: &#123;&#125;&quot;.format(number_of_months)) break if number_of_months % 6 == 0: annual_salary += annual_salary * semi_annual_raise number_of_months += 1 3、运行结果 第30天：20190729学习时间：2小时学习内容：重读《自学是门手艺》part.1.A-part.1.E.3+思考pset1partC。学习心得：1、前言，重视一切老生常谈，向真正做到的老生学习，听话照做就好。2、习得自学能力的终极目标：有能力只靠阅读习得新技能。3、运算和流程控制组成计算机程序的两个最基本成分。4、数字值和字符串值的逻辑操作符包括：&gt;、&lt;、==、&gt;=、&lt;=、!=、in(属于)5、数字的操作符有：+、-、、/、//、%、*6、布尔值的运算操作符为：与、或、非，用and、or、not表示7、任何一个逻辑表达式都会返回一个布尔值：False 或是 True8、所有的工具都一样，效用取决于使用工具的人。学会使用工具固然重要，更重要的是自己的能力不断提高。9、放慢速度耐心体会流程控制章节，将示例拷贝到pythontutor仔细理解流程的走向。 只处理一种情况，用if … 处理True/False两种情况，用if … else … 处理多种情况，用if … elif … elif … else … 迭代有序数据类型，用for … in …，如果需要处理没有break发生的情况，用for … else … 其它循环，用while … 与循环相关的语句还有continue、break、pass 10、MIT pset1partC部分，知道是要用二分搜索查找最佳存款比例，头脑中思路还是不清晰，另外语言的理解上也有不清晰的地方，忍住了没有参考同学们的答案（好像有点养成习惯了），自己再思考几天，反复学习理解一下二分搜索的代码示例，争取自己做出答案。11、另外感谢@陪练-QueenieQ的热心答疑，前两天的打卡文内图片已经用iPic上传图片至图床，可以有链接看到图片了。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
        <tag>知识点总结‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE5-2]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 5+ Python编程导论（第2版）（第5章） 学习用时: 2小时 学习笔记收获总结： 字符串只能包含字符，应用范围远远小于元组和列表。但是处理字符串的内置方法很多，重点是，字符串是不可变的，所有方法都返回一个值，而不会对原字符串产生副作用。 s.count(s1):计算字符串s1在s中出现的次数。 s.find(s1):返回字符串s1中第一次出现时的索引值，如果s1不在s中返回-1. s.rfind(s1):功能与find相同，只是从s的末尾开始反向搜索（rfind中的r表示反向） s.index(s1):功能与find相同，s1不在s中，抛出异常。 s.rindex(s1):功能与index相同，反向搜索。 s.lower():将s中的所有大写字母转换为小写。 s.replace(old,new):将s中出现过的所有字符串old替换为字符串new。 s.rstrip():去掉s末尾的空白字符。 s.split(d):使用d作为分隔符拆分字符串s，返回s的一个子字符串列表。 列表和字符串的转换： list(s):convert string to list. ‘’.join:convert list of characters to string 字符串、元组、范围与列表（str,tuple,range and list),共同之处是使用下述操作： seq[i]:返回序列中的第i元素。 len(seq):返回序列长度。 seq1 +seq2:返回两个序列的连接（不适用于range）。 n*seq:返回一个重复了n次seq的序列。 seq[start:end]:返回序列的一个切片。 e in seq:如果序列包含e，返回True，否则返回False。 e not in seq:如果序列不包含e，返回True，否则返回False。 for e in seq:遍历序列中的元素。 L=[9,6,0,3] sorted(L) #returns sorted list, does not mutate L L.sort() #mutates L=[0,3,6,9] L.reverse() #mutates L=[9,6,3,0] 别名（alias），append()具有副作用，改变列表造成对象的别名，无意形成的别名会导致程序错误，并且非常难以捕获。 克隆(clone),避免修改一个正在遍历的列表，因为Python内置计数器的存在，列表改变后计数器+1，索引值是按照新列表的索引，会产生问题。避免的方式是克隆，遍历克隆的列表。 create a new list and copy every element newL1 = L1[:] for e1 in newL1 遇到的问题和解决方法：对列表的可变性理解不透彻。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-08-07-1901100244-自学训练营-Python入门-Day00-学习心得]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901100244-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-Python%E5%85%A5%E9%97%A8-Day00-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100244 学习内容：前期准备 学习用时：2 小时 收获总结 明确了“自学是一种社交行为”； 认识到入门营的目的：先完整地做完一轮任务，不求甚解； 要尝试通过多种途径进行学习，包括但不限于：课程文档、官方文档、搜索引擎、课程教练、训练营同学； 不要认为“没什么可谈的”，事实上，学习过程中出的很多问题都并不复杂，觉得需要问就问，觉得可以答就答，不必在意“露怯”； 教学相长，自己可能晃过了别人掉的坑，别人也可能跳过了自己掉的坑，相互帮助，学习效果才会更好。 遇到的难点与问题1. 网络环境正常访问 GitHub 和 Google 是个难点，不过班里没有人聊这个（可能是不方便聊），不知都是怎么搞定的，推测应该是八仙过海了。 由于自己主要用的是飞机/火箭，多少关注了些机场相关的信息，这里就提一个评测帖好了：毒药机场简介 https://github.com/DuyaoSS/SSR/issues/1。 2 手册话语手册当中有大量不甚规范的表达，比如—— 标点 所谓”自学”，就是”自己一个人（默默地）学” 其中引号有误 名词 可以通过 google 翻译或找到翻译件 文字排版请使用 markdown 语法 Github issue 区 是很好的交流场所 其中 Google、Markdown、GitHub 的拼写不规范 病句 训练营由 “新生大学” 发起，针对基础相对薄弱，想要自学 Python 的人组织的训练营。 教研组由李笑来担任组长，帮大家形成以开放的互联网为师，习得自学这门手艺。 这两句话都有成分残缺或赘余的问题 还有很多同类情况，就不一一列举了。 这类问题在阅读时会给人“磕磕绊绊”的感觉，或许很多人并不在意这些细节，但这些细节会从一个侧面体现出主办方的水平，故而也不应轻慢。 总结 科学上网问题已解决 训练营文档应整体编修]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-MIT-自学 lecture8]]></title>
    <url>%2FMIT60001%2F1901030012-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%90%A5-lecture8notes39%2F</url>
    <content type="text"><![CDATA[学员信息 学号: 1901030012 学习内容: MIT第8课视频文稿p11-13 学习用时: 20min Notes no.: Day39 学习笔记 type vs. classIf we look at coordinate as a class, if we print what coordinate is, coordinate is a class, right?So this is what Python tells us, if we print coordinate, it’s a class named coordinate.And if we print the type of a coordinate, well that’s just going to be a type. So class is going to be a type. [why?]So you’re defining the type of an object. If you’d like to figure out whether a particular object is an instance of a particular class, you use this special function called isinstance. So if you print is instance C comma coordinate, this is going to print true because C is an object that is of type coordinate. This does not make sense to me:12345678print(Coordinate)&lt;class __main__.Coordinae&gt;print(type(Coordinate))&lt;type &apos;type&apos;&gt;use isinstance() to check if an object is a Coordinateprint(isinstance(c, Coordinate))True The computer only do what you tell it how to, and Python tooIf you have not implemented this method and you try to add two objects of type coordinate, you’re going to get an error because Python doesn’t actually know right off the bat how to add two coordinate objects, right? You have to tell it how to do that. And you tell it how to do thatby implementing this special method. Same with subtract. Same with equals.|SPECIAL OPERATORS| | –|–|defined | meaningadd(self, other) | self + othersub(self, other) | self - othereq(self, other) | self == otherlt(self, other) | self &lt; otherlen(self) | len(self)str(self) | print(self) … and others, do whatever you’d like to do. And then youdocument what you’ve decided. 相信自己的源头–自己的行动如果我没有行动，那么还是不信点滴，认为一点一滴没有那么重要，那么还是回到自己的定义里再审视，有部分没有想明白。点滴是什么？点滴是构筑希望的点点滴滴。所以，自检机制很重要。1234def self_move(something) if practice(something) == False return Noneself_move(MIT_record)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020029-自学编程:我的python语言学习地图]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901020029-%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B-%E6%88%91%E7%9A%84python%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020029 学习内容：Python 14天入门 学习用时：50小时 编程训练营学习感悟和心得14天的编程训练营迎来了尾声，回顾这14天的经历，可以用难熬来形容，从报名入营时的满心期待、到提前做准备在开营前快速通读《自学是门手艺》给自己减压、再到开营第一天完成各项任务用时5个多小时差点崩溃、又经历周末带娃根本没时间、娃生病发烧折腾一整夜身心俱疲，可是这一切困难最终都被战胜了，这14天的时间被化作完成的每一项任务成为陪伴自己的朋友。 我想能完成任务的一个很重要因素归功于笑来老师说的：给自己做心理建设很重要。别怕，千万别怕。 这14天我反复在想，编程零基础的人不可能14天就学会编程，那这14天的训练营目的到底何在，就像笑来老师说的，若不是这么多年一直看着他一步步做到，自己又怎么会一看到训练营的消息，不做停留的就付费参与，参与之后又从中学到了什么呢？ 首先，编程是门语言，是写给机器读取的语言，机器读取人下达的指令（程序），然后帮助人完成各项重复的工作，节省时间，提高效率。 这14天训练营的安排就是从python程序能实现的最小的那项任务开始，我们实现了在屏幕上打印出“hello world！”、写出一个最简单功能的计算器、运行九九乘法表、理解数据容器的概念、编写函数实现统计词频的功能、学会调用自己编写的函数、为函数添加参数类型检查以便捕获异常、了解标准库的功能、了解第三方库的功能、还进行了三天的实战演习，在微信上实现通过网络请求抓取网页内容，并对内容进行词频分析，将结果发送给指定邮箱，还可以将抓取内容词频分析后的结果生成图表回复给某人。 其实这是在最短的时间内，让我们对编程的每一个最基础的底层概念有一个最直观的体会，知道它能干什么，而为了知道这一点，你就得想尽各种办法让布置的任务能够达成，让程序在自己的终端运行，看看它到底长什么样。说句心里话，过程真心不容易。 前两天的任务还可以直接在网上搜索到代码，将现成的代码敲入自己的计算机，看看它实现出来的样子，可后面的任务便是层层嵌套，功能越来越复杂，这里面最重要的是解题思路，可是发现看完每天的参考资料后，自己一点思路都没有，怎么办？于是我开始参考同学的作业，很庆幸自己是第2期学员，第1期学员早三天已经开始学习之旅，于是第1期学员提交的作业成为了我的重要参考资料，把每一位学员的作业都翻一遍，尝试理解其中的解题思路，从中参考自己能看的懂的代码，思路清晰的作业，敲进自己的机器，看是否能够运行，出现了什么问题，再google解决。这个过程也克服了自己的抄袭心理，开始觉得自己这是抄作业，在偷懒，可是后来我认识到，时间有限，把别人写好的代码敲一遍，自己理顺思路，能让程序成功运行也是一种学习，于是靠着参考别的学员的作业，我才完成了14天的任务，在此感谢每一位被我参考借鉴过的同学。 对于其中的向教练请教、和同学互动的环节，自己的感受真的是当被各种小问题卡住时，想向教练描述清楚自己的问题都很不容易，这些天开始习惯养成在github上看别的同学提出的问题，也看看其它同学的解答，理解学习是一种社交行为的具体路径。 还要特别感谢的一个人就是我的LG，我俩一起报名参加的训练营，被分在不同的班，最后三天的实战演练，就算是我借鉴1期同学的作业，也跑不出程序，其中一个很重要的原因是，之前完成的作业内部逻辑并没有理顺，很多参数设置的很乱，要不是和LG一起讨论，并在他的帮助下整理之前的作业内容，恐怕最后几天的作业就完不成了。 最后总结一下自己的收获： 1、不停的给自己做心理建设，相信自己能学会，编程就是一门手艺，相信自己花时间，肯定能学会，而且要在用中去学，这样可以极大的提高效率，因为它本身就是工具，多用才能熟能生巧。 2、编程入门学习最困难的就是对编程语言的基本概念的理解，还有理清这些基本概念之间的逻辑关系，而逻辑关系恰恰是自己的弱中之弱，这14天里能感受到自己回避困难的心态，这和自己在真实生活中遇到的很多情况都类似，刻意的回避最难的，通过训练营发现自己习惯性的弱点很重要，今后刻意练习的重点就是基本概念，以及概念之间的逻辑关系，告诉自己别回避，一天理解一点点，把时间当做朋友。 3、我理解的训练营的目的就是带着我们认识一遍python语言的学习地图，训练营的结营是自学编程的开始，以后自学python的过程中，遇到哪里不理解，就要靠自己去查找地图搞清楚了，加油吧！ 王媛 写于2019年4月3日 以下为14天学习的具体细节：day1：训练营第一天有种要崩溃的感觉，已经折腾快5个小时了，回想一步步的操作，还是把编程当成了洪水猛兽，大脑没有聚焦在完成任务，而是紧张的盯着参考资料，操作出现任何的不一样就慌的不行，自我感觉很多的能量用在了抵御害怕上。中间会厌烦，有时还会忘记google。耗费时间特别多的地方，在本地建立local.txt文档，直接存于本地库就自动变成.rtf格式，后来是用control+c、control+v解决了这个问题。 day2：配置本地运行开发环境 学习用时：3小时 收获总结： 1、任务1下载安装Anaconda无困难。 2、任务2在vscode中配置Python环境，阅读参考资料近1小时，感觉混乱，自己添加了几个python扩展。 3、任务3学习中不知道“打开mac终端”是啥意思，后学会三种打开终端的方法，通过Finder、Launchpad和右上角搜索框输入terminal达成。 遇到的难点与问题： 阅读参考资料时“过早引用”太多，经常就忘记了任务是啥，要练习以任务为导向的思维方式，避免陷入细节中。 day3: HelloPython 学习用时：2小时 收获总结： 从网上选择了两个简单的计算器代码，先敲代码，熟悉概念，执行过程中出错才会引发自己去思考错误在哪里。第一个简单的程序运行顺利，也大致理解了每句语言的意思。第二个相对复杂的代码出现了几十个错误，首先是print语句没有（），另外知道#后是注释，所以前两行没有敲在自己的程序中，结果导致程序里的中文无法运行，后来将这两行敲出 #!/usr/bin/python #– coding:UTF-8 – #set chinese code 终端中可以正常输出中文，但还是无法运行，有一个变量没有定义，暂时自己还不会解决，再研究参考资料，争取把这个程序跑出来。 经过教练的指导，将两处raw_input更改为input后，跑出了程序，很开心。 day4:控制流程 学习用时：2小时 收获总结： 1、通过编写程序运行九九乘法表，理解机器语言。 2、通读参考资料后，快速google现成的程序，从照着现成的程序敲出代码努力理解代码涵义做起，能成功跑出程序就鼓励自己，做到尽可能完成任务不焦虑。 3、理解同一项任务可以有多种解决方案，九九乘法表可以用for…in循环呈现，也可以用while循环呈现。 4、任务2在google搜不到现成代码，参考了同学的作业，将i+=1修改成i+=2成功实现，感觉到编程的神奇，也觉得同学解题非常智慧，不过这个答案没有体现任务中的在while循环中设置条件判断，继续努力寻找答题思路。 5、在while循环中加入if语句设置条件限制，实现了目标，不过偶数行显示的是空行，并没有被删除掉，不知算不算成功。 day5:数据容器 学习用时：5小时 收获总结： 大部分时间都在理解笑来老师书中给出的实例的代码涵义，感觉能看懂，但做任务却毫无思路，说明对于这些调用的函数，对其内部流程并没有真正掌握，后来为了完成任务，参考了其他同学的答案，照着敲函数由得出的结果去反着理解输入，理解编程语言的结构，今天做任务已经感觉很吃力。 day6:函数 学习用时：4小时 收获总结： 因为这些内容已经远超出了自己的理解范围，所以我选择先参考同学的作业，查看了很多同学提交的作业，能够读出各种解题思路的不同，有些答案看起来很费解，有些答案则条理很分明，选择了条理分明的答案，拷贝到自己的作业中，运行顺畅，然后自己按照代码重新敲一遍，加深理解，敲完代码后怎么都运行不出来，后来请教了教练，原来自己一个正则表达式少了个右方括号，自己还不太会读TERMINAL提示，教练告诉我要自己学会看提示，嗯嗯，一个小小的疏忽困了我好久，更糟糕的是我真的反反复复对照代码对了很多遍，就是没看出来，加上右括号后，代码成功运行。我觉得在自己毫无思路，或完全写不出的时候，照抄优秀代码也是很好的练习，从自己敲击的程序中，看到程序运行得出的结果，对于自己理解代码的含义很有帮助。 day7：模块 学习用时：4小时 收获总结： 理解每天的任务都是在前一天的基础上实现更大的功能，昨天通过函数实现了对文档英文单词词频的统计，对中文汉字字频的统计，今天在昨天已实现统计词频功能的py文档中，再定义一个函数，可以实现分别调用英文词频统计、中文字频统计，并合并输出的功能，生成模块main()。利用模块功能，通过导入模块，也就是自己编写好的统计词频、字频的函数，对其它参数进行程序运行。 day8:异常处理 学习用时：3小时 收获总结： 理解用try语句来对程序异常进行处理。各种试错，不明白为什么。对于函数的参数，运行流程还是不明白原理。先完成，在慢慢看书总结的过程中再努力去理解。 day9:标准库 学习用时：4小时 收获总结： 学习标准库中counter函数的使用，用来统计中英文词频，并学习读取.json文件，并统计其中的词频。被卡在找不到json文件处好久，后来将整个文件路径都写入程序，跑出了结果。 day10:第三方库 学习用时：3小时 收获总结： 学会在terminal下安装第三方库，每天的内容都是在前一天的基础上扩展，参考优秀学员代码，反复试错的情况下总能跑出结果，但还是不明白内部逻辑，继续读书理清底层概念。 day11:实战演练1 学习用时：3小时 收获总结： 今天卡在了模块调用路径上，总是显示import error，还不会解决。 day12:实战演练2 学习用时：4小时 收获总结： 利用wxpy模块，在微信上实现监听好友消息，并对分享类型的消息自动获取网页链接，用分词处理模块将处理结果返回给发信人。原来这就是一个可使用的服务，编程很神奇。 day13:实战演练3 学习用时：4小时 收获总结： 结合之前所学，将网络抓取数据进行词频分析，然后生成图表，参考同学作业，不采用之前的模块，一步步列出流程，可以生成图表，但是中文字体问题折腾很久也没解决。我调用昨天完成的函数，加入生成图表流程，程序没有报错，但不生成图表，没搞明白问题出在哪里。 day14:总结拓展 复盘生成前文学习感悟和心得，用时2小时。]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-自学数据营-作业1思考记录001]]></title>
    <url>%2F%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5%2F1901030012-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E4%BD%9C%E4%B8%9A1%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95001%2F</url>
    <content type="text"><![CDATA[学员信息 学号: 1901030012 学习内容: 数据营学员手册+Markdown说明 学习用时: 183mins Notes no.: 001 学习笔记 我的问题重新看了JupterLab里的code，raw，markdown显示，突然感觉自己就是没有勇气面对和解决自己的问题：遵从规范。 我，骨子里，对于规范的理解存在被别人输入的偏见。而行为中实际是遵从原则和规范的。因为这样才效率，而有违自我价值观的那个部分，实质上就是宕机的主要诱因，很可能，很可能就是“我的”价值观出现了问题啊，小傻蛋。（哈哈哈哈哈摸摸脑袋。patpat，therethere） 我的解决办法尝试001我的问题：不知道什么是规范，由于偏见直接内植virus干扰自己对于去读规范以及不熟悉而看不懂规范的时候跳闪谎言：懂这个干嘛。well，解决这个问题： 1234567891011Import 许岑 as MarcusImport @realcaiying as MaestroImport @糖总总 as 糖糖# 那么还是Maestro给我的必杀技啊，#fixme#这个部分的规则和规范是什么，我能知道多少，在哪儿能补充完整，先记录，不要想着一出手就成。 Marcus*大器免成*.SELFLEARNING(something)# 我舅说的分清主次，完全可以使用Marcus还有Maestro的methods来训练解决。来，请伸出猫爪子，开始吧。囫囵吞枣的先。 拆解分析尝试001 1 我们的目的好像是：去读，去实践规范，并最终能理解规范的内涵外延与历史背景。 3.2 主要问题是要实现action1;action1 = 去读与去实践、使用 而干扰action1的是behavior1; behavior1 = 认为要搞不清楚规范的内涵外延与历史背景就不能行动了？ 但是，实际上behavior1是次要矛盾，因为即便是以要理解为目的，action1也是必要的，而且是需要足够量的action1的积累才可能最终带来目的实现的，这里面隐藏的一个变量叫做workable_time，这里还隐藏着另外一个action2 == reflection1，这里还隐藏了一个函数叫recursion1（我还没有想明白），这里面隐藏的一个theory叫做: 12[(action1*workable_time) * (action2*workable_time) ] ** (recursion1*workable_time) == [(action1*workable_time) * (reflection1*workable_time)]**(recursion1*workable_time) 3.3 根据上述分析，不懂的部分目前看是正常的啊，是需要有效时间投入到不断熟悉的过程的。那么过程才是主吧，所以，每天要完成action1 + action2. 同时不放弃思考自己不明白的那些部分。#fixme# why insert _ between names characters inside the variable names causing effects unexpected, how to solve it?check the guides later to fix it. 3.4 观察自己的actions，我不敢乱点东西，每一个步骤我都要问好几遍自己，而且最终我还是需要找别人帮我确认。但是，如果使用上面的分析，实际上只要持续进行action1 + action2，自我采用什么方式都可以啊。Maestro和糖糖还有Marcus都提到的 “玩” 。他们的玩的定义是什么，我感觉很重要。因为，这个定义或者是个函数，可能就是我的核心问题的一部分解。 我不敢点，因为我不知道我现在是可以玩的，玩，是需要被许可的么？ 这个问题对我而言这么重要是因为，我突然间似乎能够体会，他们说这个词是很认真地，褒义地使用的，而且，我还是觉得我不会玩这个是个很重要的问题，所以，通过行动来玩，搞清楚玩的定义对我而言很重要，这个是 I want 。 玩，自始应该是源自我自己想要干什么吧，我的问题是，我想要，这个是什么？(how pathetic I was…how lucky I have been…Cat you can do it, let us keep moving on!!!) 想起来MIT Professor Ana Bell的话-lecture1, 核心是：别怕哈，玩不坏，大不了关机重启嘛。 And I think, also, one of the big things is if you’re new to programming, you’re kind of afraid that you’re going to break your computer. And you can’t really do that just by running Anaconda and typing in some commands.So don’t be afraid to just type some stuff in and see what it does. Worst case, you just restart the computer. Yeah. That’s probably the big thing right there.I should have probably highlighted it, but don’t be afraid. 综上，实际上，我们的目标是 行动 。action1 + action2 玩 起吧。]]></content>
      <categories>
        <category>自学数据营</category>
      </categories>
      <tags>
        <tag>数据营</tag>
        <tag>思考</tag>
        <tag>点滴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE5]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 5（17分钟）+Python编程导论（第2版）（第5章至5.2） 学习用时: 2小时 学习笔记收获总结： 元组(tuples):与字符串一样，是一些元素的不可变有序序列。元组是字符串的扩展，区别是元组的单个元素可以是任意类型，包括元组。 元组类型的字面量形式是位于小括号之中的由都好隔开的一组元素。 单一元素的元组应在元素后加逗号，表示是由单一元素构成的元组。 元组和字符串一样，可以进行连接、索引和切片等操作。 列表(lists):列表也是值的有序序列，每个值都可以由索引进行标识。空列表用[]表示，单元素列表不需要额外加逗号。 中括号可以用于表示list类型字面量、列表索引和列表切片。 列表和元组一样，都可以使用for语句遍历其中的元素。 列表是可变的，除了count和index，下述方法都能改变列表。 L.append(e):将对象e追加到L的末尾。 L.count(e):返回e在L中出现的次数。 L.insert(i,e):将对象e插入L中索引值为i的位置。 L.extend(L1):将L1中的项目追加到L末尾。 L.remove(e):从L中删除第一个出现的e。 L.index(e):返回e第一次出现在L中时的索引值。如果e不在L中，抛出异常。 L.pop(i):删除并返回L中索引值为i的项目。如果L为空，抛出异常。i被省略，默认为-1 L.sort():升序排列L中的元素。 L.reverse():翻转L中的元素顺序。 遇到的问题和解决方法：对列表的可变性理解不透彻。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-MIT-自学 lecture8]]></title>
    <url>%2FMIT60001%2F1901030012-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-lecture8notes38%2F</url>
    <content type="text"><![CDATA[学员信息 学号: 1901030012 学习内容: MIT第8课视频文稿p9-10 slide p12-16 学习用时: 66min Notes no.: Day38 学习笔记 conventionSo by convention, it’s a lot easier to do the one on the left.And as I mentioned, Python implicitly says, if you’re doing the one on the left, you can call this method on a particular object and it’s going to look up the type of the object and it’s going to essentially convert this on the left to the one on the right.def distance(self, other): code here Using the class: - [ ] conventional way - [ ] equivalent to c = Coordinate(3,4) c = Coordinate(3,4) zero = Coordinate(0,0) zero = Coordinate(0,0) print(c.distance(zero)) print(Coordinate.distance(c, zero) object to call method on c, name of method is distance and parameters not including self (self is implied to be c). informative debugging tool–str methodSo if you create a coordinate object, C is equal to coordinate 3, 4, right? That’s what we’ve done so far. If you print C, you get this funny message.Very uninformative, right? It basically says, well, C is an object of type coordinate at this memory location in the computer. Which is not what you wanted at all, right? Maybe you wanted to know what the values for x and y were. That would be a lot more informative. So by default, when you create your own type, when you print the object of that type, Python tells you this sort of information which is not what you want. So what you need to do is you need to define your own method that tells Python what to do when you call print on an object of this type. c = Coordinate(3,4)print(c)&lt;main.Coordinateobject at 0x7fa918510488&gt; define a str method for a class. Python calls the str method when used with print on your class object. you choose what it does! Say that when we print a Coordinate object, want to show: print(c)&lt;3,4&gt; 12345678910class Coordinate(object): def __init__(self, x, y): self.x = x self.y = y def distance(self, other): x_diff_sq = (self.x - other.x) ** 2 y_diff_sq = (self.y - other.y) ** 2 return (x_diff_sq + y_diff_sq) ** 0.5 def __str__(self): return &quot;&lt;&quot; + str(self.x) + &quot;,&quot; + str(self.y) + &quot;&gt;&quot; 我来实验一下啊，我怎么不能换行（据说是要空两个空格啊）呢？还有就是最最最简单的图表怎么就是搞不定呢？(不是搞不定，是眼睛无比的粗心大意，，，使劲盯着看，，，我舅说的没错，规范啊规范很重要，那就盯着盯着的不就找出来不同了)。然而，这个列表的点点是怎么输入进去的呢？！让我再纠结一会儿吧。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE4]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 4+Python编程导论（第2版）（第4章4.1） 学习用时: 4小时 学习笔记收获总结： 分解（decomposition）实现了程序结构化。它允许我们将程序分成多个逻辑上独立的部分，并可以通过各种设定实现重用。 抽象（abstraction）隐藏了细节。它允许我们将一段代码当作黑箱使用。所谓黑箱，是指那些我们不能看见、不需看见甚至根本不想看见内部细节的东西。 抽象的精髓在于，在具体背景之下，保留那些该保留的，忽略那些该忽略的。抽象归根结底就是忽略。 在编程中有效使用抽象的关键在于，找到一个对于抽象创建者和抽象潜在使用者都很合适的相关性表示。这才是真正的程序设计艺术。 achieve decomposition with functions or classes. achieve abstraction with function specifications or docstrings. function characteristics: has a name has parameters(0 or more) has a docstring(optional but recommended) has a body returns something 三引号之间的文本在Python中称为文档字符串。按照惯例，Python程序员使用文档字符串提供函数的规范。可以使用内置函数help访问这些字符串。 函数的规范(specifications)定义了函数编写者与客户之间的约定，约定包括：假设是客户使用函数时必须满足的前提条件；保证是函数应当实现的功能。 编写测试代码是一件一本万利的事情。 formal parameters绑定到actual parameters有两种方式，位置参数和关键字参数。关键字参数不可以放在非关键字参数。 作用域(scope):每一个函数都定义了一个命名空间，称为作用域。 每次调用函数形成一个栈帧，函数结束时它的栈帧随之消失。 遇到的问题和解决方法：注意对作用域的理解。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020029-MIT60001-Day1-10]]></title>
    <url>%2FMIT60001%2F1901020029-MIT60001-Day1-10%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020029 学习内容：MIT6.0001课程 1-10天打卡 学习用时：20小时 学习笔记第一天：20190624学习时间：3小时学习内容：MIT Lecture 1学习收获：1、从上周开始学习MIT课程，Lecture1听了3遍，第一遍跟英文字幕，发现无法理解课程，后两遍跟中文字幕，尽可能理解课程讲解的内容。2、陈述性知识：陈述事实。程序性知识：即配方，如何做。3、什么是一个配方？包含简单的步骤、每一步被执行时的控制流、以及用什么方式停止程序。4、计算器是固定程序的计算机，只会计算；电脑则是储存程序的计算机，可以进行机器存储和执行指令。5、理解计算机的基本体系架构。6、编程语言与英语语言类比：数字、字符串、简单的运算符就像英语里的单词，是编程语言的原始构件；原始构件的组合要符合语法结构，数字和字符串组合在一起会导致语法无效；编程语言只能有唯一的含义。7、复习数据、对象（标量对象、非标量对象）类型、类型转换、打印命令、表达式、数值运算、=（赋值）的含义、变量这些基本概念。遇到的难点：1、英语仍是拦路虎，畏难心理有点严重。课程用中文字幕听完后，打开PPT来仔细阅读，还是有许多看不懂的地方。2、psets 是 problem sets 的缩写吗？是问题集合的意思吗？3、练习题1、2做完，第一次使用Spyder，练习题3的视频在打开时没注意，点成用默认的QuickTime player播放，对文件进行了转码，然后就遭遇意外无法打开。我尝试重新在钉钉上下载lecture文件，重新解压，依然无法解决此问题。 第二天：20190625学习时间：2小时学习内容：MIT Lecture 2学习收获：1、快速过一遍Lecture1pdf，读不懂的英文努力理解一下。2、字符串对象类型包括字母、特殊字符、空格、数字；需要封装在双引号或单引号中；用+来连接，其中的空格必须用“ ”来实现；用 * num 来实现字符串的num次重复。3、用print( )实现在控制台的输出，括号内的输出内容字符串需有引号，用+拼接的内容之间无空格，用，连接的内容之间显示空格。4、用input(“ ”)进行人机交互，提示用户按引号内的内容输入并回车，将用户输入绑定到一个变量；默认用户输入为字符串类型，如果需要数字类型，需要转换。5、对象类型之间可以用比较运算符连接成表达式，最后评估为布尔值，真或假。6、控制流实现程序的分支。用if…、if…else…、if…elif…else…来实现。7、for循环：知道迭代数量；能用break结束；使用一个计数器；用while循环可以重写一个for循环。8、while循环：可无限数量的迭代；能用break结束；可以使用一个计数器但是必须在循环之前初始化计数器并在循环内部递增它；用for循环可能不能重写一个while循环。疑问：昨天想问，但忘记问了，这个课程的名称里6.0001的含义是什么？ 第三天：20190626学习时间：2小时学习内容：MIT Lecture 3前半部分学习收获：1、逐渐理顺学习节奏，先用中文跟视频尽量理解，再仔细阅读pdf，消灭生词。2、对字符串数据类型的处理：把其当作大小写敏感的字符序列；可以用运算符==、&gt;、&lt;等进行比较；可以用len( )函数检索字符串的长度；可以用[ ]索引到字符串内指定的位置；字符串不可以被修改。3、其中关于字符串切割的例子 s [4：1：-2 ]，开始怎么也绕不明白，后来去查阅The Python Tutorial的讲解，终于明白了。4、做随堂练习是检验自己到底懂没懂的最好方法，今天去公开课网站做前两个Lecture的IN-CLASS questions，发现虽然代码都尝试运行过，但是题还是会答错，说明原理并没有理解透彻。5、践行“不耻下问”的结果很赞，前天关于psets的疑惑，问之前各种担心会不会太小白，会不会被笑话，结果得到了热心同学的解答，确定是问题集合后，也在想这个psets在哪里？今天在公开课网站上找到了ASSIGNMENTS里的psets，接下来要多多练习了。6、这几天多看、多读、多想的结果就是真的不那么怕英语啦，能明显感觉到自己通过英语能理解的东西越来越多了。7、小伙伴们一起来打卡啊，加油！ 第四天：20190627学习时间：2小时学习内容：MIT Lecture 3后半部分学习收获：1、学习三种不同的算法，理解计算机如何帮助我们解决具体的问题。三种算法为猜测和检查、近似算法、以及二分搜索法。2、近似算法是为了寻求一个足够好的答案，在求解立方根的例子中，给定一个epsilon变量，给定一个增量值increment变量，如果增量值过小会导致程序很慢但结果的准确度很高，如果增加epsilon范围，则会降低结果的准确度，但能更快得到答案。3、二分搜索法老师以0-100之间的猜数游戏为例，讲解这样的求解方法可以快速降低搜索范围，以对数的形式降低猜测次数，不同于遍历每一个数据进行猜测的线性的猜测检查法和近似解决法，强大的二分法能更快速的获取答案。4、几个用于理解不同算法的代码案例，反反复复看了很多遍，也运行了所有的代码，换不同的数据体验结果有何不同，感觉每看一遍都有不同的理解。 第五天：20190628学习时间：2小时学习内容：MIT Lecture 4前半部分学习收获：1、重点内容：结构化程序及隐藏的细节；函数；说明书；关键词return vs print；范围。2、先用投影仪的例子来帮助我们理解编程中分解decomposition和抽象abstraction的概念。3、超大型舞台需要很多台投影仪协同工作，每台投影仪的内部处理完全相同，但给每台投影仪输入不同的内容，最后不同的投影结果组合出完美的舞台成像。4、好程序不是指更长的代码，而是能提供更多的功能。实现机制就是分解和抽象。5、在编程中用分解创造结构。代码被分解成模块modules，模块是独立的、用于分解代码、计划重复使用、有组织的、连贯一致的。函数functions和类classes可以实现分解。6、在编程中用抽象来隐藏细节。把一块代码理解为黑盒，不用管其内部细节，会看函数说明书或字符串文档，知道怎么用这块代码实现想要的功能就可以了。7、可反复使用的代码块叫函数，函数在程序中不运行，除非函数被调用。8、函数的特征：有名字、有参数（0或更多）、有说明文档（可选项但推荐有）、有主体、返回某物。 第六天：20190629学习时间：1小时学习内容：MIT Lecture 4后半部分学习收获：1、理解变量作用域，嵌套的变量作用域例子有点绕不清。2、当函数被调用时，形参被绑定到实参的值。3、当进入一个函数，新作用域/框架/环境创造出来。4、作用域是对象名称的映射。5、程序先列出全局变量，函数的值是一些代码，然后是各个变量的值，当变量在调用函数时，就进入被调用函数的局部变量作用域，程序开始列出函数内部的变量，直到函数的返回值，这个函数的返回值回到主程序的函数变量里。6、没有return陈述的一个警告：如果函数没有return陈述，python返回值None。 第七天：20190630学习时间：30min学习内容：MIT Lecture 5前半部分学习收获：1、理解两个新的数据类型：元组 ( ) 和列表 [ ]。2、元组一旦创建其值不可更改；列表的值是可变的。3、元组和列表的元素可以像字符串一样进行索引、定位、切割等。4、列表的值可改变这一点使列表对象非常有用。5、添加列表元素用L.append（element）6、只是听课（跟中文字幕）来理解课程有点困难，周末时间严重不够用。7、感觉前几课的内容因为训练营突击学习过，大概了解最基础概念，听课程加看pdf能比较好理解，今天的感觉到吃力，后续学习是应该继续跟课程，先听一遍下来，还是巩固复习前面的内容，花时间做练习，彻底搞懂再继续？感觉自己又犯了究细节的毛病，而忘记了全面和完整，听不懂也应该先听一遍不是吗？但是最大的难点在于不懂如何写收获。 第八天：20190701学习时间：3小时学习内容：MIT Lecture 5视频前30min + PPT（p1-p16）学习收获：1、重新复习元组、列表这两个复合数据类型。昨晚只是跟字幕听视频感觉头脑很混乱，今天放慢速度，边听边看pdf，做到理解内容。2、元组：有序的元素序列，可以混合不同的元素类型；不能改变元素的值，同字符串一样，一旦创建是不可变的；用( )代表元组。3、注意：元组 t = (2,“mit”,3）经t [1:2]切割后值为(“mit”, ）这里额外的逗号意味着它是一个元素的元组，而不是字符串。4、元组用于替换两个变量的值非常方便，(x,y)=(y,x)一行代码即可实现。否则想替换变量x、y的值，必须设置一个临时变量才能实现。5、利用元组可以实现从函数中返回多个值。6、元组中嵌套元组元素，进行遍历元组数据，对处理真实世界的数据非常有用。这点需要运行代码实例才比较好理解元组实现的功能。7、列表是有序的信息序列，可索引；用[ ]表示；通常包含同类元素，也可以包含混合的元素；列表是可改变的。8、像字符串一样，可以用更pythonic的语言来遍历列表，计算列表元素的总和。for i in L：9、有关列表的操作：用L.append(element)实现在列表L后添加element；用+实现两个列表的组合；用L.extend(some_list)实现在列表后扩展一些清单；用del(L[index])删除索引位置的元素；用L.pop( )实现返回列表的最末尾元素，并将L改变为去除最末尾元素的新列表；用L.remove(element)实现查找第一个出现的element，并去除它，如果元素不存在，则报错。10、列表与字符串之间的互转：用list(s)实现将字符串s的每个字符转变为列表元素；用s.split( )实现在字符串中某个字符处将其分解为两个元素的列表；用‘ ’.join(L)实现将列表L转变为字符串;用’’.join(L)实现在转变为字符串的字符之间添加用sorted(L)实现对列表L的排序，列表L没有改变；用L.sort( )实现对列表L的排序，列表L改变；用L.reverse( )实现对列表L的反转，列表L改变。心得：1、心静下来，理解力明显上升。2、视频中的代码示例一定要亲自运行，并修改数据来试验结果，有助于提高对代码的理解。3、遇到中文字幕拗口不好理解时，配合pdf来理解效果更佳。 第九天：20190702学习时间：2小时学习内容：MIT Lecture 5后10min + PPT(p16-24)学习收获：1、列表对象具有可变性，不同于字符串、元组等不可变对象。2、变量名仅是贴在对象上的标签，对象变了，指向对象的标签都受影响。3、用列表对象进行具体操作时会产生某些副作用。4、理解别名现象，比如warm和hot指向同一个列表对象，使用append()函数改变hot变量时，warm变量也改变了。5、针对列表可变性，克隆列表是很有用的方法。用[:]实现，比如hot= warm[:]，这样改变hot时，warm仍是原来的列表对象。6、对列表排序调用sort()函数改变列表，返回None；调用sorted()函数不改变列表，但必须分配值给变量。7、列表嵌套列表，在实际工作中要时刻注意副作用的问题。8、做exercise。 第十天：20190703学习时间：2小时学习内容：MIT Lecture 6（主题：递归，字典）前10min + PPT(p1-p13)学习收获：1、老师换成了Eric Grimson，一下有点不适应。2、理解递归RECURSION，是把规模大的问题转化为规模小的相似的子问题来解决。在函数中，就产生了函数调用它自身的情况。此外，这个解决问题的函数必须有结束条件，否则会产生无限递归。3、之前已经学了循环结构(for、while)来迭代算法，按照一套状态变量在每次迭代循环时更新来捕获计算。4、举例：展示乘法a*b和计算阶乘n！分别用迭代求解方案和递归求解方案是如何一步步实现的，学习递归的解题思维。5、时间主要花在网上阅读有关递归的文章，帮助理解递归的思想。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE3-2]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 3+Python编程导论（第2版）（第3章） 学习用时: 4小时 学习笔记收获总结： 近似解位于实际解附近的一个常数范围内，这个常数我们成为epsilon。 穷举法程序会运行多长时间？迭代的次数依赖于答案与0的距离以及步长，大致来说程序会执行while循环最多x/step次。step设定太小，程序运行时间过长，设定太大，会略过适合的答案。 二分查找是每一步都将查找空间分为两部分，二分查找是对穷举算法的一个重大改进，穷举算法只能在每次迭代后将查找空间缩小一部分。 用==比较两个浮点数会产生不可思议的结果，更好的做法是看看两个浮点数是否足够接近，而不是比较两个浮点数是否相等。e.g. abs(x-y) &lt;0.0001比x==y更好。 最常用的近似算法是牛顿-拉弗森法，如果存在一个值guess是多项式p的根的近似值，那么guess-p(guess)/p’(guess)就是一个更好的近似值，p’是p的一次导数。 仔细体悟穷举算法、二分查找法、牛顿法求立方根的思路。 遇到的问题和解决方法：尚未编写程序比较三种算法的效率。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050107-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050107-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：党聪学号：1901050107 工作背景培训讲师 自我介绍15年大学毕业后做过一段时间的程序员，但是由于没有找到突破的路径和状态所以放弃了，后来辗转各个行业探索，尝试，但是发现真正想变得厉害就得像笑来老师这样，需要什么就去学，不问喜不喜欢，只问学没学会。 目前已经学完了入门训练营，MIT 13节课，在此阶段，我找到了钻研的感觉，找到了输入，实战，输出的流畅的感觉，这是我之前从未有过的。臆测一下：任何学习必须是链式反应，就是上一个阶段的学习必须是下一个阶段学习的原动力，而非阻力。 学习目的一：转行回到互联网行业，回到最容易做出成绩的赛道 在这一阶段学习结束后，我会找一份数据分析师的工作。因为我发现个人的价值首先是由社会的需求决定的，其次才是自己的努力程度。我原本以为只有新兴行业才会用到数据分析，但是经过这几个月的观察发现几乎各行各业都会用到。 二: 学以致用，围绕技能构建系统认知 向笑来老师学习，就编程一项技能做出了这么多产品，这些产品共同组成了一个能够自己生长的系统， 我原来做程序员的时候很傻很单纯，既没有社交，又不会主动把技能用到其他的地方，所以是一种消耗似的工作。但是现在，我尝到了甜头，一方面Python能做很多事，简直不要太好玩。另一方面，很多朋友听说我学习Python都想让我做点儿东西。虽然大部分需求我还满足不了，但是我相信我很快就能跟进。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>培训讲师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020029-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020029-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王媛学号：1901020029 工作背景从事生物制品质检、质量管理及一线销售工作共计16年。 自我介绍我叫王媛，一直在医药行业工作，如今作为一个4岁男孩的妈妈，我希望自己能真正学成一门手艺，用自己不断自学成长的经历来做孩子的榜样！ 学点编程，我相信学了总比不学强！]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>孩子母亲</tag>
        <tag>医药行业</tag>
        <tag>质量管理</tag>
        <tag>一线销售</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet3(P2)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet3(P2)%20%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 3 (ZIP) 打卡天数：D09 作业(Problem 2: Dealing with hands):Removing letters from a hand (you implement this!) The player starts with a full hand of n letters. As the player spells out words, letters from the set are used up. For example, the player could start with the following hand: a, q, l, m, u, i, l The player could choose to play the word quail. This would leave the following letters in the player’s hand: l, m. You will now write a function that takes a hand and a word as inputs, uses letters from that hand to spell the word, and returns a new hand containing only the remaining letters. Your function should not modify the input hand. For example: 12345678910&gt;&gt; hand = &#123;'a':1, 'q':1, 'l':2, 'm':1, 'u':1, 'i':1&#125;&gt;&gt; display_hand(hand) a q l l m u i&gt;&gt; new_hand = update_hand(hand, 'quail')&gt;&gt; new_hand &#123;'l': 1, 'm': 1&#125;&gt;&gt; display_hand(new_hand)l m&gt;&gt; display_hand(hand) a q l l m u i 作业心得作业要求，实现update_hand函数，根据作业中的提示，可以通过 copy 函数来实现次函数的功能。 学习的新函数： Python dict.copy 函数: 复制dict，修改新的dict不会影响原来的数据; ceil() Python del 函数: 删除 dict 中对应key的项 程序代码1234567891011121314151617181920212223242526272829303132## Problem #2: Update a hand by removing letters#def update_hand(hand, word): """ Does NOT assume that hand contains every letter in word at least as many times as the letter appears in word. Letters in word that don't appear in hand should be ignored. Letters that appear in word more times than in hand should never result in a negative count; instead, set the count in the returned hand to 0 (or remove the letter from the dictionary, depending on how your code is structured). Updates the hand: uses up the letters in the given word and returns the new hand, without those letters in it. Has no side effects: does not modify hand. word: string hand: dictionary (string -&gt; int) returns: dictionary (string -&gt; int) """ new_hand = hand.copy() word = word.lower() for letter in word: v = new_hand.get(letter) if v is not None: if v == 1: del new_hand[letter] else: new_hand[letter] -= 1 return new_hand]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE3]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 3(22minutes) 学习用时: 1.5小时 学习笔记收获总结： len()函数求出字符串的长度，包括字母、数字、特殊符号和空格等等，尤其要注意空格。 s = “abc”index 012 indexing always starts at 0index -3-2-1 last elements always at index -1索引 slice: s[start:stop:step], s[::]等于s[0:len(s):1] ,s[::-1]等于s[-1:-(len(s)+1):-1] strings are immutable –can not be modified. 遇到的问题和解决方法：可支配时间太少，工作日会好转。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020029-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020029-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王媛学号：1901020029 工作背景从事生物制品质检、质保及一线销售工作共计16年。 自我介绍我叫王媛，目前暂时是一名全职妈妈，之前一直在医药行业工作，在成为母亲这件事上曾遭遇很大的考验，一晃10年，本以为此生将不能做妈妈，结果一个健康快乐的小精灵降生了，伴随着感慨和喜悦，如何做一个合格妈妈的思考便常伴左右。 在遭遇考验处于人生低谷的很多年里，笑来老师的文字一直鼓舞着我，学习不断成长这件事自己一直有默默在进行，但真正学成一门手艺，自己还完全是个门外汉。 这次笑来老师用编程当例子教大家学会自学这门手艺，正是我特别想学会的，也是我想通过自己切身学会的经历，总结自学经验，今后在宝贝的成长路上能给他以正确引导，和他一起并肩成长将是一件无比开心的事。 目前python入门营已毕业，MIT6.0001课程已自学一遍，正准备9月进入python进阶营学习数据分析。 我并不清晰自己的未来会是什么样子，但我知道在正确的地方努力总不会错。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>全职妈妈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090043-自学训练营学习9群-PYTHON入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901090043-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A09%E7%BE%A4-PYTHON%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901090043 学习内容：14天python入门营 学习用时：35小时 学习笔记 自学往事如果人一生中最应该掌握的技能就是自学能力，多年来对学习有相当的信仰，只是李笑来老师把自学能力当做一种能力，并且掌握和变现了这种能力，令人震惊！在对一件事情上执着，并努力做到世界水平，这是每个人都应该学习的勇气。之前学过cSharp，Java，ps，微软办公软件，写作，阅读……由于没有系统方法论，以及对这种方法的研究意识，错过了多少美好时光，人说掌握一个技能，就拥有了另一个新世界，回想下，失去了多少个本可以拥有的世界啊。”种棵树的最好时间是十年前，其次就是现在。” 自学心得从小家里就反对我成群结伴，老家的话叫“上伴”，看到你跟几个伙伴一起聊天开心玩耍，就会说：“不要上伴啊！”我父亲有时还会当场发飙，导致我从小面对父亲就害怕，到现在而立之年有时都害怕……小时候当然不以为然，从小受到”寓教于乐“的毒，总是从心里这样说服自己，现在想来，不要上伴和现在的无效社交一样，还真是充满智慧。在我的字典里，耐心和急于求成是相对的，年轻时候每个人都胸怀大志，都要成为人上人，从几万年前的智人开始一直是这样，这是天性！这种天性导致什么呢？就是攀比啊，想立刻成为闪耀的明星啊，于是就急于求成啊，一旦不能如愿，便不开心了，受打击了，我相信99%的人都是这么个过程，实在不行就放弃了。没想通这个道理的，到死都是一事无成的！现在读书，动不动一天一本书，想想之前上学的时候吧，半年才读一本书，大部分还学不好，李笑来老师有句话：慢就是快，快就是无。没学好的症结在这里，不够慢！耐心的深入理解一个概念，一个公式，内化成自己大脑的一部分。所以说耐心是一种态度和心法，学习每个知识之前，在心理建设上，说服自己要耐心！慢慢建立自己的金字塔，这会是一个复利效应，相信我，你会学的越来越快！ 学习步骤 模仿–成果–熟练–内化为自己的大脑结构一切学习都是从模仿开始的，不模仿你怎么开始呢？你连提问都不知道怎么提，是吧？许岑在他的《如何培养你的研究能力》课程说过，要建立作品意识，这是什么意思呢？作品就是你学习的效果，也是学习反馈的一部分。举个例子：学习python编程，作品就是你写的一个一个的程序，写一个总结一下写程序的心得体会，完成一个作品，成就感从何而来，从你的作品而来。学习效果怎么得到反馈，从作品和目标作品的对比而来呀。没对比就没有前进的目标啊，从对比中反复修正自己的作品，这个就是反馈，不是什么神秘的东西！我们学习的目标是什么，是学以致用嘛，把知识内化为技能，熟练是指标，反复练习是桥梁！学会了也就会了，会伴随终身的，想想骑单车，游泳吧，这两个技能你一辈子也忘不了。 学习的每一步需要反复打磨，慢就是快，快就是无知识要成为自己的一部分，要从身体上长出这么个东西，是多么困难！想到这里也没什么害怕的，不就是和时间做朋友，反复思考，反复练习嘛！这是成长的唯一路径，或者自学的唯一路径，至于说效率，你会想这么做多慢啊！是慢，前期慢，越过一个瓶颈期会越来越快，重要的是坚持！再推荐李笑来老师的一篇文章《为什么同样都是爱读书你却总是没进步？》 学会提问从一无所知到渐入佳境，到走上”巅峰“，有篇文章写得好，跨越鸿沟，你需要的只是提问！看到这篇文章之后，心里开心了一下，看见3岁小孩哭闹淘气再也不心烦了，心想，你就淘气去吧，等你稍大点，我给你传授万金油心法，可以让你跨阶层，跨学科，立于不败之地……想起自己读书的时候，有问题再怎么思考就是不问，那时想要的是锻炼自己的思维能力，以为锻炼好了能解决一切问题，现在想来佩服那时的自己，世界果真是那样的话，世界大统一理论早就铸就出来了，万有引力、相对论全都靠边站了…… 总结不需要学会学习知识，完成作品需要进行总结，总结没有什么大用处，就是让思维更清楚，更有信心！这是心理建设的一部分！怎么说呢？学会知识和技能，一通学习完，头脑混乱，隐约是懂了的，真要说什么，那就没什么说的了，什么都没记住！你都不知道自己是会了还是不会，是真懂还是假懂？这时不要急躁，耐心做下总结。做过了肯定印象深刻，再总结下，思路就清晰了，而且心里有它了。感觉是真学会了的，感觉对头了，你就会更倾向去用它。 时间需要管理吗？学习也需要管理学习从来不是学习本身，学习是个系统工程，不是单一简单问题，头痛医头脚痛医脚这种思维太局限。学习得考虑各个方面的因素：学习环境，学习时间安排，情绪，反馈，记录，积极性，会提问题……和学习相关的比不相关的都多呢！如果人这辈子什么最重要，当然是学习，越厉害的人越会学习，学习需要学习的，但不只是学习学习，身体的管理，比如要多运动，情绪管理，乐观，心胸宽广，不要被无所谓的事情消耗自己的意志力。批判思维，怎么思考对错怎么看待有用没有用，每个知识对每个人的重要程度是不一样的，与三观不符的话，相信我，你很难坚持的，如果为此你过得很痛苦，那学习有什么意思呢？学习这件事是困难的，但不是痛苦的。人生中学习最重要，学习是生活的一本分，是活着的一部分，如果活的抑郁了，说明任督经脉没打通啊！ 学到内容 项目 知识点 总结 Github Github,Github Desktop Github是最好的陌生协作平台(分布式版本控制系统)，Desktop方便本地化修改编辑 Anaconda VSCode 环境配置，pip安装python3 VSCode是个方便强大的开发工具，里面扩展很多，界面友好 calculator计算器 python文本编辑，input(),strip() python语言简单，学会了两个方法，python对文本对齐要求很高 打印9*9乘法表 print(‘’,end=’ ‘),string.center() 知道print方法有个end参数，字符串打印居中center()方法 文本统计，字符串处理 字典，正则表达式，string.replace(‘’,’’,count),range(,),sorted(text,key=,reverse=),’’.join(array[]),bin(),oct(),hex() 正则表达式简单而强大 文本统计排序 path库abspath(),with……as……：，dict(dic,**dic1),import模块导入 path获得当前路径，文件的读取，字典的合并，和模块导入 异常处理 raise ValueError(),try: except ValueError as result 知道抛出异常，捕获异常 Counter().most_comment(count) collections.Counter库 counter()方法简单强大，优于sorted() 分词 jieba库，jieba.cut() jieba智能分词很好用 解析微信文章获得文本，发送邮件 pyquery.PyQuery response=requests.get(url,vertify=),PyQuery(response.text,ya=yagmail.SMTP(),ya.send()) 解析网络文章获得有意义的统计，很有用！ 通过微信好友发送的文章获得url，回复分析文本 wxpy库，Bot(cache_path=True),@bot.register(chats=[Friend],embed()) 监听微信好友或群消息，wxpy还有很多有趣功能待挖掘 通过微信好友发送的文章获得url，回复分析图表 nupy库,matplotlib.pyplot库 以图表图片的形式发给好友，思路：保存分析图片到本地，然后msg.reply_image(path)发送给好友]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100042-自学训练营学习13群-学习心得]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F1901100042-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A013%E7%BE%A4-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100042 学习内容：14天python入门营 学习用时：22小时 学习笔记1.从day7开始记录学习内容：调用模块学习过程：模块的详细代码主要是day6内容，day7需要做的就是把中英文统计合并起来。其中，为了限制误识别，英文统计在原来的基础上添加了一个判断条件==&gt;element.isascii( )。随后，直接调用就OK。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
        <tag>学习心得</tag>
        <tag>一个差生的自述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020043-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：金志坚学号：1901020043 工作背景医药行业，从事营销推广工作 自我介绍今年42岁，除了日常的管理工作所需，最想学好的就是英语和编程，一法通万法通，通过学习编程提高自己的自学能力，希望能保持终身学习的能力，也希望能给员工展示一切皆有可能，年龄不是问题。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>营销推广</tag>
        <tag>工程师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090059-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901090059-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Charles 工作背景担任7年左右的老师，期间学生总数约有过千人，基本反馈尚算正向。 离开学校后，基本微电子行业待着，也就目前贸易战的核心内容标的之一。期间做过设计、带过团队；担任过设计工程师、技术支持工程师、研发经理等职务。从业过的公司有芯片制造的、EDA工具开发的和设计公司。 自我介绍平时喜欢阅读，尤其喜欢心理学、金融学及企业经理管理方面的书籍。 喜欢行在旅途中的美好感觉。喜欢约两三亲友，闲聊。喜欢矗立窗前听雨。 喜欢每天的坐享，经过近1年半左右的持续坐享，深深体会到她给我身心带来的积极影响和变化。 人生美好，值得付出，值得努力! 希望突破一下自己，给自己一个挑战。学习数据分析可以让自己站在新人生高度。希望学完之后一方面可应用于解决工作中碰到的问题；另外一方面希望可以基于此进行行业或者企业分析、投资分析方面。在学校期间有一定的处理器结构、嵌入式编程的基本经验，也了解过关于数据库的一些基本概念，完成了14天自学Python入门营课程，目前正在阅读Python Tutorial及MIT 60001的课程学习。主要的学习困惑是如何具备实际应用项目的工程研发能力。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>工程师</tag>
        <tag>老师</tag>
        <tag>微电子行业</tag>
        <tag>研发经理</tag>
        <tag>喜欢阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100088-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100088-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：罗禹 工作背景医疗器械注册临床研究员，靠循证医学和撰写Meta分析与临床试验方案吃饭，日常检索数据、分析数据，解释评价数据来证明医疗器械的安全及有效性。 自我介绍接触python好几年了，但每次长期卡壳后就暂停学习了，间隔好久又重启。想在今年内彻底搞定编程及python的入门及运用。 程序的日常工作运用场景1.数据获取及爬虫：日常需要检索同类医疗器械信息、文献、不良事件及召回信息、监管数据。对于各国的监管数据，爬虫获取远比手工检索高效。2.数据分析：工作中需要做森林图和漏斗图，现阶段使用的数据分析软件是RevMan和SPSS，正在向SAS和Stata转换，涉及到程序。3.大数据：临床评价统计学方法学上一个发展方向是真实世界研究。工作中查询的关节登记数据库实质就是各个国家的确关节置换方向的大数据统计结果。4.数据库建立。5.医疗器械研发方向；6.人工智能：国家对创新类医疗器械优先审评，对人工智能医疗器械在不断推进。国药监对标准化公示了归口单位，也召开了人工智能创新推进会。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医疗器械</tag>
        <tag>注册</tag>
        <tag>临床评价</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020015-自学编程阶段性总结：终于找到“浸泡”式学习英语的机会，开启跨越自己的旅程]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901020015-%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BB%88%E4%BA%8E%E6%89%BE%E5%88%B0%E2%80%9C%E6%B5%B8%E6%B3%A1%E2%80%9D%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD%E7%9A%84%E6%9C%BA%E4%BC%9A%EF%BC%8C%E5%BC%80%E5%90%AF%E8%B7%A8%E8%B6%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%85%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[阶段性总结 写在前面的话：致所有看到这个文章的伙伴。请原谅我的自私，想要以书信的口吻写给曾经的（上一刻的）自己。如果你不禁笑出了声，感谢你的认同和感同身受。 Dear, 李浩天 想了很久，还是觉得以 “阶段性总结” 这个标题起笔比较好。我想你已经明白不管是Python还是自学能力，它就像英语一样是一个需要不断使用、不断强化和迭代的工具。那在今天这个时刻所需要跨越的我想也许就和财富自由一样，只是一个里程碑而已，跨越过去还有更多的事情要做，更长的路要走。 开始 还是想和你聊聊开始，但也许并不像你想的那样，开始真的不应该在完成选择的那一刻。 我知道最开始的时候，你一定觉得选择加入自学训练营还挺偶然的。但你有没有想过也许就像《The Secret》里面一样，这个世界好像有一个”Attraction law”。而这个Attraction的源头就是你自己的内心。 我想你一定还记的，在很早的时候你心里面就被种上了那颗种子。我真的已经记不清是什么时候了，只是隐约的记得那是某一次你的父亲带着你参加一个演讲的时候，在讲台上的老师说到的。 —— “ 一个人的学历代表他的过去，财力代表他的现在，只有学习力才能代表他的将来”。 我想你一定笑了，因为你明白它已经在你的生命中生根发芽。我看的到，其实你并不过分的信赖所谓的“经验”和“资历”，但你会尊重并观察它们。你认为每一个经验的背后都有其自己成长的背景，也有值得学习和改善的地方。 还记得吗，在你刚毕业半年的时候。你加入一家广告营销咨询公司，开始的时候只是一个项目执行，然后一个月后涨薪，实习期过后升为SA，半年后带团队拿到部门70%的项目。我知道你当时很自豪，也很傲慢。会觉得是因为自己有“自学能力”所以可以快速超越。 我想现在你一定明白了自己当时的傻逼，当静下心来，你才会想起很多的细节。其实你当时只是有学习的态度而已，当时的你真的不知道如何去体系化的、深入的去学习，只不过是有态度所以你的领导愿意带你，你真正感谢的应该是教你学会当时需要的东西的那个领导。啊……我想经过了这些年，你也一定会发现 仅仅有学习的态度，并且愿意花费时间和精力这一项粗浅的特质其实已经可以超越很多人，因为它会让你向前看让你不会离”鄙视链”那么近 （真的不敢说远离） 我们再来聊聊这次你认为的偶然吧。我记得当时的你很迷茫，想要找到一个机会可以以“浸泡”的方式来开启英语，而不是像之前那样反反复复只学不用，同时你也总是想拾起大学时学习的编程知识可也不知道应该从哪里开始。也许当时的你并没有想到可以有这样的一个结合。直到那天晚上： 女票发来消息说：这个东西你看一下，应该你会喜欢的。然后……你就报名了…… 是不是回过头来，感觉好突然，似乎没有做什么迟疑和判断，所以你说这是一个偶然。但我想说 —— 不，这是一个必然。事情的发生其实和选择无关，相同的事情不同的人可能会做出相反的选择。而所有的选择都是根深蒂固在自己内心的观点和认知，所以我说这个的开始真的不是在完成选择的那一刻。 共同成长的14天 原本的小标题是“成长的14天”，但后来改为了“共同成长的14天”，因为这里面不仅仅是你和我的成长，我想更是和每一个一起走过着14天的战友们一起的成长。这里面不可能更不应该只有你的影子对吧。 我想对你来说，最难的应该就是开始的3天了吧。纯英的资料、没有接触过的工具、陌生的词汇，不仅仅对你的时间是一个挑战，更不断地，不断地，不断地打击着你的自信心，让你觉得“我怎么这么蠢，这东西怎么这么难”。我看的到，当时的你不断的在‘对未来的恐惧’、‘对自我的怀疑’、‘内心的自我安慰和鼓励’这三种状态中不断的切换，你想过放弃，但很庆幸你坚持下来了。 请原谅我使用 “坚持” 这个词，我知道你并不喜欢甚至不认同。但我还是想说所有的“坚持”都是存在的，只不过在不同的情景下它转化为了不同的样子。当你以爱好开始那个坚持叫做“想知道”，当你以任务开始那个坚持叫“目标”，当你以被迫开始那个坚持叫“自我安慰”。但是我们都清楚，如果可以走的足够长或者做的足够好那这个坚持一定会被叫做 “根本停不下来”。它将成为你的标签，满足你的内心并支撑你的生活。 说到这里，我不禁想起了那天差点“玩坏微信”的你。应该是Day12，那天的作业是通过微信的文章链接，将文章内容读取出来并统计词频输出。 最开始是惊奇 —— 哇哦，原来还可以这样。然后你用wxpy获取了自己的所有的好友信息，还拍了个视频发给好些个好友，去解释为什么不要随便用微信扫一扫，并通过微信机器人和好友聊天，还发了个朋友圈去指点江山 —— “The code is the language of the age, and as open source requires more and more human nature”，我知道那天你玩嗨了，也真的是收了好一波存在感。 说这个并不是想怪你，其实真的没关系，我看得到因为这次玩嗨后，对后续的学习你多了些许热情。有的时候是需要用一些东西让自己找到它的用处，你才会真的用下去，这是一个自己释放的窗口。但是你要知道你是在做什么，因为什么在做，这就够了。 既然我们是在说“共同成长”，那我们再来聊聊战友好吗？ 我猜你最想和我聊的一定是你们的教练对吗？我记得有一次你差点就放弃了，应该是Day11，那天你的SSL一直出问题，怎么都解决不了，你知道如果这个问题解决不了后面的作业基本上就都完不成了。当时猜测了很多种问题也尝试了多种方法，你甚至都想过要重装系统。我知道你可能最后都已经无奈甚至破罐破摔了，可是教练没有放弃，他帮你解决了。最后的问题是Anacanda自带的Python编译器启动不了系统的 SSL。一切的一切事后说起来都是这样的云淡风轻，但我相信看到这里你一定能回想的起来当时复杂的心情。 这件事情我知道是你记得最深刻的，但是还有一个事情，我觉得你不应该忘记。day10，那天需要通过pip安装jieba这个第三方库，最终你是通过issue上找到战友给出的方法解决的。我知道当时战友的issue让你多少有点惭愧，因为你发现一直标榜学习能力的你，在遇到这个问题的时候竟然没有做进一步的分析，甚至你都没有了解过pip是什么，就张口发文。你明白这种做法叫“索取”，没有人有义务被你索取，也许我说的重了点，但仅仅是想提醒一下你 孤独的旅程在14天的旅程结束后，你便开始了另一个旅途，这段旅途多少有些孤独，但是它却给到你带来了一个惊喜：让你更多的体会到计划和完整性的重要性 当时你计划用一个月的时间读完笑来老师的《自学是一门手艺》。我看的到，开始你是比较随性的，并没有对自己的计划进行分解。因为之前读书一直如此，以将书本的知识运用到生活中为目标而并非速度。 但是很快你就发现这样不行，太过随意让自己丧失了目标。因为10天过去了，你却没有太多的进展，其实常常并不是自己没有时间，而是一种拖延和懒惰造成的。忘记是因为什么了，也不知道是不是巧合，当时的你竟然想到了一个历史事件，让你为之一惊： 那是在1911年的时候了。当时世界上还有一个地方没有人去过，它是最后一个大洲 —— 南极。 当时有两个竞争团队都希望最先到达那里。其中一个是挪威的阿蒙森团队，总共5人；另一个是北欧的莫斯特团队，17人。两个团队基本都是在1911年10月在南极圈外围做好了准备，但两个多月后也就是1911年12月15日，阿蒙森团队率先到达了南极点并在21个月后回到了原来的基地完成了这次探险。 而莫斯特团队不仅仅晚到了。最后也恰恰因为晚了，回去的路上天气非常差，路上遇到越来越多的困难，不断地有人掉队，最终全军覆没。队长莫斯特和另外两个队员冻死在了离他们最后一个储藏装备的地方大概10英里的位置。他们付出了生命的代价。 在后来通过他们的日记中分析得知，阿蒙森团队之所以可以胜利有很多原因。包括充沛的物资、充分的调研、对困难有足够的预料。但最重要的是 ———— 他们有一个策略的区别： 阿蒙森团队做了一个有富余量的计划，并坚持按照计划完成。即，不管天气好坏，团队坚持每天前进大概30公里 莫斯特团队比较随心所欲，天气好就走的非常猛，大家走的非常多，可能有40-50公里甚至60公里，但天气不好的时候，暴风雪的时候，他们就谁在帐篷里，吃点儿东西，诅咒恶劣的天气，希望尽快转晴 其实你明白，也许到今天我们已经不需要为没有达成付出生命的代价，但是这个经验教训依然值得借鉴 因为那天的思考，你开始为这个一个月的计划进行分解。当时你先买了糖果上笑来老师那个《自学是门手艺》的音频，了解了一下每一章的难度和目标，然后试读了两天看看自己的时间花销。最后在保障自己能理解的情况下，决定前两章以每天两节的内容阅读，特殊章节比如“字符串”一天只读一章。对于第三章的内容，每天一章完成。 最终，恭喜你，终于在一个月的时间点内完成了计划 恩，好像漏了点什么。其实中间还有一个插曲对吧？ 当时是看到第三章了，在看到“拆解”之后，你多少觉得后面都是“鸡汤”了，就把节奏放缓了，同MIT 的Python课程一起学习了。 我想现在的你一定和庆幸，当时那个傻叉的自己仅仅是放缓了进度，而不是完全略过了。因为在读完后你明白： 读完才是最重要的 《自学是一门手艺》给到一个完整的心里建设，这对于后面的学习远比 “硬知识” 要重要 ———— 从最开始的时候老师告诉你它并不难学会，往后给到一些学习的方法和原则，比如耐心和刻意思考。再往后会给到达到一定程度的时候会遇到的坑，比如“装权威”。最后，基于完整性特质，引出了全栈工程师，告诉我们全面的路还有很长。而且人生很长，不必惊慌 阶段性总结前面说了很多我们在这个过程中的感触和发现，最后还是要回归这封信的主题，一起来做一点抽象，进而总结这个阶段的收获 我想一定很惊讶，为什么竟然把学习MIT的Python课的过程略过去了。其实并没有。 在我看来 MIT的Python课更像是一个引爆点，它让你对 “计划” 的理解更加具象化，所以它应该是这个总结的一部分。 为什么这么说呢？首先因为这个过程有两个特点： MIT的Python课虽然依然是自学，但有了一个社群，在这里大家会每天打卡，这个多了一个好处就是，当你看到别人打卡的时候你会不自觉的有一种代入感，不太容易被懒惰或者拖延所干扰 但同时也带来了一个坏处，就是每个人都会有自己的发现和自己的想法，你很容易被带跑偏甚至陷入一种迷茫和焦虑 另外，也恰恰是两个特点，让你兴奋过也纠结过迷茫过。最终，使你清楚的认识到一定要自己动手制定一个富有余量的计划，并执拗地执行它 这个里面有三个重点：自己动手、富有余量、执拗地执行 为什么要自己动手为什么一定要自己动手，难道别人的计划不能直接用吗？当然不是不可以，但不是这里就是那里总会有些太合适，以至于最终的效果就是没有自己动手做的好。这里至少有两个原因： 1.每个人的起点多少有些差别 起点的细微差别，它会直接导致在学习同样的内容的时候花费差异的时间。你肯定明白，从 MIT 的 Python 课程来说，至少会有两个明显的起点差别：编程和英语 就拿自己来说，我的英语水平可以说真心烂，英语4级而且毕业后就再没用过，而编程水平多少还好一些。在整个过程中我就会发现，在两个地方是我最耗费时间的，一个是阅读 PDF 的时候需要查单词理解意思，另一个就是在看视频的时候特别是第一遍看视频的时候有些翻译总觉得不对我就需要去查单词去理解它。 同时，我也知道在一起学的小伙伴中已经有是翻译的小伙伴了，显然我们因为同样的东西花费的时间就会完全不一样。当然你明白这个没必要气馁也无需害怕，每个人都是从什么都不会走过来的，这只是在填自己之前坑而已，反正或早或晚总归要填的 当然起点的差别除了这两个显而易见的差别外，还会有很多隐性的难以直接体现出来的差别，比如思考能力、理解能力等。这些都会间接的导致我们在学习同样的内容的时候花费差异的时间 所以，起点的差别虽然不一定很大，但是多少还是有的。直接把别人的计划拿过来反正就会有些不舒服 2.每个人的时间预算很难相同 什么叫时间预算？就是你每天最少可以在这件事件上花费多少时间，并且可以持续多久 其实在脱离的学校后，每个人的职业、社会身份、文化习俗的差异，都会对他的时间花销产生或多或少的影响，以至于每个人的时间花销会有所差异，最终落实到某个事情少的的花销，还和个人的价值观，以及对这件事情的重视程度相关，最终很难相同 就拿职业来说，按照《中华人民共和国职业分类大典》中的内容，我国职业归为8个大类，66个中类，413个小类，1838个细类。单单这一个维度上可能就是存在一个巨大的差别，哪怕由于社群的属性使得某些职业的群体会更多，但再加上其他维度后，差异依然是巨大的 除此之外，还有一个 最重要 的原因：自学是我们自己的事情 什么叫富有余量所谓的富有余量，指的是计划中所花费的时间，比你可以给到的预算时间再少一些 其中 预算时间 - 计划时间 所剩下的称之为 “预留时间” ，类似于工程中的 “预留金” 一样。它的首要功能当然是应对风险，应对什么风险呢？两种： 临时事件导致的 “预算时间” 不足 由于自己的疏忽和遗漏，在看到别的小伙伴发现相关内容时，返工的时间 但是我觉得另一种功能更为重要： 提供一个完善自己的计划的可能性 因为自学的方法这个事情，总是需要也总会不断完善的。可能你没想到或者没有发现的内容和方法会被别的小伙伴提出来。比如在学习 MIT 的 Python 课的过程中，就有小伙伴提出应该看 PDF 的方法，也有小伙伴提出 MIT 有原版书应该和课程一起学习，这个时候 “预留时间” 就起到了作用 其实完善计划是很耗费时间的，真的不是随随便便的并入就可以的。至少你要比较相似度、考虑时间的充裕度、并考察效果后，再决定是不是并入你的计划 在学习 MIT 的 Python 课程的时候，当小伙伴提出上面的方法时，我首先比较了原版书和课程本身的相似度。原版书一共有24个章节，前10个章节和课程相对应，可以部分匹配。之后我考虑了时间的充裕度，按照我的速度将原版书加入时间会拉长两倍超出时间预算，而将 PDF 阅读纳入学习中时间消耗并不多。最后我通过两节课程的学习考察了将 PDF 阅读后的效果，发现确实有明显的加强。于是将 PDF 阅读纳入计划中，并确定每节课程的学习方法：看一遍视频 - 读一遍 PDF - 再看一遍视频 也许你会问我，为什么不能不留 “预留时间” ，需要并入的时候改计划不是也可以？也不是不可以，就是差别会很大。如果你改了计划，由于时间的限制你可能会需要调整节奏甚至舍弃一部分内容。你甚至还要为此比较一下两种不同的情况下那种效率更高，然后进一步拖后计划 所以说，富有余量 很重要，它会在不太影响内容和节奏的情况下，给你提供一个完善自己计划的可能性 尽量保障计划的完整性1.优先保障计划可以 “通读” 学习内容我想我们不用着急一次把所有的内容都搞清楚，也不用着急把连带的内容都看完。我们应该优先 “通读” 学习内容： 《自学是一门手艺》中笑来老师说：读不懂也要读完 《通往财富自由之路》中笑来老师说：读书要先看目录 甚至我的语文老师也教导过我：一定要先通读古文再拆解 其实这些表达的都是一个意思，当你 “通读” 完内容之后，你就会有一个大体的轮廓。你会知道谁和谁之间有关系，你会知道每个部分大概是怎么样一个内容。这样学习第二遍的时候就会更容易理解。当然真正的好书和好文章也不是一遍就可以读完的（这也是我开始第二遍读《自学是一门手艺》才知道的，好书就是一本宝藏，至少参考文献都够你挖好久） 2.尽量保障计划覆盖最小单元如果在一个连续的计划内，无法 “通读” 学习内容，那么退而求其次 —— 尽量保障计划覆盖最小单元 什么叫最小单元？就是可以拆分的相对独立的最小学习模块。一个最小单元有着内部内容的连贯性和相关性 而计划覆盖最小单元，强调的是连续性，这是因为考虑了记忆的特性，这样可以最大限度的降低我们学习和理解成本的方法。我们知道按照 “艾宾浩斯记忆遗忘曲线” 一天之后我们记忆的内容仅会剩余25%，如果隔了更久将会更少。即便我们有所记录或者总结，还是会有很多细节的东西我们会忘记。计划覆盖最小单元，就是针对连续性或相关性的内容最大限度的降低理解和学习成本 比如 MIT 课程 我将它分为了10个最小模块，1-7分别是7个模块讲了7个独立的内容，8-9是一个模块讲类及面向对象编程，10-11是一个模块讲效率问题，12是一个模块更偏向于算法 假设你先制定了连续3天的一个学习计划完成了 MIT 的第一节课程，中间停了两天，然后又制定了一个5天的学习计划完成了 MIT 的第二节课程和第三节的一部分。那么先制定的学习计划是满足覆盖最小单元的，而后制定的学习计划虽然覆盖了第二节这个最小单元，却没有完全覆盖第三节这个最小单元，所以是不满足的 另外，除上面的两点外，最重要的是：一定要做好整理和记录。因为不管是“通读”还是“覆盖最小单元”,都要面对一个问题，就是记忆的流失和不确定。而整理和记录是最好的应对方法 执拗地执行其实前面我们聊明白了，“执拗地执行” 就是自然而然的事情，原因无非两点： 既然已经想清楚了，并作出了一个适合自己的富有余量的计划，有什么理由不执拗地执行呢？ 如果是因为懒或者怕麻烦，那就算了吧。就像笑来老师说的 “活着就挺麻烦的” 最后，还是想说，很幸运。虽然未来自学的路还很长，但我们却都跌跌撞撞的走好了这“第一步”，愿未来一直有你并肩前行 祝好 李浩天 写于 2019 年 7 月 8 日]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE2-2]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学 号: 1901020043 学习内容: MIT 6.0001 LECTURE 2 +Python 编程导论（第2版）（第3章） 学习用时: 2小时 学习笔记收获总结： 穷举法是猜测与检验算法的一个变种，我们枚举所有可能性直到得到正确答案或尝试完所有值，穷举法经常是解决问题的最实用方法。 for循环是对于按照一个整数序列进行迭代的while循环的简化使用方式。 for variable in sequence： code block 内置函数range通常用于生产sequence。range(start,stop,step) default values are start = 0 and step = 1 and optional loop until values is stop -1 for loops 和while loops 最重要的区别是所有for loops都可以用while loops重写，但是while loops不一定可以使用for loops重写，这一点和上述第2条笔记相对应。 遇到的问题和解决方法：今天发现PR后显示格式不对，不再拷贝格式，花了些时间学习一点Markdown语法，改回vscode写作业。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100065-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100065-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：brian学号：1901100065 工作背景大型互联网公司游戏策划 自我介绍科技产品爱好者，生活黑客，两个娃的爹。 学习原因 工作中有大量产品和用户数据分析的场景，希望能够在分析方法、思路以及效率上有所提高。 希望能在生活里的决策中用数据分析的方式指导决策，比如购房、和各类投资场景 目前学习阶段 Python自学训练营马上毕业 之前有少量编程经验，可以在excel里写简单的vba程序，在mac各类效率工具中编写脚本。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>游戏策划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901060005-自学训练营-MIT60001]]></title>
    <url>%2Funcategorized%2F1901060005-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT60001%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901060005 学习内容：MIT 30天打卡 学习用时：14.5小时(1-6) + 46.5小时(7-30) 学习笔记第一天学习内容：看唐总总推荐链接的视频，感谢自学营没有忘记我们。看第一节课视频40 分钟。 学习心得： 1.刚打开视频，有种崩溃的感觉，完全不知所云，看到十分钟左右还是蒙蒙的状态， 视频起到了很好的催眠效果，看视频的过程中几乎要睡着了。还好为克服惰性选择在 星巴克，喝了一口咖啡提提神，慢慢的看到简单的程序语言有点点熟悉的感觉了，能 够跟着视频听懂一些内容，原来的睡意也没有了，不错的感觉。 2.通过视频学习，对于老师讲到的计算机运算能力很快，但是它什么都不知道，如果 没有给他指令，它什么也做不了，如果我们想让计算机输出“X”就需自己先知道怎样 才能够得到它，并转化机器语言输入计算机。感觉这样的表述特别清楚，学习机器语言就是学习规范自己的逻辑思维的过程。 3.学习语言的关键动作就是 练习。 4.任何学习都是有一个过程： 知行合一 第二天 视频学习内容： 1.字符串的基本概念和简单操作 2.学习了Python的分支、迭代、循环的表达方式。 学习心得： 1.又加深了对字符串的概念和基本操作的理解。 2.if…elif…的表达方式更精简了语言的条件、分支的表述。 3.加深了对for和 while两个循环的理解， for循环和while循环，两者的相同点在于都能循环做一件重复的事情；不同点在于， for循环是在序列穷尽时停止，while循环是在条件不成立时停止。 第三天学习内容：1.学习视频两遍用时1.5小时2.学习了字符串的操作，字符串只能被切分，不可更改。3.新学习到字符串可以简单被反向遍历，以前竟然没有想象过这个问题。4.学习了三种算法：guess-and-check,approximate solutions,bisection method 学习心得：自学营结束后，自己又是不是的学习笑来老师的《自学是门手艺》，也有上机练习编程，虽然没有熟练，不过可以编写简单的程序，通过MIT自学营的唤醒，对于Python语言的熟悉度又加强了。主要是在自学的过程中提升了自己的自信心，以前从来没想象自己可以编程，那是遥不可及的事。通过学习感觉到了只要自己要做，并且持续的坚持、践行，就一定会有收获。相信只要学习就一定会产生时间的复利。在学习营里有任务的学习，有同学和老师们的互相砥砺，惰性减少，效率提升，有组织的感觉真好。 第四天 学习时长2小时学习内容： 1.复习笑来老师《自学是门手艺》Part.1.E.2.values-and-their-operators部分。2.学习网上前辈们的技术博客，主要也是学习数值的类型和转换函数。 学习心得：1.基本的三种数据类型： 布尔值（Boolean Value) 数字（Numbers）：整数（Int）、浮点数（Float）、复数（Complex Numbers） 字符串（Strings 重点是有读到了笑来老师书里的一句话： 运算的一个默认法则就是，通常情况下应该是相同类型的值才能相互运算。 这句话自所以是重点，关键它是一个默认法则，也就是通常情况的运算都是遵循这样的法则运行。那么有没有例外呢？自己也在网上搜索了相关信息好像没有不同类型的数值进行运算。不同类型值之间要进行运算就需要进行数值转换，那么转换的函数都有哪些呢？2.数值转换的函数： 1234567891011121314int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 3.了解并加深了理解不同数值的操作符。 第五天 学习时长2.5小时学习内容： 1.学习第四天视频内容。2.学习定义函数和函数内容编写。 学习心得：1.视频中的编程内容基本都能够理解，不过自己在读写甚至是编写的时候就感受到了在练中学，对概念的理解是相对容易。2.比如Python中的函数，自己最初的理解就是一个能够实现某一功能的小段程序。 函数能提高应用的模块性，和代码的重复利用率。 3.函数内部的变量名如果第一次出现，且出现在=前面，即被视为定义一个局部变量。如果要在函数中给全局变量赋值，需要用global关键字声明 第六天 学习时长5小时学习内容： 1.笑来老师《自学是门手艺》递归函数部分。2.视频作业练习。3.学习了变量的局部范围和全局范围 学习心得：1.学习了递归函数三原则并反复测试递归函数： 1).根据定义，递归函数必须在内部调用自己；2).必须设定一个退出条件；3).递归过程中必须能够逐步达到退出条件…… 2.用循环方法和递归函数两种方法计算数值的求和。 递归函数法 123456def sum1(num): if num ==1: return 1 else: return num+sum1(num-1)print(sum1(5)) 循环法 123456def sum1(num): a=0 for i in range(1,num+1): a+=i return aprint(sum1(5)) 条条大道通罗马，现在的感觉哪条大道修起来都不容易。程序思维是学习的重点，虽然进展缓慢，还是要着实用功。 第七天 学习时长3小时学习内容： 1.教学视频及作业练习2.学习元组•列表3.一系列列表的操作函数 学习心得： append,extend，remove,del,pop 等函数都会改变列表。 12345678L1=["bacon","eggs"]L2=["toast","jam"]brunch=L1L1.append("juice")brunch.extend(L2)print(brunch)print(L1)print(L2) 结果 123&gt; [&apos;bacon&apos;, &apos;eggs&apos;, &apos;juice&apos;, &apos;toast&apos;, &apos;jam&apos;][&apos;bacon&apos;, &apos;eggs&apos;, &apos;juice&apos;, &apos;toast&apos;, &apos;jam&apos;][&apos;toast&apos;, &apos;jam&apos;] join将 容器对象 拆分并以指定的字符将列表内的元素(element)连接起来，返回字符串（注：容器对象内的元素须为字符类型）。 split以指定的字符将字符串分割为单个元素(字符类型)并加入list中，返回一个List。 sorted(L) 返回一个排序后的L，不改变原始的L； L.sort() 是对原始的L进行操作，调用后原始的L会改变，没有返回值。L.reverse() 倒序排列并改变列表。 remove()不能用于循环删除。 x = [‘a’, ‘b’, ‘c’, ‘d’]y = [‘b’, ‘c’]for i in x:if i in y: x.remove(i)print x result：[‘a’, ‘c’, ‘d’] 第八天 学习时长3小时学习内容： 1.第五天学习资料中“lec5_tuples_lists.py”文件，运行里面的代码。 学习心得： 元组与元组可以进行相加操作，元组也可以迭代。 t=’python’b=(6,7,8)c=b+(t[1],)print(c) (6, 7, 8, ‘y’) 没有搞懂为什么这个函数变量无法调取外部数值 1234567891011121314def sum_elem_method1(L): total = 0 for i in range(len(L)): total += L[i] return total def sum_elem_method2(L): total = 0 for i in L: total += i return total print(sum_elem_method1([1,2,3,4]))print(sum_elem_method2([1,2,3,4])) 错误提示： unindent does not match any outer indentation level (, line 3) 问题解决：total缩进有问题 第九天 学习时长4小时学习内容： 1.函数的返回值及函数调用间的关联2.字符串的格式化方法 学习心得： 函数无论是否有返回值，都是可以被调用的，没有返回值用print打印函数返回结果是None，有返回值的时候就可以用print显示函数的返回结果。 例如： 123456789def say_hi(*names, greeting='Hello', capitalized=False): for name in names: if capitalized: name = name.capitalize() print(f'&#123;greeting&#125;, &#123;name&#125;!')say_hi('tome','jack')print('-'*20)print(say_hi('tome','jack')) 终端运行结果： 123456&gt; Hello, tome!Hello, jack! --------------------&gt; Hello, tome!Hello, jack!None 字符串格式化方法主要有三种：%格式化 ， str.format()和f-Strings。 %格式化操作容易表现出各种问题，导致许多常见错误（例如无法正确显示元组和字典）。 python中用%代表格式符，表示格式化操作，常用的操作有%s,%d,%r等.%r用rper()方法处理对象%s用str()方法处理对象%d十进制整数表示 使用较新的格式化字符串文字或 str.format() 可以有助于避免这些错误。这些替代方案还提供了更强大，灵活和可扩展的格式化文本方法。它使用普通函数调用语法，并且可以通过 format() 方法为对象进行扩展。使用 str.format() 时，替换字段用大括号进行标记。 str.fotmat()在处理多个参数和更长的字符串时仍然可能非常冗长。 f-Strings，它可以使得字符串格式化更加容易。f-strings 是指以 f 或 F 开头的字符串，其中以 {} 包含的表达式会进行值替换。 12345678910111213141516171819202122name = "hoxis"age = 18someone="hello, %s. you are %s ?" %(name, age)print(someone)print()person = &#123;"name":"hoxis","age":18&#125;is_person="hello, &#123;name&#125;. you are &#123;age&#125;?".format(**person)print(is_person)print()name = 'hoxis'age = 18status = 'Python'message =[f'hi &#123;name&#125;.'f'you a &#123;age&#125;.'f'you are learning &#123;status&#125;.']print(message) 对应结果： hello, hoxis. you are 18 ? hello, hoxis. you are 18? [‘hi hoxis.you a 18.you are learning Python.’] 第十天 学习时长4小时学习内容： 1.学习了列表操作中append()，extend(),insert()不同函数之间的区别，以及pop()和remove()的区别。 学习心得： 看到群里同学们在讨论append()，extend()的异同，这是自己没有留意到点，顺便做了一点延申学习。 append(object) 是将一个对象作为一个整体添加到列表中，添加后的列表比原列表多一个元素(会改变原列表)，该函数的参数可以是任何类型的对象，该函数没有返回值extend(iterable) 是将一个可迭代对象中的每个元素逐个地添加到列表中，可迭代对象中有几个元素，添加后的列表就比原列表多几个元素，该函数的参数必须是可迭代的对象，改函数没有返回值insert（object） 方法是指在某个特定位置前面增加一个数据项。 1234a_list=[1,2,3]b_list=[4,5,6]a_list.append(b_list)print(a_list) [1, 2, 3, [4, 5, 6]] 第十一天 学习时长5小时学习内容： 看了一遍多的视频。 学习递归函数、编写并运行。学习心得：1234567891011def printMove(fr, to): print('move from ' + str(fr) + ' to ' + str(to))def Towers(n, fr, to, spare): if n == 1: printMove(fr, to) else: Towers(n-1, fr, spare, to) Towers(1, fr, to, spare) Towers(n-1, spare, to, fr)Towers(3,1,2,3) 1234567move from 1 to 2move from 1 to 3move from 2 to 3move from 1 to 2move from 3 to 1move from 3 to 2move from 1 to 2 感觉递归函数特别牛，如此聪明的代码，能看懂但是想不出，满受刺激。 兔子繁殖的算法让自己头晕，感觉会编程的都是数学家。化繁为简需要的智慧。 第十二天 学习时长2小时学习内容： 学习群里优秀的打卡作业 学习lec6_recursion_dictionaries.py一个程序学习心得： 套用两个自定义函数的自定义函数感觉逻辑上都难理解。还是先从实用、简单的小程序入手，循序渐进。 第十三天 学习时长3小时学习内容： 学习编程书本中的基础概念及使用。 学习for循环和while循环。学习心得： 两种循环方法，询问用户显示哪个数的乘法表。 123456789101112131415i=int(input("Which multiplication table would you like:"))print ("Here's your table:")for j in range(1,11): print("%d x %d = %2d"%(i,j,i*j))i=int(input("Which multiplication table would you like:"))print ("Here's your table:")j=0while j &lt;=10 : if j &gt;=0: j+=1 print("%d x %d = %2d"%(i,j,i*j)) else: break #print() 运行结果 : 12345678910111213Which multiplication table would you like:5Here&apos;s your table:5 x 1 = 55 x 2 = 105 x 3 = 155 x 4 = 205 x 5 = 255 x 6 = 305 x 7 = 355 x 8 = 405 x 9 = 455 x 10 = 505 x 11 = 55 for循环（计数循环） range()函数–计数循环的一个捷径。 while循环（条件循环） 用continue跳到下一次迭代 用break跳出循环 第十四天 学习时长2小时学习内容： 学习MIT视频两遍 运行、验证代码学习心得： 学习视频就当练习英语了，内容及程序还是要时间慢慢消化，不断地验证吸收。 第十五天 学习时长4小时学习内容： MIT练习题 字符串格式化的几种方法，编写九九乘法表。学习心得： 字符串几种常用的方法：%操作符，f-Strings，str.format str.format 1234for i in range(9,0,-1): for j in range(i,0,-1): print('&#123;&#125;x&#123;&#125;=&#123;&#125;'.format(i,j,i*j),end=' ') print() 1234567899x9=81 9x8=72 9x7=63 9x6=54 9x5=45 9x4=36 9x3=27 9x2=18 9x1=98x8=64 8x7=56 8x6=48 8x5=40 8x4=32 8x3=24 8x2=16 8x1=87x7=49 7x6=42 7x5=35 7x4=28 7x3=21 7x2=14 7x1=76x6=36 6x5=30 6x4=24 6x3=18 6x2=12 6x1=65x5=25 5x4=20 5x3=15 5x2=10 5x1=54x4=16 4x3=12 4x2=8 4x1=43x3=9 3x2=6 3x1=32x2=4 2x1=21x1=1 %操作符 1234for i in range(1,10): for j in range(1,i+1): print('%dx%d=%2d'%(i,j,i*j),end=' ') print() 1234567891x1= 12x1= 2 2x2= 43x1= 3 3x2= 6 3x3= 94x1= 4 4x2= 8 4x3=12 4x4=165x1= 5 5x2=10 5x3=15 5x4=20 5x5=256x1= 6 6x2=12 6x3=18 6x4=24 6x5=30 6x6=367x1= 7 7x2=14 7x3=21 7x4=28 7x5=35 7x6=42 7x7=498x1= 8 8x2=16 8x3=24 8x4=32 8x5=40 8x6=48 8x7=56 8x8=649x1= 9 9x2=18 9x3=27 9x4=36 9x5=45 9x6=54 9x7=63 9x8=72 9x9=81 f-strtings 1234for i in range(1,10): for j in range(1,i+1): print(f'&#123;i&#125;x&#123;j&#125;=&#123;i*j&#125;',end=' ') print() 第十六天 学习时长40分钟学习内容： 笑来老师的《自学是门手艺》“保存到文件的函数”部分学习心得： 事情忙起来都没时间学习，当然也和惰性有关，没有及时投入学习。当有突发情况出现只有见缝插针的进行学习并完成日记。 学习了函数保存文件里作为模块方便调用，并温习了函数调用的方法。 第十七天 学习时长3小时学习内容： 笑来老师的《自学是门手艺》“值及其相应的运算”部分 学习lec7_debug_except.py中的程序学习心得： lec7_debug_except.py中的程序对自己来说还是要再花时间消化. 定义素数列表函数这里就花费了很多时间，刚开始都没有理解程序的逻辑。 学习别人的程序前首先要看看注释，能比较快速的理解函数要实现的功能。 第十九天 学习时长2小时学习内容： 学习了解“对象”的概念:对象=属性+方法 可以对它们做什么（动作）。 如何描述（属性或特性）。 学习心得： 先定义对象，像什么，会做什么。就如先画一张图纸确定要建造的实体是什么，能干什么。 第20天 学习时长40分钟学习内容： 学习lec8.classes.py里面的程序学习心得： 没有很好的理解这部分内容，需要加深学习这部分，争取能有点点突破。 第21天 学习时长50分钟学习内容： 学习“类”与“对象”的概念学习心得： class后面紧接着是类名，类名通常是大写开头的单词（例如：Teacher），紧接着是(object)，表示该类是从哪个类继承下来的. 注意到init方法的第一个参数永远是self，表示创建的实例本身，因此，在init方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 第22天 学习时长3小时学习内容： 学习“对象”，加深理解属性，方法及实例。学习心得： 对象=属性+方法 属性相当于变量，只不过是在对象中的变量。它可以显示，可以赋值，可以给常规变量（不是对象的变量）赋值，可以给其他对象的属性赋值。 对象就是将一个产品从无到有的一个过程，定义类就相当于给一个即将建造的产品命名，然后通过属性和方法告诉大家这个产品是什么，什么形状、颜色、大小、重量等等属性，它可以做什么，可以怎样操作等等。 比如建房子，属性和方法就是相当于为要建的房子画了一个图纸，只要按图施工就可以建造出图纸上的房子。实例就是开始按照图纸建造房子，一个图纸可以建造很多房子。 123456789101112131415161718192021class Door(): "定义类-门" def __init__(self,size,color,type): "初始化门的属性" self.size = size self.color = color self.type = type def open(self): "门操作的方法" print("打开这个宽%scm颜色%s的%s门" %(self.size,self.color,self.type)) def off(self): "门操作的方法" print("关闭这个宽%scm颜色%s的%s门" %(self.size,self.color,self.type))door1 = Door('90','red','木门') #门的实例化1door1.open()door2 = Door('120','white','铝合金')#门的实例化2door2.off() 打开这个宽90cm颜色red的木门门关闭这个宽120cm颜色white的铝合金门 第23天 学习时长50分钟学习内容： 对象实例，数据隐藏学习心得： 构建一个对象首先要定义，可以初始化属性，可操作的方法，创建实例。虽然大概流程了解了，要使用好对象还是要在代码上多下功夫，既要不断地熟练基本操作，又要不断的理顺自己的逻辑思维能力。在顺利程序的过程中也是不断的顺利自己思维里的逻辑，是一个一举两得学习。 对象中的数据（属性）可以被查看和修改，不过建立一个方法可以同时调整两个及以上的属性，还有就是可以避免很多无效的操作。 第24天 学习时长30分钟学习内容： 了解学习对象的两个重要的方面：多态。 学习了两个多态程序。学习心得： 多态就是在一个对象中可以有两个或者多个相同的方法，它们可以有不同的行为。 同时再强化下方法，对象的方法就是可以调用这些代码做什么事。方法就是对象中的函数。 概念的理解是学习效率的关键，对于重要概念要反复的学习、复习、敲代码践行。 第25天 学习时长50分钟学习内容： 对象的继承学习心得： 继承就像孩子从长辈继承了一些东西，比如样貌、皮肤、发质等等，也可以是钱财。 对象的编程中，类可以从其他类继承属性和方法，就形成一个“家族”以共享相同的属性和方法。 1234567891011121314151617181920class Person(object): def __init__(self,name,sex): self.name = name self.sex = sex def print_title(self): if self.sex == "male": print("man") elif self.sex == "female": print("woman") class Child(Person): # **Child 继承 Person** pass May = Child("May","female")Peter = Person("Peter","male") print(May.name,May.sex,Peter.name,Peter.sex) # 子类继承父类方法及属性May.print_title()Peter.print_title() 第26天 学习时长 30分钟学习内容： 对象现实应用学习心得：明天继续完成 123456789101112131415class BankAccount: def __init__(self ,account,name,balance): self.account=account self.name=name self.balance=balance def save_money(self, money): self.balance += money def draw_money(self,money): if self.balance&gt;=money: self.balance-=money print("取款金额：&#123;&#125; 余额：&#123;&#125;".format(money,self.balance)) else : print("余额不足") 第27天 学习时长 50分钟学习内容： 对象现实应用学习心得：123456789101112131415161718192021222324252627class BankAccount: def __init__(self ,account,name,balance): self.account=account self.name=name self.balance=balance def save_money(self, money): self.balance += money def draw_money(self,money): if self.balance&gt;=money: self.balance-=money print("取款金额：&#123;&#125; 余额：&#123;&#125;".format(money,self.balance)) else : print("余额不足") def check_balance(self): print("账号：&#123;&#125; 户名：&#123;&#125; 余额：&#123;&#125;".format(self.account,self.name,self.balance))bankat=BankAccount(123456,"lili",3200)bankat1=BankAccount(123489,"王文",1000)bankat.save_money(2800)bankat.draw_money(1200)bankat1.save_money(890)bankat1.draw_money(1000)bankat.check_balance()bankat1.check_balance() 取款金额：1200 余额：4800取款金额：1000 余额：890账号：123456 户名：lili 余额：4800账号：123489 户名：王文 余额：890 第28天 学习时长60分钟学习内容： 使用pygame绘制圆形，矩形。学习心得： 在学习的路上不会孤单，有问题先在网络上查找解决问题的办法，有无数的先行者已经把踩过的坑都做了解决攻略。学习中最需要的是克服自己的浮躁，有问题的时候就是提升自己的时候，无论知识还是情绪。 学习python基础的概念、知识点之后，可以借助第三方库解决很多实际问题，这样语言就越来越贴近工作和生活了。 123456789101112import pygame,syspygame.init()screen = pygame.display.set_mode([640,480])screen.fill([255,255,255])pygame.draw.circle(screen,[255,0,0],[320,160],60,0)pygame.display.flip()running=Truewhile running: for event in pygame.event.get(): if event.type==pygame.QUIT: running=Falsepygame.quit() 第29天 学习时长70分钟学习内容： 学习了一部分程序复杂度分析（大O表示法）。学习心得： 看了Lecture10部分视频，云里雾里，通过网络资料了解、学习程序复杂度分析。算法通过时间复杂度和空间复杂度来评价一个程序的好坏，衡量算法的运行时间有三种方法： 基准评价、统计指令，以及复杂度分析（大O表示法）。 空间复杂度和时间复杂度，可以作为选择数据类型的评判标准之一。 对于一个程序来说，编程语言提供了最基础的类型实现，例如python里面的str，int，float，list，tuple等，在表达一个数据结构的时候，就有各种选择，可以选择不同的方式，而当你选定了数据结构，那么你程序最基本的运行时间就大概已经定型。 不同数据结构复杂度连接分享。 https://www.cnblogs.com/yueyun00/p/10246251.html 第30天 学习时长60分钟学习内容： 使用pygame随即绘制100个矩形。学习心得： 在脚本上随便修改矩形颜色，底板颜色，随机生成100个矩形图案相互叠加还是蛮好玩。 时间和坚持会越来越了解、理解一门语言，同时这门语言是未来的趋势，是技能、是手艺、是逻辑训练工具、是与年轻人交流的工具甚至可以成为发展兴趣的工具（瞬间感觉这门语言很强大^ _ ^）。 坚持打卡30天，过程中不断的挑战、突破，时间及惰性，虽然还有太多不足，而这也是前行的动力。 1234567891011121314151617import pygame,randompygame.init()#初始化pygamescreen = pygame.display.set_mode([640,480])#设置显示幕布的宽和高screen.fill([255,255,255])#幕布填充白色for i in range(100): width = random.randint(0,250) height = random.randint(0,100) top = random.randint(0,400) left = random.randint(0,500) pygame.draw.rect(screen,[0,0,0],[left,top,width,height],1)pygame.display.flip()running = Truewhile running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = Falsepygame.quit()]]></content>
  </entry>
  <entry>
    <title><![CDATA[1901050017-今年是自学编程年，我将用这个杠杆来撬起我的未来]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901050017-%E4%BB%8A%E5%B9%B4%E6%98%AF%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E5%B9%B4%EF%BC%8C%E6%88%91%E5%B0%86%E7%94%A8%E8%BF%99%E4%B8%AA%E6%9D%A0%E6%9D%86%E6%9D%A5%E6%92%AC%E8%B5%B7%E6%88%91%E7%9A%84%E6%9C%AA%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[阿基米德曾经说过，给我一个杠杆我能撬起整个地球。 硅谷投资人Naval说： Code and media are permissionless leverage. They’re the leverage behind the newly rich. You can create software and media that works for you while you sleep. Study microeconomics, game theory, psychology, persuasion, ethics, mathematics, and computers.Apply specific knowledge, with leverage, and eventually you will get what you deserve. Specific knowledge can’t be taught, but can be learned. Knowledge that gets you paid. Identify your strengths and apply them Capital means money. To raise money, apply your specific knowledge, with accountability, and show resulting good judgment.Fortunes require leverage. Business leverage comes from capital, people, and products with no marginal cost of replication (code and media). 我一直想和这个世界有更深的连接，而不仅仅是做一个时代的局外人。而作为年近40的人，想要更深的连接只有通过“杠杆”工具了。在之前的几年，我通过自学，已经拥有了两个“杠杆”。 杠杆1: 自学excel vba，让工作流程半自动化，精确结果，效率提高 我曾因为恐惧，恐惧不能跟上时代，这个念头在我脑子里盘踞了很久，我不禁自问，如果我这时候没有工作了，我有拿的出手的特长吗？我会脱离人群吗？ 我的工作是中学教务处老师，相对“稳定”。但内心深层的焦虑和危机感还是占据了我的大脑，看看周围，几乎都是心态半退休的人们，至今我都记得那时的感觉：焦躁不安，束手无策。我只知道我不想再当那种出了大学门就再也没升级过知识的人。左思右想，我决定从小事做起。先把我的工作升级一下，至少这是我力所能及的。我的主要工作是安排课表和监考，统计课时费，但一直都是半手工，半电脑输入，至于怎么改进我一点头绪都没有，问问周围的同事，她们都摇摇头，说做的挺好的呀，没有必要改。我知道我不能再求助他们了，我转向网上，开始逛办公软件的论坛，就这么一点一点的，从一个公式到vba，我用了两个星期的时间，把课时费统计表做成了半自动化输出，课表和监考表做成了半自动生成，当测试结果完全符合我的期望时，有一种从原始社会进化到现代社会的感觉。至于刚开始的恐惧，早就随着进化一点一点地消失了。 杠杆2: 自学英语，和现代先进的文化产生了更直接的连接 这次得到人生杠杆的原因是紧迫，这个紧迫呢，是由于孩子的原因。我的大女儿按计划去国外上学，国外各种文件、邮件纷至沓来，而家中无一人看得懂。思来想去，我决定学英语，想着，将来女儿需要我去国外陪她的时候，我能顶得住。人啊，一旦尝过甜头，就不肯停下来了，学习也是如此，尝到过自学的快乐，就总会找机会再尝试的。这次我不是没头苍蝇似的瞎找，而是直接决定—-以“用”代“学”英语了。这个决定是因缘际会，看到了李笑来老师的《人人都能用英语》之后做出的。这也是我第一次看李笑来老师的书，虽然那时还没有来得及去研究他的背景，但是他的实践主义让我看到了学英语的希望。时间紧迫，也没做他想，就这么地，我急匆匆地踏上了第二次自学之旅。没有什么特别的开始，那时起，每天我都在办公室朗读《大空头》，车上、健身时耳机里都放着它的电子书音频,因为我记得李笑来老师在书里说过： 读一本真正感兴趣的原版书，讲的是自己正真感兴趣的话题，你不用去坚持，不用去挣扎，这时候是自己在“用”，而不是在“学”。我们关注的不是英语字句本身，而是文字承载的内容，英语只是挡在我们和内容之间的毛玻璃，时间久了，就会越磨越薄。 我知道自己对金融非常感兴趣，于是我从这方面着手，从兴趣这个点扩展到英语整个面。就这么过了一年，有一次在电影院看英语原版电影时，突然发现我都听懂了，当时的我怔住了，心跳地厉害，那时我知道英语不再是我的弱项了，而将来有一天女儿需要我去异国陪伴，我也会竭尽所能不拖后腿，替她挡风遮雨。 英语真的是和现代文明连接最快的方式。 杠杆3:编程。它可以带我活在未来 如今，编程是这个时代无须权威机构许可，就能使用的杠杆，它们是这个世界上最聪明的人创造的语言，它们是顶级思维凝聚的智慧结晶。我知道它会给我力量，来突破成长边界线。用它可以撬起我的未来，不再做时代的局外人。什么叫局外人？就好比大学文凭金贵的时代，不参加高考的人；改革开放的时代，不去当弄潮儿，反而变成下岗工人的人；地产时代，不购置房产的人；每个时代都有它的特征，现在，不会编程在我看来，就是错过了这个时代。而在更新知识如此快的编程世界，知识更新的速度比进入课本的速度快，等到学校里把它定为一门课程，等着老师来教的话，就永远学不到最新最快的编程知识了。 既然我知道了我需要掌握的技能，那我如何敲开呢？我试了读书、看视频、报网课，信心满满地开始，回头丧气地停滞。前几次自学成功的自信心被击碎了，眼看着未来已来，而我却束手无策。所以，在我看到李笑来老师的python自学训练营开班后，立刻就报名了。说实话，我当初报名，也是死马当活马医的心态，因为确实编程的学习停顿了一些日子了，苦于不能敲开门，心态已经不好了。没想到的是，最终结果是我竟然以优秀学员的成绩毕业，用6天的时间学完了14天的课程。那，我是怎么做到的呢？ 首先，自学训练营不是传统教学方式，但它是最符合编程学习的方式：没有老师教，不限地点，资料都是最新的，自己看书、思考 + 社群同学请教 + github分布式提交作业。进了自学营，不仅学会的是编程，还学会了在github上和全世界最优秀的人们（都在GitHub上）近距离接触—通过作品接触。那么github是什么呢？github是一个面向开源及私有软件项目的托管平台。github的特点，简单来说就是，代码托管，开源共享。第一点：代码托管。比如说，在你出差的时候，带了一台笔记本，想在有空的时候写写代码，但是你的代码在另一台台式电脑，这该怎么办。如果己经把代码放到github上，那只需要下载下来就可以了。那么，代码托管，并不是github特有的。github最大的亮点在于，开源共享。第二点：开源共享。第一点好处就是团队协作。一个项目分成几个模块，无论大家身在何处，都可以一人做一部分，再把自己做的部分上传到github仓库里。真正是全世界协同合作。另外一点好处是，可以借鉴别人的代码，模仿大师的杰作，在别人允许的情况下为己所用 。比如说，准备做一个项目，往往一个复杂的项目都需要把项目分成多个模块来做。这时可以上github搜与项目或者各个模块相关的代码，然后进行二次开发，省时省力，比自己纯手写代码节省很多时间成本。第三点：对于学习编程的人来说，github就是天堂。学习编程不是学语法这么简单，最关键的是要动手，学习编程讲究多看多练。github就提供了很好的学习机会。可以在github找些小项目来学，代码少，而且简单。先是看一遍，然后自己动手把这个项目重做一遍。如此一来，确确实实能够学到很多东西。gitHub于2008年4月10日正式上线。目前，其注册用户已经超过350万，拥有超过900万开发者用户。 训练营带给我的 训练营的每日作业都会迫使我主动思考，逼迫我一字一句去阅读要求，不按照要求做就会完不成作业，强制改正了我阅读不仔细的问题。 社群式学习。不是单打独斗地面对困难，‘恐惧未知’这条恶龙不会在大脑中盘旋很久，因为有教练和同学在帮助着我，即使偶尔会深陷泥沼，只要我呼喊，他们就会立刻施于援手。学习效率大大提高。 养成了阅读官方档案的习惯。这一点非常重要，每天的作业都会给出官方档案的链接，在群里大家也会互相提醒，随时巩固这个好习惯。 学会了程序员思考，遇到难点，学会把它分成一小段一小段来解决，并且用自己熟知的知识尝试类比来解释给自己听。 深刻地认识到了借鉴优秀程序员的智慧结晶是非常重要的，有质量的输出的前提是要有质量地输入，如果能看懂优质代码，并为己用，这本身就是一种进步。 千里之行，始于足下—-训练营第一天自学训练营最能反映学习中不好的习惯。 收到“自学任务清单”，开始学习。清单表达的很清楚，但真的就是我看不见它，它一直在那里。清单里要求先看参考资料，我愣是自动掠过这一步，现在想来，真的是很佩服我的大脑，就这样习惯性地怕麻烦，找捷径，试图略过一切，然后还妄想能快速完成作业。 我在卡壳以后，冷静了下来，重新从清单1开始看，耐心地看了参考资料，认真地对待每一句话，这样竟然神奇地解决了每一个问题。这次我认识到想要解决问题，还是得克服自己的毛病。在做作业时，踏踏实实。 因为习惯不好，没有阅读官方文件。在一个小到不能再小的步骤上卡壳了1个小时。 在查看社群其他人的聊天中，找到了解决方案，在第一天截止时间前完成了第一天的打卡。 好久没体会过沉浸的感觉了，就是那种猛一抬头，一个小时过去了。 第一天的学习让我认识到想要解决问题，还是得克服自己的毛病。在做作业时，要踏踏实实。 纸上得来终觉浅，绝知此事须躬行—-训练营第二天看到群里的同学都在陆续地交作业（社群学习的好处，时刻督促自己），我停掉了“自我攻击的剧情”，心里开始接受一件事，那就是遇到不会的问题时是正常的，不久的将来一定会熟练掌握的。于是，心理突破了，脑子和手并用，完成作业的速度就提上来了。再加上，我不再以借鉴代码为耻，目的就是为了学习，我再借鉴的基础上再加上自己的理解，现在已经能够写出代码的一大部分了。自主学习加同学间互助式学习，具像化了李笑来老师说的： 很多人有莫名其妙的误解，以为“自学”（self-learning)就一定是“自己独自学”（solo-learning)，殊不知，自学也需要社交。 别怕！ 啥也别怕！没什么可怕的！ 收获总结： 学会了抄代码。不再谴责自己没用，心安理得地抄了三种代码，然后运行，改写代码，最后改写出了自己的代码。 敢于调试，以前总是怕出现问题，手心冒汗，后背冒汗，脑袋发麻，如今出现问题我就搜索问题是什么意思，然后冷静地去想办法解决。 学会去github里的issues找问题答案。 读书破万卷，下笔如有神—-训练营第三天收获总结： 行之有效的方法就是大量阅读官方资料，因为是社群学习+github分布式交作业，所以可以看到很多同学的代码。学习+模仿，是我在3天时间内完成day1-6的任务的秘诀。输入有质量才是最好的进步方式。 读书不觉已春深，一寸光阴一寸金—-训练营第四天写python代码，做有用之事。在第四天，完成到了训练营day10的任务。 收获总结： 因为这几天的学习，让我深刻体会到了废寝忘食、孜孜不倦、目不转睛、聚精会神、茶饭不思的境界，心流时间可以达到3、4个小时不间断。 对阅读更是有了新的体会：一字不落的读，来回反复地读，不躲避，不放弃，迎着困难读。 对官方文档更加看重，对google也更加依赖，李笑来老师说的好： 学习任何东西，首先看官方文档或产品说明书，那些学习高手都是会先阅读官方文档的人。 能google出答案的问题，就不需要去麻烦别人.google、stackoverflow、wikipedia、youtube这都是自学人经常要去搜索的好地方。 千里之行，始于足下—-训练营第五天 眼是懒汉，手是好汉不怕，一点也不可怕，不难，一点也不难。 在这天，我清楚地感受到今天不想做作业地心情，抵触、逃避、恐慌、焦虑。。。。。。因为预知了困难，提前看GitHub 上的issues里都是关于day11作业的困惑和疑问，心里多少有些抵触。但是我知道只有做了才能解决，而不是空想。逃避没有任何用，把任务分解，一句话一句话地去实施。 随着着手敲代码的开始，这一天没有想象中困难，最后完成了day11-12的任务。 收获总结： 深刻理解了，写代码如同搭积木，一个函数如同一块乐高积木，只要一块一块加上去，就具像化了自己的目标。 一直听说python爬虫技术，今天终于得以实施，抓去了张小龙的演讲稿并做了处理，返回了邮件。 一直听说微信机器人，今天又亲自实施，和微信好友互动有无，她给我文章，我给她文章的数据，是自动的哦。 这次我好像真的很可以确信，学python不会再半途而废了，也许日后如同excel一样，用的机会越来越多了。 敏而好学，不耻下问—-训练营第六天最终的一天来到了，全部学完了训练营的任务，中间有困惑，有惊喜，最终收获的是满满的知识和弥足珍贵的自学体验，升级了自学的操作系统，对未来编程技能的使用充满了信心。 关于编程的思考 1真正理解了编程就是搭积木的过程。尤其是在day11作业开始，把各种函数放到一起，去完成自己的目标。函数就是手里的工具，建筑工人的砖头和水泥，人们的交通工具，摄影师的单反，学生的铅笔和橡皮，化妆师的化妆品和化妆工具，它只是让我们轻松完成目标的手段。最主要就是得先‘用’起来，只有用起来，才能直到自己的需求，正如不需要会修车才能开车，也只有开了一段时间的车才能清楚地知道自己到底需要什么功能，不需要什么功能。有人说，不都得先了解清楚了才能用吗？这种想法我认为挺害人的，大多数人的坏习惯，是从来不需要了解清楚危害就已经开始做了，比如填鸭式学习，比如抱怨，比如不健康的饮食习惯，但是要是想开始学习某项技能了，却谨慎了起来，给自己找一堆理由进而可以拒绝进化。需要大概了解一下原理？需要。需要着重看一下说明书吗？非常需要。 李笑来老师说过： 你不用去坚持，不用去挣扎，这时候是自己在“用”，而不是在“学”。我们关注的不是英语字句本身，而是文字承载的内容，英语只是挡在我们和内容之间的毛玻璃，时间久了，就会越磨越薄。 这句话对自学编程也是一样的好用。我们关注的不是编写代码本身，而是背后的思维方式。 学会顶级聪明人的思维方式，才是自学编程最大的收获。]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901060005-曾对电脑不熟悉，用20年前的4级英语水平，我却坚持写出了通往未来的代码]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901060005-%E6%9B%BE%E5%AF%B9%E7%94%B5%E8%84%91%E4%B8%8D%E7%86%9F%E6%82%89%EF%BC%8C%E7%94%A820%E5%B9%B4%E5%89%8D%E7%9A%844%E7%BA%A7%E8%8B%B1%E8%AF%AD%E6%B0%B4%E5%B9%B3%EF%BC%8C%E6%88%91%E5%8D%B4%E5%9D%9A%E6%8C%81%E5%86%99%E5%87%BA%E4%BA%86%E9%80%9A%E5%BE%80%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[曾经的迷失我叫代智国，来自深圳，2002年大学毕业，2004来到深圳，恍恍惚惚，蓦然回首已经在深圳生活了15年。10年前开始创业，现在是一名中小企业老板，从事餐饮食材贸易，开设连锁餐厅。团队的慢慢成熟，自己的自由时间相对宽裕一点，有时会迷茫、焦虑甚至迷失。未来是什么样子？现在的自己能够适应未来吗？怎样才能更好的读懂未来、适应未来？。。。。。。 在无数的疑问中，疯狂的参加线上和线下的学习，开启了学习和自我成长之旅。过多的线下的学习，使自己疲惫于到处奔波，反过来思考和复盘的时候又感觉收获不大，有些痛惜过去徒劳的学习时间和经历。痛定思痛，决定慎重的选择学习课程，不再盲目、飘荡奔逸的随从。这时目光转向了线上学习平台，出于对知识的贪婪，又同时参加了5个左右的线上平台，在信息的过滤中慢慢的做着自己的选择和判断，信息质量不高的平台自己很少光顾了，有的直接卸载。 为了保存精力，为了不再浪费宝贵、公平、一去不复的时间资源，目前跟随为数不多的课程，笑来老师的课程是其中之一。当然，对于笑来老师的课程自己也是经历了怀疑、迟疑到相信的过程，虽然笑来老师自称“硬核鸡汤”传作者，不过能够感受着笑来老师的价值观引导是可敬的，他所说和所行都是一致。是真正的“知行合一”的践行者。笑来老师如此的笃定前行可能基于他对”成功“概念的定义： 所谓的成功，无非是“用正确的方式去做正确的事情”。 价值观是对的，做的事是对的，所需要的做的也只有用正确的方法坚持，而笑来老师就是如此的走过来，他就是自己前行的导师，是前进路上”填坑“的向导，有如此通过践行获有真知的老师值得跟随。 为什么学习Python通过一个线上学习APP订阅了笑来老师的《通往财富自由之路》，对自己的很多认知有了很大的触动和颠覆。追随笑来老师来到了Python自学营。当时决定学习Python下了很大的决心，在自己原来的认知世界中从来就没有编程的概念，因为自己平时电脑用的都少，编程更是想都没有想过，因为编程是什么都没有概念。电脑的不熟练、20年前的4级英语水平毕业后就没有使用过，任何一个方面对自己自学Python都是一份大的挑战。 既然决定学习就有必要了解什么是Python，于是通过网络搜索查阅的大量资料，终于了解了一点点概念。虽然还是不懂，虽然有害怕过露怯，想学又害怕压力而退缩，在无数次的纠结后，下定决心挑战自己。想到笑来老师说过： 你原本有机会，却因为害怕羞耻而放弃…… 最终，你一无所成，当然应该羞耻. 既然要做时间的朋友就要做对得起自己和时间的事情，未来社会变化程度之大是自己难以想象的，不想在人工智能和物物相连的世界中茫然无措，不想做未来的 “文盲”，自己感觉学习程序语言势在必行。于是在自学营报名、缴费，开始了开智学习。 坚持开始的学习的确是如自己所料，困难比较多，基本上是用了一天的时间才算搭建好了开始学习的电脑里的环境。过程中有过烦躁，有过想放弃，如黑夜中摸索前行，克服心理障碍、语言障碍、知识障碍的过程中缓步前行。印象特别深的是在“对象”这个概念了纠缠了4天左右时间，能够感受到理解和应用“对象”对于能否学好Python特别重要，虽然不能准确理解“对象”到底重要在哪里。 当时的感觉：自己如一只口渴的乌鸦，眼前明明摆着一只装着水的瓶子，可悲的是瓶身高、瓶口小，任你再怎样着急，水依然在瓶子里，看得见但是喝不到。 自己在脑海里搜寻着解决当下问题的方法，期待能够找到解决问题的答案。最终还是用笨拙的、缓慢的、折磨身心的方法，一点点、一字不漏的阅读、阅读、阅读。。。。。。一点点的敲出代码、调试代码、修改甚至删除代码，如此的重复、重复。。。。。。第四天当看到书中概念的时候，瞬间感觉是如此的亲切，每个字仿佛都能够读懂了，它们所构建的图案都在脑海中浮现，是如此的清晰，是如此的让人愉悦，是如此的让人热血沸腾。 已经记不清楚什么时候有过这样的感觉了，能够确定是那是很久以前的事了。时间和坚持可以解决任何你想解决的问题，只要自己不放弃就没有任何外在的因素能够阻止你的前进，即使是在人生的谷底也会奋力前行。因为坚持让自己走出了想放弃学习的念头，因为坚持找到了自己继续前进的勇气和力量，因为坚持仿佛能够感受到时间的友好，因为坚持自己的内心仿佛光亮了许多。 学习中点滴收获自学营14天的学习，从开始的更多是想挑战自己的出发点到对Python有了一些兴趣，看到一次次敲出的代码能够运行出来，这种即时反馈的喜悦和成就感是其他学习中没有体会过的。 14天的坚持，编程零基础的自己有了继续学习Python的勇气和动力。 14天的坚持，渐渐的发现解决同样的问题可以有不同的结构、不同的算法，在学习和借鉴的过程中，当发现一种实用、简洁而优美的程序时，那种心情特别开心，赞叹的同时更多是感受事物和心情的美好。 14天的坚持，使自己不再抵触、抗拒阅读英文教程。 14天的坚持，在应用中学习Python，虽然学习中的应用还很简答，看着原本陌生的语言在解决着现实中的问题，原来的陌生和距离感消失了，它与我每天的生活是如此的贴近。 14天的坚持，让自己坚信没有什么是不可战胜的，问题的根本是你想不想、肯不肯去做，道理就是这么简单。。。。。。 14天的坚持，自己收获的太多太多，也许这就是用笑来老师的话说“入门”了，只要坚持学习并勤加练习可以更熟练的使用它。 曾经不识字是文盲，后来不懂英语是文盲，再到不懂基本计算机操作技能是文盲，到现在和不远的未来，不懂数据分析基本与文盲无异。。。。。。 自己能够清晰的感受到，学习Python的过程中，因为其知识浓度、知识难度对于自己都是很大的挑战。为了完成学习要不断的克服学习过程中出现的各种性格弱点，比如惰性、烦躁等等不好的情绪。克服这些人性弱点不仅仅是学习的需要，更是工作、生活甚至人生的需要。可以说学习Python不仅让自己懂得了一门语言，学会了一项技能或手艺，更加重要的是同时也在净化自己的”情绪底板“，可谓一举多得，事上磨练从来都不是虚言。 “潺潺溪水，肆意汪洋。” Python就是那个解未来之渴的“水之源”，未来就是无数个今天的延续。为了自己不成为未来的文盲，为了子女能够更好的生活在未来的时代，学习Python是自己的需要，自己也会在学习中不断地完善学习方法，持续的学习，为在未来遇见更好的自己而不是日趋堕落的自己而努力、为了成为孩子的榜样而努力。 天行健，君子以自强不息！ 14天的坚持，学习历程的记录：day1 收获总结： 1.刚接到任务就小紧张，在安装Anaconda的时候，就浪费了不少时间。更换版本重新下载安装后问题解决。还有就是运营Github最好是在googlo浏览器中运营，不然会很多问题。 2.第一次提交作业，教练回复没有READ.md，helloworld.txt多了一个txt，文件变成了helloworld.txt.txt。重新在本地仓库调整文件，才清楚作业要求的txt后缀系统自动添加，不需要文件命名时添加后缀。通过issue的问答中学习到README.md是文本文件。自己原来只是在建了一个文件夹。 3.在Github destop的commit耽搁了不少时间，原来commit要一个一个勾选。 备注：1.本地仓库变更之后要在github destop界面左下角完成commit，并且修改的内容要一个一个勾选，逐个commit。 2.commit之后github destop界面的push按键会变绿，点击之后就会同步远程仓库github中。通过pull request与master合并。 day2 学习总结： 1.主要的问题还是英文阅读上的困难，本来就不懂机器语言，再加上不熟悉的英语，难上加难。下载VS Code后设置Python环境和参数耽搁了很多时间，在摸索陌生的知识感觉就是在黑夜里前行，每走一步都很小心。体会到真正的自学是能够改变一个人的思维模式，改变人的认知。 2.在fork老师的新书，clon到本地文件夹时也因为掌握的不好耽搁了一点时间。首先路径都不完全确定，经过思考系统间的关系，几次试错，搞定。完成一项任务还是很开心。 day3 学习总结：1.拿到作业，感觉内容不多，看到编写计算器程序就懵了。一点头绪都没有，平时用excel都少，对于函数没有概念，感觉大脑抛锚了。那就先了解学习python的函数，即使了解一点函数，编程的逻辑都没有，两难相加是1+1＞2！运算程序只好上网借鉴别人的，感谢他们。2在程序的运行上面也纠结了很久，在教练和同学的帮助下，跌跌撞撞搞定。感谢大家。 day4 学习总结： 1、经过多次运行程序，终于发现一个小细节：函数结束都需要有冒号（：）才能被识别正确格式。 2、学习理论的同时要同步在VS Code python 环境中码程序、运行反复操作，才能慢慢有一点感觉。 3、刚刚接触python 语言，感觉 for…in 和while 都是很好用，一定要明白他们的使用规范，才能用起来比较舒服。 4、不断地学习，不断地试错，就一定会有收获。 5、暂时的学习都是站在前人的肩膀上，感谢他们。 day5 学习总结： 1、这两天被作业折磨的受了内伤，真心感觉这次作业的难度大，太多不知道、不熟悉、不理解的概念、函数、逻辑…… 2、感谢在卡壳的时候教练和老师提供的帮助，很多时候就在一个坑里出不来了，原因还是概念不清晰。开始都搞不清楚还有列表、字符串、数组等等概念和差异，概念不清楚函数的使用就不可能对。在复盘学习的时候要加强概念的理解，多用、多试错才能更好的学习。 3、深刻体会到人生就是活在大脑的算法里，同样的问题解决可能有很多途径，同时也一定有一条最优、最简洁的路径就看你的知识储备和思维开阔的程度。 day6学习总结： 1.今天作业相对顺利，能够大概知道程序调整的方向。 2.还是要加强对于函数和概念的理解。 day7 学习心得： 1.今天作业在DAY6基础上进一步深化学习，没想到day6程序的坑在day7作业就是井，为了出井需要先出坑。自己原来的程序不能区分中英文，对于中英混合的列表就无法完成词频统计。在这个问题上纠结了一个上午，在教练的指导下，借鉴同学的程序才完善了自己程序的窟窿。。 2.在模块调用上开始也停住了，文件夹、文件、程序、函数的空间关系有些不清楚，停下来看了下书梳理出关系，问题迎刃而解。 day8 学习总结： 1.虽然作业都是在前一天的基础上逐步推进，但是感觉学起来还是有些吃力，对于函数的概念理解和使用方法不能够透彻理解，很难单独完成程序。每天拿到作业都是先学习知识点，再尝试完成作业，同时也发现如果按照这个路径作业完成就需要很长时间，甚至会拖延。看到其他同学能够短时间完成作业，很佩服他们同时也在思考自己的学习方法是不是有问题。希望同学们交流、指导。 day9 学习总结： 1.现在的情况是能够看懂简单的程序，在借鉴同学或者网络资料勉强完成作业。对于函数的使用规则和参数设置都不熟悉，要在作业中慢慢学习。这次主要是调用统计函数，怎样融合到自己的程序中花费了比较长的时间。 2.对于python的语言规则还要多看书多练习。 day10 学习总结： 1.今天作业在昨天的基础上学习了增加了第三方库的安装和使用，jieba.cut在默认状态下就是精准分词，只要在上次作业的基础上做简单微调，添加jieba函数就可以了。 2.在利用函数的同时，要注意参数的转换，列表转换字符串，字符串转换列表是时常都有也经常容易忽略。 day11 学习收获： 1.这次学习有两个比较耗时的问题出现，一个是VS Code在运行过程中自动退出，再登录时无法终端运营，并且程序中的问题也不能提示。试了很多办法，最后是重新下载安装Anaconda并且删除旧文件夹，才恢复了正常使用。第二个问题：发送邮件总是提醒下图中的问题，两天时间经过教练们的细致、耐心的指导下终于解决问题，感谢他们。 2.任何刻意练习都是要在练习中学会解决问题的能力。 day12 学习收获：参照学习资料，照猫画虎竟然成功登陆微信小号的网页版，还是有点小意外、小激动，没想到几行代码就能够实现这么多的功能，小惊喜。经过十几天的学习逐步对python有了一点点认识，还是很感叹计算机语言的魅力，就像人的思想一样虽在灯火阑珊处，它的作用做事随时可见的。计算机语言有内置参数，高手还可以自定义很多函数既能高效解决问题，又能时时看到自己的劳动成果输出，很美好，自己学习的路还有很长，希望自己能继续深入的学习下去。 day13 学习收获： 1.怀着激动、忐忑的心情迎接第13天的作业，在上次作业的基础上调用新的函数，输出柱形图。实际在完成程序的过程中还是不能够准确的使用函数。经过学习同学们的作业，才勉强看懂程序中的逻辑结构和函数使用方法。 2.感觉自己是在对照程序理解逻辑，还不能够梳理出自己的逻辑，用机器语言表达出来，即使是简单的功能，这种思维的转换还是不顺畅。 day14 学习感悟：1.走完Python的入口之旅，收获很多，最大的感悟就是自学是活在未来的必要路径，在学习的过程中有太多自己的障碍需要克服，在克服障碍的过程中不断的学习、成长。2.感谢在学习过程中给予帮助的辅导员、助教、教练，感谢给予帮助的同学们，感恩同行！]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>自学营</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010014-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010014-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：白头翁学号：1901010014 工作背景销售类 自我介绍大家可以叫我白头翁，从事销售类工作。 参见Python 训练营进阶课程，是因为想换个行业工作，因为的的确确这是个变化频率与幅度都在不断加大的时代，10年前我还不知道二维码是什么，但今天二维码已经成为了移动互联网的入口，现在出门带个手机就可以搞定许多生活事项，且2009到2019这10年技术发展非常快，移动互联网、云计算、大数据、人工智能、区块链…… 都在一步步影响着各行各业，与其将来被技术革命，不如现在趁年轻，相对有充裕时间和充足精力，去拥抱变化。 目前我在反复看《自学是门手艺》这本书，能看懂一些 Python 程序，但自己实际动手写个小程序还是很困难。 愿我们自学 Python 进阶训练营的同学们一起讨论问题，共同进步，用三个月时间让自己学有所获，用一年时间把自学这门手艺和数据分析能力磨练的很好，足够应对日常工作生活所需。一起加油！]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>销售</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901070038-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901070038-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名:张书忠 工作背景私募股权投资，主要从事股权投资工作 自我介绍金融行业从业者、Python初学者 为什么想学习数据分析我想学习数据分析有以下几点：1.我之前看了很多做IDC的公司，他们普遍说目前国内对于数据的分析和应用处于非常初级的阶段。我之前也没有研究过这个东西，所以就着这次机会去学习一下。2.目前自己时间相对比较多，也想找一件事情让自己不闲下来。而编程我感觉比较适合自学，自己学习的知识可以马上用电脑去实践，可以获得很好的反馈。3.我认为在编程的过程中可以很好的锻炼自己的思维方式，比如严谨的思维。 希望学完之后的应用场景学完之后的应用场景我还真的没有深入想过。目前能想到的就是，可以自己去编写一些程序，从而减少自己的一些重复性工作。 目前自己的学习阶段和疑惑我目前还处于学习了一些基本概念的阶段，并且这些概念也都是基本了解，还不能熟练的去运用。应该算一个初学者。目前最大的困惑就是如何很好的表达出自己所遇到的困难。比如如何比较好的搜索出自己所需要的函数。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>股权投资</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020015-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020015-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：李浩天，只接受三个正确的打开方式 —— 浩天、奇点、战友学号：1901020015 工作背景目前在 互联网+物流 领域深耕，说的高大上一点就是建设中国运输网络主干线。岗位性质更多的集中在经营分析、项目管理、战略研究三个方面 自我介绍一个类数据分析从业者、一个非资深物流人、一个追求成长速率的学生 学习目的最开始的原因其实很简单，想要拾起大学时学习的编程知识。这来源于两个基本诉求： 由于工作的性质，存在外部数据的采集需求，而IT资源又很稀缺，特别是在自己想要研究一些东西的时候。所以想要自己具备一些外部数据的获取能力，可以独立完成 数据爬取 另一个需求是来自于多方面的，想要自己的效率做进一步的提升，并且解锁更多的可能性。比如，工作中可以通过编程替代一部分Excel的工作，更快速的实现一些想法或者编写一个程序完成重复性的内容，脱离 “大表哥” 的困扰 那天我们沟通完之后，关于数据分析的发展方向，我在网上检索了一下，有一篇文章说的最讲究，文章说有四个方向： 业务数据分析(原文就直接叫数据分析，方便理解换了一个名字)：这类基本有两个主要任务：一个是业务数据体系化大白话来说就是业务指标体系的建立，一个是业务问题的解决比如为什么活跃用户数下滑增量放缓等。并且对于传统行业也会存在线下业务的规划包括选址等，会涉及到宏观数据，需要搜索及调研能力。这个岗位貌似说是最适合走向管理岗位的一个职位 数据挖掘： 看下来没有特别明确数据挖掘和数据分析的差别，给我的感觉是数据挖掘貌似更加理论化一些，涉及到模型的建立算法的应用。比如机器学习、协同过滤、关联规则、PageRank 等。在最优化问题的应用上，看到的例子是：外卖行业，如何寻找骑手效率最大化的最优路径 从问题解决的角度基本可以分为几个步骤：问题抽象-&gt;模型建立-&gt;线上部署。在岗位分工上面，问题抽象基本由数据分析完成，模型建立可以是数据分析也可以是数据挖掘，线上部署可以是数据挖掘也可以是数据工程。所以我大致的理解是数据挖掘和数据分析是一脉相承的关系而已，解决的问题难度不同 数据产品：这个现在有两种理解，一种是具备强数据分析能力的PM，一种是公司数据产品的规划者。前者以数据导向优化和改进产品，后者类似于产品经理，主要参与数据相关的产品项目：包括大数据平台、埋点采集系统、BI、推荐系统、广告平台等 数据工程：相对数据挖掘来说更倾向于更底层的工程实现和架构，很多工作是围绕 ETL / DW / BI 进行展开 综合看下来，评估了一下，自己现在应该只涉及到业务数据分析的工作，最开始的诉求也是希望在业务数据分析的路上走的更远一些。可这个并不妨碍那颗数据挖掘的心，关于数据挖掘这里当下有一个比较大的疑问，也希望后续可以得到解答，就是数据挖掘究竟可以解决那些类型的问题，它的边界又在哪里？ 最后特别想说一句感谢。因为最近的自己像是打开了一扇门，当编程、英语以及区块链一个一个迈入自己的视野，感觉自己的眼前像变了一个世界，特别深刻的感受到 “井底之蛙” 的感觉。也因此改变了很多自己的行为，曾经可以忍受的突然就忍受不了了，比如上不了外网 [捂脸笑] 追加一下： 这两天我看完了《自学是一门手艺》的一个链接文章 What exactly can you do with Python? ，就特别想提一个需求：在学习的过程中能不能更多的介绍一下Python在数据分析或者数据挖掘领域有哪些实际的应用场景]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>互联网+物流</tag>
        <tag>追求成长速率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1902100001-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1902100001-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王学闻 , 大家可以叫我学闻学号：1902100001 工作背景目前从事Java程序员工作(三年工作经验) 自我介绍我是一名在职的Java程序员 , 在这几年的工作中除了敲代码 , 看的最多的就应该是很多所谓的产品经理根据自己的并不实际的调查确定用户的需求 , 然后进行项目开发 , 结果开发的产品犹如石沉大海 , 然后……就没有然后了 . 作为一个底层业务的实现者 , 我深知这种现象在软件开发的普遍性 , 也知道在那些所谓的产品经理眼中用户 “应该” 有的需求是不对的 , 明白这些又怎样 ? 如果换我去做同样的工作 , 或许也会犯一样的难 . 也会一样淹没在无边无际的不确定性之中 . 我想这样的焦虑并不只有我一个人感受得到 . 然而大数据却能解决这样的问题 . 我们可以运用大数据思维去消除不确定性 , 利用它实现精准服务 , 它还能帮我们动态的调整做事策略 , 还能用它去发现未知规律 , 等等等等 . 能够做到让我们的分析更加贴近现实 , 我想大数据思维应该成为每一个有志于在未来数据大潮中过好日子的人的必修课 . 目前的学习阶段 , 初级]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>Java程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1902100002-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1902100002-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息 姓名: 苟利桥，当然也有叫大桥的，叫小桥的，等等。 工作背景 目前从事IT工程与运维项目的实施工作，主要是服务器存储以及华为云计算的实施交付于维护相关工作。 自我介绍 虽然岁数不大，30都还差点，但是一路走来一直在学习，从中受益匪浅，我以前大学毕业后是搞基础网络维护与个人pc电脑维保工作的，到后来的企业网维护，企业网IT维护，再到现在的企业网、运营商IT云计算维护。由于我本人背景并不好，所以从技术中获益的幅度更是十分的可观，总是有几句话一直觉得特别受用: 凡事有失有得有得有失，有些事情别人不愿意做的、累的、看不起的可能里面会有机会。 君子性非异也，善假于物也。下面再详述。 为什么想学习数据分析，希望学完之后应⽤在什么场景 这里接着说刚才那句话，像我们很多一线的工程师是骨子里是不乐意搞技术这个东西的，理由很简单就是不受用，性价比很低，毕竟学习技术研究技术非常的花精力，而实际的效益确并不好，这点我自己是深有体会，所以好多一线工程师实际上干的是业务的活，就是变相的搞销售拿提成，真有解决不了的问题，有二线，有研发支持，压根不需要自己花精力去研究。 交代一下背景，更加方便于自己阐述学习的动力和心态。本人一直在工程师岗位那么多年，深刻的认识到技术的重要性，概况起来就两个字效率。同样是做一个事情，我懂技术，我多会那么一些工具，在故障诊断上，工程交付上，思维逻辑上，完全能成指数级的方式改善自己的工作方式，大大提升效率，节约出更多时间来进一步加深扩充技术，从而实现良性循环，量变到达质变，接着而来的就是生活的改变。 话又说回来了，为什么要学习数据分析，是完全因为工作么？显然不是，显然我们工作对数据分析的依赖并不大。如上文讲到，技术改变了我分析问题，看待问题事务的逻辑，提供了我终身学习进步的可能，进而深刻的认识到当下时代从数据中获利的趋势必然会大于我通过工作时间来获利的可能。 好了，上文讲到我们想通过数据来获利，诶就是挣钱，不以挣钱为目的的学习技术那都是耍流氓。 那么我们学完后要干点什么呢： 当然学习数据分析只是我要干的事情中的一部分，就目前我最终想干的事情是通过爬虫、数据分析、信息论、离散数学等，建立一个股票等二级市场涨跌的交易模型，极大概率从中实现获利。 同时，还想通过数据分析，爬取与分析当下的电商平台，比如美团，淘宝，大众点评，链家等等平台的优惠信息以及其他商业价值信息，帮助实现获利决策模型。 最终目的就是从当前的通过完完全全的工作时间获利的模型中解脱出来，创造更多的可能，实现财务自由。 目前自己的学习阶段和疑惑 当然想干那么多事情，单纯只靠数据分析是远远不够的。所以还是要关注当下，沉下心来，一步一个脚印的前进，虽然看过很多书，懂得很多道理，但是我每天依然还是在做调系统、写代码。 因此当下依然还是处在通过代码来调优工作效率的阶段。不过已经能通过爬虫获取到海量数据，存储数据了，所以完全可以进一步进阶来分析这些数据，展现这些价值数据的时候了。 既然如此，那大家就一起共同加油，共渡剩下的阶段吧。 Fighting]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>IT工程运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE2]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020043 学习内容：MIT 6.0001 LECTURE 2 +Python 编程导论（第2版）（第2章的2.2-2.4） 学习用时：3.5小时 学习笔记收获总结： Spyder 快捷键 多行注释 Ctrl + 1 取消Ctrl+1 ；或者Ctrl+4块注释，Ctrl+5取消。 最简单的分支型程序是条件语句，if Boolean expression: ​ block of code ​ elif Boolean expression: ​ block of code ​ else: ​ block of code 缩进在Python中是具有语义意义的。Tab或四个空格不要混合使用。 条件语句可以嵌套；在检验条件中使用复合布尔表达式是非常方便的。 print()函数每个参数之间自动加空格。 +两侧都是数值对象时就是plus，两侧为字符串时，表示连接，没有空格。 +不能操作str和int；*可以操作str和int，变成重复操作符。 每行代码都要手动输入一遍，照着打都经常容易错。 需要程序多次做同一件事情的时候，可以使用迭代语句：while loops: while : ​ ​ ​ … for loops: for in range(): ​ ​ ​ … 遇到的难点与问题（是否解决）：对迭代语句的理解还很模糊，明天继续学习迭代语句。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet3(P1)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet3(P1)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 3 (ZIP) 打卡天数：D08 作业(Problem 1: Word scores):The first step is to implement a function that calculates the score for a single word. Fill in the code for get_word_score in ps3.py according to the function specifications. As a reminder, here are the rules for scoring a word: The score for a word is the product of two components: First component: the sum of the points for letters in the word. Second component: either [7 * word_length - 3 * (n-word_length)] or 1, whichever value is greater, where: word_length is the number of letters used in the word n is the number of letters available in the current hand You should use the SCRABBLE_LETTER_VALUES dictionary defined at the top of ps3.py. Do not assume that there are always 7 letters in a hand! The parameter n is the total number of letters in the hand when the word was entered. Finally, you may find the str.lower function helpful: 123s = “My string”print(s.lower())&gt;&gt;&gt;&gt; “my string” If you don’t know what this does you could try typing help(str.lower) in your Spyder shell to see the documentation for the functions. 作业心得这里有个2关键点： [7 * word_length - 3 * (n-word_length)]，如果计算值小于0，则 Second component 为1 一定要认真看 Introduction章节的Scoring部分，从中得知这道题是要计算 First component 和 Second componen 相乘的结果 要认真看 test_ps3.py 的 test_get_word_score 函数，参考这个函数可以知道如何测试 关键函数的理解deal_hand(n):该函数返回一个字典类型数据，包括 ceil(n/3) 个元音和若干个辅音与对应的次数，元音与辅音可重复 update_hand(hand, word):将存在 hand字典中 key 为 word 的元素删除并返回，但不修改原 hand 变量 学习的新函数： Python ceil 函数:向上取整; ceil() Python choice 函数: 从列表、元组、字符串中随机选择一个元素;choice 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361# 6.0001 Problem Set 3## The 6.0001 Word Game# Created by: Kevin Luu &lt;luuk&gt; and Jenna Wiens &lt;jwiens&gt;## Name : &lt;your name&gt;# Collaborators : &lt;your collaborators&gt;# Time spent : &lt;total time&gt;import mathimport randomimport stringVOWELS = 'aeiou'CONSONANTS = 'bcdfghjklmnpqrstvwxyz'HAND_SIZE = 7SCRABBLE_LETTER_VALUES = &#123; 'a': 1, 'b': 3, 'c': 3, 'd': 2, 'e': 1, 'f': 4, 'g': 2, 'h': 4, 'i': 1, 'j': 8, 'k': 5, 'l': 1, 'm': 3, 'n': 1, 'o': 1, 'p': 3, 'q': 10, 'r': 1, 's': 1, 't': 1, 'u': 1, 'v': 4, 'w': 4, 'x': 8, 'y': 4, 'z': 10&#125;# -----------------------------------# Helper code# (you don't need to understand this helper code)WORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # wordlist: list of strings wordlist = [] for line in inFile: wordlist.append(line.strip().lower()) print(" ", len(wordlist), "words loaded.") return wordlistdef get_frequency_dict(sequence): """ Returns a dictionary where the keys are elements of the sequence and the values are integer counts, for the number of times that an element is repeated in the sequence. sequence: string or list return: dictionary """ # freqs: dictionary (element_type -&gt; int) freq = &#123;&#125; for x in sequence: freq[x] = freq.get(x,0) + 1 return freq# (end of helper code)# -----------------------------------## Problem #1: Scoring a word#def get_word_score(word, n): """ Returns the score for a word. Assumes the word is a valid word. You may assume that the input word is always either a string of letters, or the empty string "". You may not assume that the string will only contain lowercase letters, so you will have to handle uppercase and mixed case strings appropriately. The score for a word is the product of two components: The first component is the sum of the points for letters in the word. The second component is the larger of: 1, or 7*wordlen - 3*(n-wordlen), where wordlen is the length of the word and n is the hand length when the word was played Letters are scored as in Scrabble; A is worth 1, B is worth 3, C is worth 3, D is worth 2, E is worth 1, and so on. word: string n: int &gt;= 0 returns: int &gt;= 0 """ word = word.lower() first_component = 0 for letter in word: first_component += SCRABBLE_LETTER_VALUES[letter] second_component = 7 * len(word) - 3 * (n - len(word)) if (second_component &lt; 1): second_component = 1 return first_component * second_component # "it" 7*2-3*(7-2) = 14-15 = -1 # "was" 7*3-3*(7-3) = 21-12=9+6 # [7 * word_length - 3 * (n-word_length)] # pass # TO DO... Remove this line when you implement this function## Make sure you understand how this function works and what it does!#def display_hand(hand): """ Displays the letters currently in the hand. 显示当前手里的字母 For example: display_hand(&#123;'a':1, 'x':2, 'l':3, 'e':1&#125;) Should print out something like: a x x l l l e The order of the letters is unimportant. hand: dictionary (string -&gt; int) """ for letter in hand.keys(): for j in range(hand[letter]): print(letter, end=' ') # print all on the same line print() # print an empty linedisplay_hand(&#123;'a':1, 'x':2, 'l':3, 'e':1&#125;)## Make sure you understand how this function works and what it does!# You will need to modify this for Problem #4.#def deal_hand(n): """ Returns a random hand containing n lowercase letters. ceil(n/3) letters in the hand should be VOWELS (note, ceil(n/3) means the smallest integer not less than n/3). Hands are represented as dictionaries. The keys are letters and the values are the number of times the particular letter is repeated in that hand. n: int &gt;= 0 returns: dictionary (string -&gt; int) """ hand=&#123;&#125; num_vowels = int(math.ceil(n / 3)) for i in range(num_vowels): x = random.choice(VOWELS) hand[x] = hand.get(x, 0) + 1 for i in range(num_vowels, n): x = random.choice(CONSONANTS) hand[x] = hand.get(x, 0) + 1 return hand## Problem #2: Update a hand by removing letters#def update_hand(hand, word): """ Does NOT assume that hand contains every letter in word at least as many times as the letter appears in word. Letters in word that don't appear in hand should be ignored. Letters that appear in word more times than in hand should never result in a negative count; instead, set the count in the returned hand to 0 (or remove the letter from the dictionary, depending on how your code is structured). Updates the hand: uses up the letters in the given word and returns the new hand, without those letters in it. Has no side effects: does not modify hand. word: string hand: dictionary (string -&gt; int) returns: dictionary (string -&gt; int) """ pass # TO DO... Remove this line when you implement this function## Problem #3: Test word validity#def is_valid_word(word, hand, word_list): """ Returns True if word is in the word_list and is entirely composed of letters in the hand. Otherwise, returns False. Does not mutate hand or word_list. word: string hand: dictionary (string -&gt; int) word_list: list of lowercase strings returns: boolean """ pass # TO DO... Remove this line when you implement this function## Problem #5: Playing a hand#def calculate_handlen(hand): """ Returns the length (number of letters) in the current hand. hand: dictionary (string-&gt; int) returns: integer """ pass # TO DO... Remove this line when you implement this functiondef play_hand(hand, word_list): """ Allows the user to play the given hand, as follows: * The hand is displayed. * The user may input a word. * When any word is entered (valid or invalid), it uses up letters from the hand. * An invalid word is rejected, and a message is displayed asking the user to choose another word. * After every valid word: the score for that word is displayed, the remaining letters in the hand are displayed, and the user is asked to input another word. * The sum of the word scores is displayed when the hand finishes. * The hand finishes when there are no more unused letters. The user can also finish playing the hand by inputing two exclamation points (the string '!!') instead of a word. hand: dictionary (string -&gt; int) word_list: list of lowercase strings returns: the total score for the hand """ # BEGIN PSEUDOCODE &lt;-- Remove this comment when you implement this function # Keep track of the total score # As long as there are still letters left in the hand: # Display the hand # Ask user for input # If the input is two exclamation points: # End the game (break out of the loop) # Otherwise (the input is not two exclamation points): # If the word is valid: # Tell the user how many points the word earned, # and the updated total score # Otherwise (the word is not valid): # Reject invalid word (print a message) # update the user's hand by removing the letters of their inputted word # Game is over (user entered '!!' or ran out of letters), # so tell user the total score # Return the total score as result of function## Problem #6: Playing a game### procedure you will use to substitute a letter in a hand#def substitute_hand(hand, letter): """ Allow the user to replace all copies of one letter in the hand (chosen by user) with a new letter chosen from the VOWELS and CONSONANTS at random. The new letter should be different from user's choice, and should not be any of the letters already in the hand. If user provide a letter not in the hand, the hand should be the same. Has no side effects: does not mutate hand. For example: substitute_hand(&#123;'h':1, 'e':1, 'l':2, 'o':1&#125;, 'l') might return: &#123;'h':1, 'e':1, 'o':1, 'x':2&#125; -&gt; if the new letter is 'x' The new letter should not be 'h', 'e', 'l', or 'o' since those letters were already in the hand. hand: dictionary (string -&gt; int) letter: string returns: dictionary (string -&gt; int) """ pass # TO DO... Remove this line when you implement this functiondef play_game(word_list): """ Allow the user to play a series of hands * Asks the user to input a total number of hands * Accumulates the score for each hand into a total score for the entire series * For each hand, before playing, ask the user if they want to substitute one letter for another. If the user inputs 'yes', prompt them for their desired letter. This can only be done once during the game. Once the substitue option is used, the user should not be asked if they want to substitute letters in the future. * For each hand, ask the user if they would like to replay the hand. If the user inputs 'yes', they will replay the hand and keep the better of the two scores for that hand. This can only be done once during the game. Once the replay option is used, the user should not be asked if they want to replay future hands. Replaying the hand does not count as one of the total number of hands the user initially wanted to play. * Note: if you replay a hand, you do not get the option to substitute a letter - you must play whatever hand you just had. * Returns the total score for the series of hands word_list: list of lowercase strings """ print("play_game not implemented.") # TO DO... Remove this line when you implement this function## Build data structures used for entire session and play game# Do not remove the "if __name__ == '__main__':" line - this code is executed# when the program is run directly, instead of through an import statement#if __name__ == '__main__': word_list = load_words() play_game(word_list)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901030012-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Cat学号：1901030012 工作背景地产、能源与自然资源领域涉外法律服务从业超过13年 自我介绍 自我介绍: 本人叫王露萩，朋友都叫我Cat。中国和美国加州执业律师。实际心理年龄只有4岁8个月左右，对世界开启了好奇心。我可以使用中文、英文。在学习使用Python和日文。 为什么想学习数据分析：不明白数据是什么，想知道现在所指的”数据“都是如何产生的、可以如何搜集、又是如何被分析的。数据分析本身是怎么被应用的。 希望学完之后应用在什么场景： 1 学完后搞明白自己的数据都可能有什么，是怎么被别人搜集、分析和使用的，然后自己好好学习一下怎么使用数据分析了解自己。 2 自己能编写脚本实现各国司法案例数据库内捕捉自己需要的关键词相关数据的功能。 目前自己的学习阶段和疑惑： 1 学习阶段：14天Python入门营毕业，MIT6.0001课程学习文稿到lecture8文稿的p12.（练习题做到 psets 1 part A） 2 疑惑： 4.2.1 语言概念定义的关联，范畴，暂时还没有梳理明白； 4.2.2 看见数字和图表内心深处阴影面积暂时还是会产生巨大压力影响自己的学习动作变形。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>里程</tag>
        <tag>起点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020008-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020008-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王娟芳 【同事叫我芳芳（年龄小的叫芳姐)，大家也可以这么称呼我(✿◡‿◡)】学号：1901020008 工作背景数智校园整体方案解决服务商 自我介绍大家好！作为新兴互联行业与传统教育业的结合体这样一个行业，关于大数据，关于AI，这些前端科技都在时时刻刻影响着我们。 作为商家，一定要成为两个行业的专家才能把路越走越宽。 作为企业主，势必要更快更好的学习，成长，才能不被淘汰。 作为个人，脑中没有对未来清晰的预见，只能让焦虑占据 而作为两个孩子的母亲，教给孩子什么，让孩子走什么样的路，脑子里没有清晰的概念也是不可行的。 关于为什么学习数据分析，我脑中没有一个清晰的定义。一开始进训练营的考虑是：这个世界有方法论，我想找到适合我的，切实可行的方法改变自己无一技之长的现实。后面觉得必须继续学习才能成为一技之长。 现阶段，我只坚定的相信一切都可以通过学习改变。随着学习的深入，也许可以帮我快速入门互联网行业应用于教育界。也许可以帮我理清脑中模糊的人生规划，也许能更清楚地看到未来，给孩子更好的教育。也许还会有更多意外的收获……]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>数智校园</tag>
        <tag>孩子母亲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050035-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050035-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：老罗学号：1901050035 工作背景网络维护和管理 自我介绍我是老罗，在广州工作，日常负责网络运行和维护管理工作。工作的老兵，编程的新手，很高兴有机会和大家一起参加数据营学习数据分析和处理，提高工作的效率和自我价值。 ####【为什么想学习数据分析，希望学完之后应⽤在什么场景】 工作20多年，大部分时间以通过系统出告警或用户投诉等传统的方式，来处理网络出现的故障或隐患，工作非常被动；而且随着网络的快速大规模的扩容，现有的人手和手段非常缺乏和落后，希望通过计算机自动收集日志和性能统计数据，分析和评估当前网络运行的状态，以实现对网络运行中的故障自动快速的定位和容量主动精准扩容。 ####【当前的学习阶段和疑惑】 前期参加了自学训练营，初步掌握了Python的程序的运行和基本函数规则等，后续希望通过本期数据营，学会和掌握一套数据分析和处理工具，支撑日常工作，实现对网络系统运行的自动采集、统计和分析，提高管理效率。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>网络维护和管理</tag>
        <tag>编程新手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901070004-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901070004-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：小黎学号：1901070004 工作背景目前工作和普惠金融相关，涉及寻找客户，扶贫贷款发放回收，也涉及社区工作，培养客户良好的卫生健康习惯，普及理财知识等。 自我介绍为什么学习数据分析： 计划从事数据分析工作。 希望学完后应用到什么场景： 可以在新工作中灵活运用学习到的技能，而且可以很好的完成项目，成为一个优秀的数据分析师。 可以迁移分析问题解决问题的能力，让自己成为一个能独立思考的人。目前自己的学习阶段和困惑：完成了自学营初级阶段的学习，MIT的课程还在理解实践中。比较初级。困惑是遇到问题，不知道怎样高效的解决它，怎样使用编程语言去解决问题，不知道背后的思考方式，还有学习到的思考方式怎样落地。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>普惠金融</tag>
        <tag>社区工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010061-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010061-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Music学号：1901010061 工作背景会计 自我介绍我是一名90后南方人，从事玩具行业.为什么想学习数据分析：我对数据分析是没有接触过的，从自已的理解角度，数据分析的作用应该是收集数据信息，然后信息分析，帮助自已作出一些决策判断。我们是处在信息发达的环境，如何取得高质量的信息并学会分析学习。学习数据分析是利大于弊的。学后应用场景： 生活与工作中能使用数据分析来优化决策。学习阶段和疑惑：在几个月前参加了训练营，通过自学，初步认识了python。学完之后，感觉还是有些懵，感觉学完容易忘，不会灵活使用。之后进入到MIT的学习，重新思考了学习这件事情（为什么我学习后的知识容易忘，我应该怎么做，有什么学习方法是适合我的），通过看学习相关的书箱、网上找资料，找到了合适自已学习的方法，目前正在适应中。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>会计</tag>
        <tag>玩具行业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-自学训练营-MIT60001-DAY1]]></title>
    <url>%2FMIT60001%2F1901020043-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT60001-DAY1%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020043 学习内容：MIT 6.0001 LECTURE 1 +Python 编程导论（第2版）（第1章+第2章的2.1） 学习用时：4小时 学习笔记收获总结： Computers only know what you tell them. Computers only do what you tell them to do. 计算机能且只能做两件事——执行计算与保存计算结果(perform calculations and remember results)，但它把这两件事做到极致。 计算机思维： 七种关系：1.大和小 2.快和慢 3.多维度和单一维度 4.网络和个体 5.自顶向下和自底向上 6.全局和局部 7.成本和表现 两个原则：1.等价性原则 2.模块化原则 ——（吴军的谷歌方法论） 算法：是一个有穷指令序列，描述了这样一种计算过程，即在给定的输入集合中执行时，会按照一系列定义明确的状态进行，最终产生一个输出结果。（简单步骤，控制流，何时结束） 通用图灵机：可以接受任意一个图灵机 M 的编码 ，然后模拟 M 的运作。 邱奇-图灵论题：任何在算法上可计算的问题同样可由图灵机计算。（如果一个函数是可计算的，那么一定可以通过对图灵机进行编程实现这种计算。） 停机问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。 图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完备的。图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”,所有现代编程语言都是图灵完备的。 每种编程语言都有基本结构、语法、静态语义和语义。 Python的基本结构包括字面量和中缀操作符；语法定义了字符和符号组成句子的正确形式；静态语义定义了哪些语法有效的句子是有意义的；语义为每个语法正确又没有静态语义错误的句子关联一个含义。 程序如果没有正确运行，就应该表现出明显的错误。只要有可能，我们都应该以这种方式编写程序。 对象是Python程序处理的核心元素。Python有4类标量对象：int，float，bool，None 在Python中，变量仅是名称，没有其他意义（非常重要）。变量名可以包含大写字母、小写字母、数字（不能以数字开头）和特殊字符_，变量名称大小写敏感，保留字不能做变量名。 恰当的选择变量名和添加注释是提高程序可读性的好方法。 总结：看英文字幕虽然很难但是不会像中文字幕令人不舒服；明确计算机的边界，能做什么，不能做什么；学习计算机思维的相关知识很重要，得到有很多文章讲解，应该再看一些相关书籍；个人偏好一些概念的认真理解，会额外耗费很多时间，是否有用在以后的学习中会验证；养成好的编程习惯，先从变量名和注释开始；多输入代码，刻意练习的技巧可以考虑如何用在这里。遇到的难点与问题（是否解决）：对停机问题的理解还不够，先放放，过一周再看。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020043-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：金志坚学号：1901020043 工作背景医药行业，从事营销推广工作 自我介绍今年42岁，除了日常的管理工作所需，最想学好的就是英语和编程，一法通万法通，通过学习编程提高自己的自学能力，希望能保持终身学习的能力，也希望能给员工展示一切皆有可能，年龄不是问题。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>营销推广</tag>
        <tag>年龄不是问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090043-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901090043-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：姜翔学号：1901090043 工作背景在上海从事过医药行业，金融期货行业，目前在家大部分时间学习，小部分时间在老家江西开发业务 自我介绍 我叫姜翔，之前从事过医药，金融行业，目前在老家有个办公室，生意一般，想寻求其他方面的突破。 之前有点编程基础，不想抛掉这门手艺，想重新拾取，加上Python的强大，高效，对数据分析，人工智能也有兴趣，而在这两个方面Python都有一定的优势。俗话说艺多不压身，也是想离校之后重新系统的学习一门课程，增强自学的信心，这很重要。 毕业到目前为止已有7年了，时间转瞬即逝，比起无聊的社交，真正用心的沉浸在一门手艺当中，这是让时间眷顾的最好方法了，每天坚持，沉浸其中，你会发现日子似乎过的没那么快了，心里获得的充实感和安慰是巨大的，我想每个成人都应该长期保持这种状态。而编程是比较容易获得所谓心流体验的，这是编程作为热门自学课程的原因之一。 我想了下，入门这么多年，应该是已经入门了，入门学习的最核心的字符串、整数类型、浮点类型、函数、类、模块、DIG、复杂度和数据结构都有一定的掌握，希望在之后进阶路上进一步加强理论和实践，做到不断挑战高要求，不断进步。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>自由职业者</tag>
        <tag>金融销售业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901060005-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901060005-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：代智国学号：1901060005 工作背景企业经营者 自我介绍我叫代智国来自深圳，2002年大学毕业，2004来到深圳，恍恍惚惚，蓦然回首已经在深圳生活了15年。10年前开始创业，现在是一名中小企业老板，从事餐饮食材贸易，开设连锁餐厅。团队的慢慢成熟，自己的自由时间相对宽裕一点，有时会迷茫、焦虑甚至迷失。未来是什么样子？现在的自己能够适应未来吗？怎样才能更好的读懂未来、适应未来。。。。。。通过一个线上学习APP订阅了笑来老师的《通往财富自由之路》，对自己的很多认知有了很大的触动和颠覆。追随笑来老师来到了Python自学营，下定决心挑战自己。想到笑来老师说过： 你原本有机会，却因为害怕羞耻而放弃…… 最终，你一无所成，当然应该羞耻。 为了不让自己一无所成，要坚定也坚持的将Python学习进行到底。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>中小企业老板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050081-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050081-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：QQ学号：1901050081 工作背景待业（无特定行业） 自我介绍作为一名 80 后待业大龄女青年，学习编程是为了使自己更快的适应巨变的社会，获得一个长期奋斗的方向。再选择数据分析作为进阶学习，以求先掌握一门技术作为谋生手段，并学会如何透过现象看清本质，在数据中获得最有价值的信息，不被表象迷惑，做出最有利于自我的长远决策。期望可以通过不断打磨自己的技艺，靠自己的双手过上自己喜欢的生活，由自己掌握的时间和节奏，不再活在别人设定的框架中。 目前学习阶段和学习困惑现阶段已经完成了入门训练营和 MIT 视频公开课的学习，还在继续了解 Python 的语言特性。不知道初高中数学都丢光了，数据分析能学得好吗？是不是先学会爬虫，再学习数据分析师会好一些？还是直接挑战数据分析师呢？要系统的学习，还需要学习哪些课程会更好呢？]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>待业大龄女青年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自学训练营学习7群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901050119-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A07%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[姓名：王银/Galaxy 学号：1901050119 学习内容：Python 14 天入门 学习用时：46.5h 每一个概念都不简单，“自学”更是如此经验基础先介绍一下我的个人经验基础。在填课前问卷的时候，我选的是学过一种语言，做过demo程序。其实，选这一项只是因为没有更贴切的选项。其实我学过好几种语言，只是没有一种达到精通的。 我很早就对编程感兴趣，然而，这个“早”只是相对的，事实上发现的有点晚，高考填志愿的时候我执拗地选择了物理专业，而后才发现新大陆……那又怎样，我是兴趣驱动型的，我要自学编程，我要考研转专业……所以，从本科开始学C语言，我就把学校发的清华那本教材翻来覆去学了很多遍，当时根本没想到可以多买几本书对照着看，直到后来参加工作用C语言写代码，也没想着添置新的参考书。不知道自己不知道的时候，真可怕！ 后来，我又执拗地按照自己的意愿行事，考了电路与系统专业的研究生，离计算机近了些，然后利用实习的机会，又自学C++，当然有“同事老师”可以咨询，学的应该还凑合，因为，当我应聘软件工程师的时候，如愿拿到两份外企的Offer，一个是北京的C++语言，一个是西安的C语言。后来，我去了西安的公司。大家做的不是从无到有的工作，只能算作模块化编程吧，在原有代码的基础上增添、修改功能，不需要自己搭建编程环境。所以，我那一本教材上的内容也够用了，因此也没长出新的本事，没有被迫学会整套技能。后来，也学了一些html、css、C#，但都比较肤浅，没有走得很远。究其原因，还是自己的操作系统太陈旧，而又不知道可以升级造成的。 查漏补缺那份工作持续了４年多，我辞职回家了，一边带孩子一边瞎折腾。直到《自学是门手艺》又让重新点燃了我的编程热情。这一次，不为给别人打工，就想掌握这门手艺，为己所用。 早在3月份我就报了自学训练营，因为自己本来自由时间就不够充裕，担心无法在规定时间内配合作业学完书上的内容，而且对于搭建环境不太擅长，所以特意选了比较靠后的班次，给自己留足时间去攻关。可是，学而不用、学而不练，加上学习时间不紧凑，总是前学后忘，所以，直到开营一本书还是没有完整通读下来。 我用亲身经历证明，搭建环境真的非常摧残信心！我在开营前专门留出四五天时间通关，耗费很多精力，折磨死大批脑细胞……所幸最终基本上突围成功。正因为经历了这般艰辛的未雨绸缪，自学营前两天搭建环境和熟悉工具的作业才得以“轻松”完成，也算是对之前职业生涯的查漏补缺。 在训练营学习和自己死磕的最大区别就是，这里针对每一个难点，都有对应的文档资料可以参考，你不必大海捞针碰运气，不用一头雾水干着急，顺着图例的指引前进就对了，再不行，还有战友可以交流，实在搞不定，还有教练指点迷津……总之，再也不用冤死脑细胞，你一定能一路走下去……从这个角度望过去，我之前的“未雨绸缪”多少有点惨烈。如果再给我一次重新选择的机会，我宁愿不要那么“睿智”。 因为前期已经花了大量时间来搭建、配置环境，遇到的问题基本上已经解决了。所以Day2作业的主要时间都用来学习文档。之前毫无头绪地照着书上的指示配置，成功了就庆幸，失败了就焦急，根本不知所以然，心里完全没底。 回过头来学习文档，思路逐渐清晰，明白了那些命令的含义，最重要的是，知道了如何按需配置，终于从苍蝇模式过渡到蜜蜂模式。由此深刻体会到，参加训练营的最大意义，其实就是面对陌生地形，可以直接获得精准图例，迅速了解全貌。跳过苍蝇模式，直接开启蜜蜂模式，然后，循着光飞过去就是了。 基础知识应用回过头来看，自学营的整个作业体系设计得很精巧。先是熟悉工具、搭建环境，然后从打印一个最简单的“Hello World!”开始，让大家通过实现一个个简单而完整的功能把Python用起来，然后选取一个很实用主题层层递进。让大家亲身体会同样一个功能，如何一步步扩充、一步步改进，从简陋到完善，从笨拙到讲究，一步一步见证成长。 Day3看文档差不多花了5个小时，感觉实现计算器的逻辑应该很简单，本来想独立完成，但是，对Python的编程规则还不太熟悉，而且太久没写代码了，真的要动手时，居然又无从下手。真切感受到从0到1的艰难，于是Google了一个范例，又参阅了一位学友放在issue里的代码，总算可以下笔了。 先大概写出核心功能，然后不断尝试优化，这个过程中渐入佳境。因为工具用的不熟练，Jupyter lab和VS两边交替调试，走了不少弯路，不过，功夫不负有心人，最后终于实现了自己比较满意的效果。 Day4看文档1小时，独立写代码并调试1小时，感觉越来越得心应手。虽然还不能一气呵成，但是已经知道各种困惑应该去哪里查资料，进而顺利解决问题，每天都感觉到进步。 Day5深刻体会到在用中学和单纯用眼睛“学”的巨大差异了。看书的时候，感觉努努力都能看得懂，似乎明白该怎么用了。但是要写代码的时候，根本不是信手拈来啊，反复来回不停地翻文档，每一遍都有新收获。文档解决不了的问题，就问Google，总有前人留下的足迹，任何时候都不孤单。 Day5的任务知识覆盖面比较广，需要融会贯通，交叉使用，感受到了不同概念之间是如何产生联系的，终于体会到为什么笑来老师说《自学是门手艺》是《通往财富自由之路》的实践版了。 完成Day6作业之前，先把字符串相关内容仔细复习整理了一遍，认真做了笔记，又发现了不少仅仅靠阅读没能深入理解的内容，眼过千遍不如手过一遍！做作业倒是没用多少时间，但是感觉程序通用性不强，暂时却无力改进。后面很多内容还没看，温故知新，一步一个脚印，慢即是快。 Day7作业距离上次时间间隔有点长，因为我之前一直没能把书看完。第一部分好不容易看完了，到后面看着看着感觉前面的内容已经没什么印象了，所以，这次趁着边用边学，及时做笔记，让看过的内容都连贯起来。用纸笔记笔记收获很大。 本以为Day8的作业很简单，结果做的过程中困难重重。对于错误和异常的触发机制、对应的分类以及处理方式理解太粗浅，搞得自己摸不着头脑，乱试一通，代码编辑器用的也不熟练，加了断点忘记取消了，多亏教练指点，思路终于逐渐清晰，这只是个开始，目测前面埋伏还很多…… Day9大部分时间花在打开并读取json文件上了，查了很多资料，也浏览了学友们的作业，怎么试都不行。我也曾怀疑文件是空的，但是Windows无法直接打开，我又不知道也没想到用vscode就能打开json文件，结果文件果然是空的，我却以为是出错了，白费了很多功夫。经教练指点，终于顺利完成作业。感悟：对行家来说的常识，往往却是新手凭一己之力无法逾越的坎儿。这个好像不好补～ Day10作业耗时最多的地方其实是上一次隐藏的一个bug，只不过没影响到结果，所以没有发现。上次替换无用字符的时候，对于数字字符，想要进行统一处理，用这样的语句 if text[i] in range(1, 321) 跳过，不加到字典里。 今天采取同样的方法，没有得到预期效果，很纳闷，调好了很久，终于发现症结，其实文档里面的数字都被识别为字符了，那句代码根本没起作用。最后，还是老老实实继续用很笨的方式解决问题。 消化这本书感觉就像探索社会主义道路一样曲折，前进中还会有反复、还会有倒退。分明看的时候好像都懂了，但是走着走着，知识点之间串联不起来了，因此举步维艰，感觉只是把眼前的文字识别出来毫无意义，就只好从头来过。但是，仅靠眼睛形成的记忆是靠不住的，反复忘，太不牢固。直到开始用纸笔做笔记，之前与之擦肩而过的、想当然的一些知识点终于理解到位了。虽然只是把书上的很多内容抄到本子上，但是这个过程就是很神奇，收获的是仅靠阅读无法达到的高度。 生活场景拓展从Day11开始用真实场景演练了，之前只是人造应用场景。这两天的作业主题选取的是用机器人管理微信消息的应用场景，不能再贴近生活了！就像在试卷上答题和将所学应用于实践解决实际生活问题的区别一样，难度不是一个数量级了。如果没有作业单上的代码示例，只看文档是没法完成任务的，网上也很难找到合适的例子。 DAY12作业虽然已经提交，但是还有点疑惑。感觉实践作业不像之前的基础作业，做完了确实就知道是怎么回事儿了。实践作业如果没有参考根本完成不了。在一个项目文件里搜寻所需的零散信息，然后拼装起来实现一个完整而具体的功能，又一次手足无措。我们缺失的是什么，如何弥补呢？全面阅读文档，归纳、总结、融会贯通的能力不是一朝一夕练就的，但只要坚持、反复实践，总有功成的一天。 Day13作业又拖了好久，也没刻意计时。多多少少心里有点抵触情绪，感觉怎么看文档都只是一知半解，不如前面的基础作业有成就感，所以积极性不高。 最终下定决心照着教程把代码敲出来，因为之前看过文档，多少理解了一些，再自己敲一遍确实比只用眼睛看理解更深刻了。还有些不够明朗的细节留着以后慢慢消化吧。 由图例到实地曾经，我也是个“弄潮儿”，看不上的老师，怕被误导，上课睡觉，下课自学，成绩也还不错。所以，我以为自己很擅长自学并引以为豪，直到见识了自学高手的境界，才意识到自己所谓的“自学”只不过是很初级的阶段，前方还有很长的路要走，我却以为已经到达目的地了。这认知简直太误人了。 14天的训练营虽然要告一段落了，但这只是个起点，才刚刚学会看图例而已，千里之行只迈出了第一步。下一步继续研读《自学是门手艺》，随时查阅官方文档，进行关键知识点的总结、归纳、整理、组织，不断完善更新，直至刻在脑子里。同时不间断地练手，必须学以致用，否则只能永远停留在纸上谈兵的水平。 实地考察更有趣、更挑战、更刺激。手握地图，至少不会误入歧途。再出发，已经不是独自开荒了。路径清晰、路标醒目，就连远处的风景都依稀可见…… 如果说用代码实现一个计算器、一个九九乘法表什么的，对我们的生活改观并不大，那么写段代码管理微信消息，是一件多么高大上又体面的事情啊！微信几乎是每个人生活的一部分，不难想象，精通Python将如何改善我们的日常生活……用个不那么恰当的比喻：手里拿着锤子的人，看什么都是钉子。掌握一项技能就是拥有一种工具，用得顺手了，就停不下来了……期待那一天早早到来！]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050017-自学训练营学习4群-PYTHON入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901050017-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A04%E7%BE%A4-PYTHON%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 姓名：王晓镜 学号：1901050017 学习内容：14天python入门营 学习用时：40小时 学习笔记我选择的是预约制学习，可以自己学完一次作业以后马上申请学习后面的作业。 训练营带给我的 训练营的每日作业都会迫使我主动思考，逼迫我一字一句去阅读要求，不按照要求做就会完不成作业，强制改正了我阅读不仔细的问题。 社群式学习。不是单打独斗地面对困难，‘恐惧未知’这条恶龙不会在大脑中盘旋很久，因为有教练和同学在帮助着我，即使偶尔会深陷泥沼，只要我呼喊，他们就会立刻施于援手。学习效率大大提高。 养成了阅读官方档案的习惯。这一点非常重要，每天的作业都会给出官方档案的链接，在群里大家也会互相提醒，随时巩固这个好习惯。 学会了程序员思考，遇到难点，学会把它分成一小段一小段来解决，并且用自己熟知的知识尝试类比来解释给自己听。 深刻地认识到了借鉴优秀程序员的智慧结晶是非常重要的，有质量的输出的前提是要有质量地输入，如果能看懂优质代码，并为己用，这本身就是一种进步。 千里之行，始于足下—-训练营第一天 day1-day2作业完成自学训练营最能反映学习中不好的习惯。 收到“自学任务清单”，开始学习。清单表达的很清楚，但真的就是我看不见它，它一直在那里。清单里要求先看参考资料，我愣是自动掠过这一步，现在想来，真的是很佩服我的大脑，就这样习惯性地怕麻烦，找捷径，试图略过一切，然后还妄想能快速完成作业。 我在卡壳以后，冷静了下来，重新从清单1开始看，耐心地看了参考资料，认真地对待每一句话，这样竟然神奇地解决了每一个问题。这次我认识到想要解决问题，还是得克服自己的毛病。在做作业时，踏踏实实。 因为习惯不好，没有阅读官方文件。在一个小到不能再小的步骤上卡壳了1个小时。 在查看社群其他人的聊天中，找到了解决方案，在第一天截止时间前完成了第一天的打卡。 好久没体会过沉浸的感觉了，就是那种猛一抬头，一个小时过去了。 第一天的学习让我认识到想要解决问题，还是得克服自己的毛病。在做作业时，要踏踏实实。 纸上得来终觉浅，绝知此事须躬行—-训练营第二天 day3-day5作业完成看到群里的同学都在陆续地交作业（社群学习的好处，时刻督促自己），我停掉了“自我攻击的剧情”，心里开始接受一件事，那就是遇到不会的问题时是正常的，不久的将来一定会熟练掌握的。于是，心理突破了，脑子和手并用，完成作业的速度就提上来了。再加上，我不再以借鉴代码为耻，目的就是为了学习，我再借鉴的基础上再加上自己的理解，现在已经能够写出代码的一大部分了。自主学习加同学间互助式学习，具像化了李笑来老师说的： 很多人有莫名其妙的误解，以为“自学”（self-learning)就一定是“自己独自学”（solo-learning)，殊不知，自学也需要社交。 别怕！ 啥也别怕！没什么可怕的！ 收获总结： 学会了抄代码。不再谴责自己没用，心安理得地抄了三种代码，然后运行，改写代码，最后改写出了自己的代码。 敢于调试，以前总是怕出现问题，手心冒汗，后背冒汗，脑袋发麻，如今出现问题我就搜索问题是什么意思，然后冷静地去想办法解决。 学会去github里的issues找问题答案。 读书破万卷，下笔如有神—-训练营第三天 day6作业完成收获总结： 行之有效的方法就是大量阅读官方资料，因为是社群学习+github分布式交作业，所以可以看到很多同学的代码。学习+模仿，是我在3天时间内完成day1-6的任务的秘诀。输入有质量才是最好的进步方式。 读书不觉已春深，一寸光阴一寸金—-训练营第四天 day7-day10作业完成写python代码，做有用之事。在第四天，完成到了训练营day10的任务。 收获总结： 因为这几天的学习，让我深刻体会到了废寝忘食、孜孜不倦、目不转睛、聚精会神、茶饭不思的境界，心流时间可以达到3、4个小时不间断。 对阅读更是有了新的体会：一字不落的读，来回反复地读，不躲避，不放弃，迎着困难读。 对官方文档更加看重，对google也更加依赖，李笑来老师说的好： 学习任何东西，首先看官方文档或产品说明书，那些学习高手都是会先阅读官方文档的人。 能google出答案的问题，就不需要去麻烦别人.google、stackoverflow、wikipedia、youtube这都是自学人经常要去搜索的好地方。 千里之行，始于足下—-训练营第五天 day11-day12作业完成 眼是懒汉，手是好汉不怕，一点也不可怕，不难，一点也不难。 在这天，我清楚地感受到今天不想做作业地心情，抵触、逃避、恐慌、焦虑。。。。。。因为预知了困难，提前看GitHub 上的issues里都是关于day11作业的困惑和疑问，心里多少有些抵触。但是我知道只有做了才能解决，而不是空想。逃避没有任何用，把任务分解，一句话一句话地去实施。 随着着手敲代码的开始，这一天没有想象中困难，最后完成了day11-12的任务。 收获总结： 深刻理解了，写代码如同搭积木，一个函数如同一块乐高积木，只要一块一块加上去，就具像化了自己的目标。 一直听说python爬虫技术，今天终于得以实施，抓去了张小龙的演讲稿并做了处理，返回了邮件。 一直听说微信机器人，今天又亲自实施，和微信好友互动有无，她给我文章，我给她文章的数据，是自动的哦。 这次我好像真的很可以确信，学python不会再半途而废了，也许日后如同excel一样，用的机会越来越多了。 咬定青山不放松—-训练营第六天 day13作业未完成距离上一次提交作业已经过了两天，因为这次遇到了问题。求助issues和助教，还是未能解决。matplot绘制图表在我的电脑中显示不出来。无解中。 敏而好学，不耻下问—-训练营第7天 day13-14作业完成在google和其他同学的作业中寻找到答案，遇到两个大问题最终解决。1、matplot绘制图表在我的电脑中显示不出来。刚开始我以为代码没写对，后来用官方文档里的作业依然显示不出来。我才想到可能是其他问题，因为不自信，所以才会在代码上改了又改，耽误了时间，而真正问题不能解决。这是因为matplotlib的backend设置成了agg格式得在整个代码前加上 12import matplotlibmatplotlib.use（’TkAgg’) 而且要注意要在import matplotlib.pyplot前使用。2、微信返回数据乱码a.去fontplace下载SimHei字体，其他也可以。但网页打不开，我就选择了科学的方法，一次ok。b.把这个ttf文件手动添加到matplotlib的mpl_data里的tff文件夹里，这里都是已装字体。c.找到matplotlibrc文件，打开，这是不要害怕，直接找到font.sans-serif，在冒号后面打出：SimHei。关闭文件。在代码里添加 12from pylab import mplmpl.rcParams[‘font.sans-serif’] = [‘SimHei’] 事情到此，我的代码已经完全能显示了，并且中文也出来了。而且最重要的是通过此次的问题解决，让我对这次的作业代码非常熟悉，已经能变换地写出好几种相同功能的代码了。也算是有所收获。 最终的一天来到了，全部学完了训练营的任务，中间有困惑，有惊喜，最终收获的是满满的知识和弥足珍贵的自学体验，升级了自学的操作系统，对未来编程技能的使用充满了信心。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050017-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050017-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王晓镜学号：1901050017 工作背景中学老师 自我介绍我叫王晓镜。 学习python是想活在未来，用代码来为自己工作，用程序员思维来思考，用数据分析来判断形势和做出选择。 目前python入门营已学完，MIT课程自学已完成，正准备进入python进阶营学习。 我选择进入python入门营学习是做过最正确的选择，我发现与其说是学习写代码，不如说是如何学习程序员式思考方式。在紧张、有条不紊地14天学习过后，我看到了python的库的丰富，对于数据的抓取和可视化都不复杂，稍加学习就能掌握基本的数据读写和作出图表。但我知道代码易抄，背后却需要自己的思考和扎实的知识基础。我分析了自己对数据分析的兴趣，是源于想从看似复杂难辨的原始数据中找出事实，以让人一目了然的方式展现出来，从而基于事实作出判断。无论我的工作上还是业余生活上都非常需要这个技能，工作上我作为教务处老师，整天和成绩打交道，这是原始数据，并不需要抓取，但目前为止，只能用Excel展现学生成绩，而老师的教学质量和学生的成绩都无法关联，我先用python帮助自己；在其他方面，我想抓取我感兴趣的金融、时事数据并作出分析，这也需要python来帮助我。自学是可以的，但我在入门营体会到了自学社交的魅力，所以在开设进阶数据营后，我就来报名了。希望能让自己梳理好关于数据分析的系统思维，掌握数据分析的技能，随着学习的深入，对于自己想要的应用也许能更加细分化。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>中学老师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100009-自学是门手艺-第一部分的七个章节]]></title>
    <url>%2F%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA%2F1901100009-%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%9A%84%E4%B8%83%E4%B8%AA%E7%AB%A0%E8%8A%82%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100009 学习内容：《自学是门手艺》 学习用时：60min 学习笔记 刚刚完成14天自学营的学习。针对一些疑问也跟教练做了一些交流。了解到了学习Python早期就是要多看代码，多输入才能多输出。自学营毕业了算是入门了，后面几天继续阅读《自学是门手艺》以了解整本书的框架。 今天阅读了《自学是门手艺》的第一部分的七个章节。相比其他的计算机教程书，笑来老师的这本书阅读起来更加友好一些。了解了Python的一些最基本的知识。同时对自学营早期的一些作业内容，通过阅读书籍也多了一层理解。 很快理解函数从另外一个角度看只不过是 “程序员作为用户所使用的产品”。]]></content>
      <categories>
        <category>自学是门手艺</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010056-自学训练营学习1群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901010056-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A01%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 姓名：马林同学 学号：1901010056 学习内容：Python 14 天入门 学习用时：总用时110.2小时 学习笔记day1~day14的记录day1学习时长:7个小时 学习内容 创建了两个自己的代码仓库，学会使用branch 和pull requst 在Github的仓库提交issue 通过Github Desktop 将ma-hellow-world 仓库克隆到了本地电脑 将公共作业的仓库克隆到了本地电脑，在本地仓库的exercises目录下藏剑文件 通过Github桌面客户端将本第电脑的变更推送到自己的账户下的作业仓库 向远程作业仓库的master分支发起了pull request 收获 pull request are zhe heart of the collaboration shows diffs or differences of the content from both branch make adn commit changes 和open a pull request for changes to the develop和merge your pull request 在三个步骤在初期的时候搞不明白 认识了不少单词和句子 在找按钮的过程中，经常忽略下拉找找 对于一些难词很多的生词，可以直接字典翻译，提高效率 day2学习时长:7个小时 收获 锻炼自己，通过找、 问的方式去解决问题。 顺利下载并安装了Anaconda，并在其界面安装了VScode，Jupyter Notebook 和 JupyterLab. 在 vscode 中配置 Python 环境选择特定环境，应该输入“Python: Select Interpreter”进行选择。但一直没有对应的选项。通过糖总发总的issue链接找到答案。要搜索“language”——“Configure Display Language”——将”locale”:”en”修改为”locale”:”en-US”，保存。重启。 用jupiter note book 阅读笑来老师新书，被网页上的一个烟雾弹，所困住。经过助教点播，才解决，发现也不是大问题。 day3学习时长:4个小时 收获 在自己的编码器上跑出程序 由于认真看过笑来老师的新书，再结合google翻译，看起来英文文档还比较顺畅，但是一下子也没好好吸收 感悟 实际的操作代码很多都是可以从网上找到的。这对于初步阶段的我很有利用价值。 用好google和google 翻译，似乎没有什么事是解决不了的 day4学习时长:6个小时 遇到问题 当拿到题时，没有任何头绪。知道会用到条件判断和循环语句，但是不知道怎么用。最后在issue上解决了问题 在写代码时忘了加冒号，导致运行失败 在写while语句时，发现空格也非常重要，否则，程序是没办法成功的 感悟 细心也非常重要 把学的内容解释，可以在代码中加井号，解释出来，加深理解 day5学习时长:9.5个小时 学习内容 字符串的基本处理，将文本里的单词进行替换，剔除不想要的单词，翻转单词中的大小写字母 用字典统计字符串样本中英文单词出现的次数，按照出现次数从大到小进行排列，注意排除符号 将数组顺序进行翻转，用字符符串切片方式取出第三到第八个字符，将获得的字符进行翻转，将结果转化成整型，分别转化成二进制，八进制，十六进制 学习笑来老师书上的内容，知道了笑来老师书的代码是可以直接在lab上直接运行的操作，并且可以改着玩 将单词中包含ea的单词除去的时候，一开始参考用del但是后面的怎么跑都不成功。后来又参考另外几名同学的作业，和issue，才知道del 的用途一般用来删除数组中的一个元素，或者删除一个变量 感悟 day5的实用性很强，有四六级或者考研的所有的卷子text,就可以对里面所有的单词出现的频率进行统计，从而把时间都花在记忆高频率不会的单词上，只是最后转化成二进制，八进制，十六进制，暂时还不知道有什么用 在打代码的时候，需要注意冒号是否打了 可以把笑来老师的书提上日程上来，对于增加对python有很大帮助，上面的代码可以直接修改，对于无论是函数，数据类型，还是其中的逻辑关系的理解都又很大的帮助 程序跑错误后的提示，也至关重要，提示里的单词一定要明白意思 似乎是上点门道了。结合笑来老师的书，提供了很多的方便 day6学习时长:5个小时 学习内容 封装统计英文单词词频的函数。这个任务是基于昨天 的内容 封装统计中文汉字字频的函数，判断是不是汉字这个问题需要一定的时间 感悟 虽然作业时做下来了，但是作业里面还是有很多东西一知半解，无论是函数的运用，还是字符的形式，等等一系列内容都是需要加强训练的，都是需要时间和精力的投入才能慢慢上手的 已经完成的同学的作业也是有好有坏，有的非常的简洁，有的非常的繁琐，再参考的时候一定要多看几个，比较一下 day5的Python中的禅宗中的这句话”面对困惑，拒绝猜测的诱惑”给自己提了个醒，不要懒的查找就去猜测函数的功能或者不会的内容 day7学习时长:10.5个小时 感悟 冥想对于编程来说有很大的帮助，因为无论是调试一个程序，还是阅读一段自己理解的概念，都能够让自己很清楚很客观认识自己的现状，自己的处境，自己正在挣扎在一个怎样的问题上。缺乏元认知能力的话，很容易陷入低级的困惑当中，甚至即使过了很长时间自己的对问题的思考都得不到推进。 做题的时候，可以把笔记本就打开，遇到不会的问题，就敲到上面，遇到自己不熟悉的知识点就敲到上面。因为不会的都是需要自己加强的，所以敲一遍一点都不过分，甚至多敲几遍都不过分 在把笑来老师的part1再看一遍，发现这一部分需要多看几遍，不然不容易掌握，多看一遍对全局都有一个更深刻的理解 把对英文的词频和中文的字频包装成一个函数，需要的时候随时调用，这样真的剩了不少事 知识点总结 循环语句可能带有一个else子句；这个else子句它会在循环遍历完列表的时候被执行（另一种情况暂时没遇到先不讨论），但是不会在循环被break语句终止时被执行。 break 它也属于一个子句中的一个条件，表示跳出最近的for循环，（while没遇到暂时不讨论），控制流程往下跑。但是一种情况比较特殊就是往下跑的时候遇到else语句，此时else语句不被执行 琢磨流程控制中的break和continue需要时间多点。continue语句看官方文档稍微好理解，就是当条件被满足时，也就是continue被执行时，流程被控制往上跑，继续上面的循环 易错点 在mydouble文件夹的同级目录下，创建main.py文件。意思就文件夹mydouble和文件main.py都出现在同一个页面中，容易犯的误区就是，看到，一个文件夹，一个文件，想当然地认为这个文件就在文件夹里。 day8学习时长:3.7个小时 学习收获 Ctrl +Backspace是删除整个单词 Ctrl+左右移动键是光标来回在整个单词间跳动 Tab +右移动键 可以自动补全函数和前面已经输入过的字符 感悟 尝试一下，通过写的方式将自己的思想过程具体化，避免失去重点，让任务得不到推进。 一切提升效率的东西都要尽快第掌握 day9学习时长:11.5个小时 卡点 不知道怎么把VS code给玩坏了，以前的所有作业的程序都运行不了，但是发现前已经花了好多时间在上面这是第一个卡点，卡了我不少时间，最后在折腾不行，听教练的建议又重新安装了一遍，随后才正常运转 关于tang300.json路径的设置，我一直担忧是自己的运行系统是C盘，但是作业在D盘的原因，在参考前辈的作业，什么情况都有，况且每个人的路径都不一样，苦苦挣扎，也卡了不少时间，最后在YouTube上的相关视频找到启发，让程序给运行成功了 在找问题的时候，由把本地文件的仓库的文件位置给变动了，所以就是在desktop上费了点时间 感悟 累坏了，不过在通过自己的努力查找，让程序运行成功的一瞬间，感觉自己的真牛，差点都认怂了，幸好没放弃，充足的时间预算也相当重要， day 10学习时长:11个小时 下载完jieba不知道怎样安装，在issue上虽然有个方法，但是在终端输入指令根本不会，在教练逯彬杨的帮助下，又查阅相关的资料解决 程序死活运行不了，以前的做的有的也运行不了，教练协助，修改了部分代码，还是不行，尝试了，各种办法以后（有一个尝试把操作页面改成中文了），为下一步发现问题铺一步路，尝试到11点，和辅导员老白的聊天中，他提了一句，配置问题，然后第二天发现有一个bug确实是配置问题，以前做的能运行了 找不到路径问题，由于前段时间，一不小心玩坏了本地，删除了以后，导致路径发现问题，后来又把程序中的路径改了过来 程序运行找不到mydoule中的stats_world，最后索性都在后面加了一个数字，最后终于成功 感悟 做的时候，不知道是以前的坑，还是现在的坑在等着你，让你去跳，要做多就是找出坑，把它填平，确保自己不会掉下去。 时间预算也是非常重要的考虑因素，如果时间预算不充裕的话，做这个难度还确实不小 主动性也是一个十分重要的因素，卡到一个部分，查完后还一脸懵逼，就问一下，教练十分敬业的帮助你，旁敲侧击地地提醒你，都会帮你把作业给往下推进。但是，前提是，你的主动性得强，关键在你自己。 day11学习时长:20个小时 卡点 安装文档解析库，折腾了一波 用requests请求公众号文章连接，获取返回结果response,把微信公众号的正文提取出来 开通邮箱这个权限后，输入的不是邮箱密码而是授权码，而且输入的位置是在终端 最后是在自己的邮箱先测试，反复第想 感悟 里面的步骤一步一步来，一步成功后，在继续下面的步骤，比如print出来，看这一步成功后再进行一步，避免问题堆积 想起一首歌词，“这一路上走走停停，顺着少年漂流的痕迹”，因为事比较多，所以自学这个也是挺艰难的，这几天都是，做做停停，不过只要不放弃，就有机会，如果放弃了，那这件事肯定凉凉。 辅导员和教练，助教的存在真的很重要，虽然培养的是自学能力，但是如果只靠自己而不去向前辈请教，我自己肯定做不到并且极其容易放弃，我想很多人肯定也做不到，所以有什么困惑，多和他们交流交流，收获绝对是很大的 day12学习时长:5.5个小时 卡点 安装wxpy,显示需要升级pip，根据提示输入指令后，又出现安装环境错误，直接把错误复制，在百度中搜索后，根据简书上的提示，进行改写，又出现错误。然后发现，在升级pip 的时候的命令少写一个数字，填上后，错误消失，在cmd 中查看晒否安装wxpy成功，成功后继续下一步 在终端测试得回来的数据不显示 自动接受的文章，把参考资料的延申都大致看完后，参考实例代码，运行琢磨，发现需要，把最后的embed（）函数也剪切过来，才能检验前几段程序，可是还是没解决问题，又在网上转一圈后，在何教练的点播下，又改了一行代码，解决 文本出现了，但是，词频没出现，经过琢磨后， 发现把stats_word11名字，改一下，解决 感悟 在卡点三花费时间最长，最后教练一句话解决，教练的重要性，不言自明 作业是作业，但是相关的衍生工作，都够自己的琢磨一整子的，就比如今天的wxpy: 用 Python 玩微信 也刚好在室友的帮助下，调试很多遍成功，相关实用性的训练有时需要求助的不止一个人 经过这段时间的思考，认为，自学的常态是，碰到问题，明确问题，想办法解决问题。其中最为关键的是想办法解决问题，相关论坛的，内网和外网，教练们，等等，想各种渠道去解决问题。 day13学习时长:3.5个小时 卡点 参考matplotlib的资料，将day12中的结果生成一张图片，将演示代码直接复制能出现一样的图片结果&gt;现在想办法在这个代码改改，把day12的结果想办法引进来 将返回给好友的内容以表的形式出现，参考作业代码不行，通过百度，直接把上面的结果转化成list形式，可以返回给好友 感悟 day13新增的部分更像是一个工具，一个将表格转换成图片的工具，将里面的东西稍微变变型就能弄出自己的东西 day14学习时长:6个小时 感悟 这一路走过来，像极了过关的游戏的感觉，你会遇到各种各样的卡点，不要怕，那是进步过关的入口 最后还是要感谢教练、辅导员、助教的帮助和鼓励，才让我有能力、有信心、有勇气去与困难做斗争，去把时间当朋友，披荆斩浪，勇往直前。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010056-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010056-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：马林学号：1901010056 工作背景大学狗 自我介绍 自我介绍:有一年七个月时长的时间记录者，这个习惯加速了自己的进步，所以很多场合都很想说两句，希望大家可以一块时间记录，加速成长。最后也非常高兴认识大家，希望能互相学习，互相帮助，互相鼓励，共同进步。 我学习Python的目的目前是为了将来的工作加筹码，“独善其身”完了以后，希望可以“平天下”，哈哈说得有点大了，目前希望用途： 可以用在对Python领域工作岗位的分析上 对自己的两本时间记录数据的分析上 如果时间记录分析出的各项数据，能给自己带来清楚的认知以及未来计划的优良改善的话，我希望可以将功能落地，组建一个社群去帮助更多伙伴养成时间记录，分析时间记录的好习惯。 目前的学习阶段：Python入门营的学习内容，MIT入门课，Python相关书籍的阅读 疑惑：Python的细分领域下实际的工作内容有哪些？学员所学的内容有没有对平时的学习工作立即产生帮助的例子？]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>大学生</tag>
        <tag>农学专业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自学是门手艺(1.5.2)-Day18]]></title>
    <url>%2F%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA%2F1901050119-%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA-1-5-2-Day18%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901050119 学习内容：《自学是门手艺》- 1.5.2 值及其相应的运算 学习用时：1.5h 学习笔记收获总结先把书读厚再读薄，试着借用作者的视角，通过归纳、总结，复现每一部分内容的知识结构。最后，还要能再次把书读厚。如果能做到像作者那样去思考，那么，头脑中提炼出的知识结构就可以随时还原，就像根据目录检索正文一样。这样，一本书就彻底消化吸收了。 Daily Tips 这一章主要介绍了基础数据类型的运算细节。而除了基础数据类型，我们需要由它们组合起来的更多复杂数据类型。但无论数据的类型是什么，被操作符操作的总是该数据的值。 值是程序的基础成分（Building blocks） 常量的值就是它们字面所表达的值。变量必须先赋值才能使用，即，要先把一个值保存到变量中，它才能在其后被运算。 在 Python 中每个函数都有返回值，默认返回 None 既然有不同类型的数据，它们就分别对应着不同类型的值。通常相同类型的值才能相互运算。在不得不对不同类型的值进行运算之前，总是要事先做 Type Casting（类型转换）。 函数就相当于各种事先写好的子程序，给它传递一个值，它会对其进行运算，而后返回一个值（最起码返回一个 None）。 每个变量或者常量，除了它们的值之外，同时还相当于有一个对应的布尔值。]]></content>
      <categories>
        <category>自学是门手艺</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050119-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Galaxy学号：1901050119 工作背景全职妈妈+自由职业者 自我介绍先介绍一下我的个人经验基础。在填课前问卷的时候，我选的是学过一种语言，做过demo程序。其实，选这一项只是因为没有更贴切的选项。其实我学过好几种语言，只是没有一种达到精通的。 我很早就对编程感兴趣，然而，这个“早”只是相对的，事实上发现的有点晚，高考填志愿的时候我执拗地选择了物理专业，而后才发现新大陆……那又怎样，我是兴趣驱动型的，我要自学编程，我要考研转专业……所以，从本科开始学C语言，我就把学校发的清华那本教材翻来覆去学了很多遍，当时根本没想到可以多买几本书对照着看，直到后来参加工作用C语言写代码，也没想着添置新的参考书。不知道自己不知道的时候，真可怕！ 后来，我又执拗地按照自己的意愿行事，考了电路与系统专业的研究生，离计算机近了些，然后利用实习的机会，又自学C++，当然有“同事老师”可以咨询，学的应该还凑合，因为，当我应聘软件工程师的时候，如愿拿到两份外企的Offer，一个是北京的C++语言，一个是西安的C语言。后来，我去了西安的公司。大家做的不是从无到有的工作，只能算作模块化编程吧，在原有代码的基础上增添、修改功能，不需要自己搭建编程环境。所以，我那一本教材上的内容也够用了，因此也没长出新的本事，没有被迫学会整套技能。后来，也学了一些html、css、C#，但都比较肤浅，没有走得很远。究其原因，还是自己的操作系统太陈旧，而又不知道可以升级造成的。 那份工作持续了４年多，我辞职回家了，一边带孩子一边瞎折腾。直到《自学是门手艺》又让重新点燃了我的编程热情。这一次，不为给别人打工，就想掌握这门手艺，为己所用。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>全职妈妈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE1]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020043 学习内容：MIT 6.0001 LECTURE 1 +Python 编程导论（第2版）（第1章+第2章的2.1） 学习用时：4小时 学习笔记收获总结： Computers only know what you tell them. Computers only do what you tell them to do. 计算机能且只能做两件事——执行计算与保存计算结果(perform calculations and remember results)，但它把这两件事做到极致。 计算机思维： 七种关系：1.大和小 2.快和慢 3.多维度和单一维度 4.网络和个体 5.自顶向下和自底向上 6.全局和局部 7.成本和表现 两个原则：1.等价性原则 2.模块化原则 ——（吴军的谷歌方法论） 算法：是一个有穷指令序列，描述了这样一种计算过程，即在给定的输入集合中执行时，会按照一系列定义明确的状态进行，最终产生一个输出结果。（简单步骤，控制流，何时结束） 通用图灵机：可以接受任意一个图灵机 M 的编码 ，然后模拟 M 的运作。 邱奇-图灵论题：任何在算法上可计算的问题同样可由图灵机计算。（如果一个函数是可计算的，那么一定可以通过对图灵机进行编程实现这种计算。） 停机问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。 图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完备的。图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”,所有现代编程语言都是图灵完备的。 每种编程语言都有基本结构、语法、静态语义和语义。 Python的基本结构包括字面量和中缀操作符；语法定义了字符和符号组成句子的正确形式；静态语义定义了哪些语法有效的句子是有意义的；语义为每个语法正确又没有静态语义错误的句子关联一个含义。 程序如果没有正确运行，就应该表现出明显的错误。只要有可能，我们都应该以这种方式编写程序。 对象是Python程序处理的核心元素。Python有4类标量对象：int，float，bool，None 在Python中，变量仅是名称，没有其他意义（非常重要）。变量名可以包含大写字母、小写字母、数字（不能以数字开头）和特殊字符_，变量名称大小写敏感，保留字不能做变量名。 恰当的选择变量名和添加注释是提高程序可读性的好方法。 总结：看英文字幕虽然很难但是不会像中文字幕令人不舒服；明确计算机的边界，能做什么，不能做什么；学习计算机思维的相关知识很重要，得到有很多文章讲解，应该再看一些相关书籍；个人偏好一些概念的认真理解，会额外耗费很多时间，是否有用在以后的学习中会验证；养成好的编程习惯，先从变量名和注释开始；多输入代码，刻意练习的技巧可以考虑如何用在这里。 遇到的难点与问题（是否解决）：对停机问题的理解还不够，先放放，过一周再看。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part2)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part3)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D07 Part 3 作业:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学习 not in list 的写法 list去重的方法 enumerate 的使用 程序代码（完成提示功能）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. 返回目前还没有猜过的字母 ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef score_counter(guesses_remaining, secret_word): '''计算分数 guesses_remaining: 剩余可猜单词的次数 secret_word: 要猜测但单词 ''' return guesses_remaining * len(list(set(list(secret_word))))def hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' my_word = my_word.replace(' ', '') if len(my_word) == len(other_word): hidden_letters = [] for i,c in enumerate(my_word): if c == other_word[i]: continue elif c == '_': hidden_letters.append(other_word[i]) else: return False for hidden_letter in hidden_letters: if hidden_letter in my_word: return False return True else: return False def show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' my_word = my_word.replace(' ', '') possible_matches = [] for word in wordlist: if match_with_gaps(my_word, word): possible_matches.append(word) print(" ".join(possible_matches))def hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if letter == '*': print("Possible word matches are:") show_possible_matches(current_guessed_word) continue if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. # secret_word = choose_word(wordlist) # secret_word = 'else' # hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. secret_word = choose_word(wordlist) secret_word = 'tact' hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010000-MIT-自学 MIT 原版书 第三章]]></title>
    <url>%2FMIT60001%2F1901010000-MIT-%E8%87%AA%E5%AD%A6-MIT-%E5%8E%9F%E7%89%88%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901010000 学习内容：自学 MIT 原版书 第三章一些简单的数值程序/其他补充阅读材料 学习用时：60min 学习笔记 完成30天打卡后，首次来完成当周打卡任务。发现Python健脑最好别间隔太久，要不一回来看就又觉得有丢丢陌生 这章其实就还是在继续复习while循环和for循环的基本编写方式。喜欢书里的写法，每次讲解完程序就会写”有经验的程序员一般是这样做的”。里面有一个例子是程序会永远运行下去，因为循环体没有减少两个参数之前的差距。经验丰富的程序员经常会插入一些print语句，比如测试递减函数是否真的递减。 这也是优秀教练的教法，比如今天我看到蔡教练给姜翔发的google工程师的编写规范·。下面也也发给大家一起参考。 看到特别好玩的三个语录分享给大家一乐： 这个”电话”有太多缺点，没法当作真正的通信手段。这东西本身对我们没有价值。 ——西联公司1976年内部备忘录 我看全世界对计算机的需求量总共可能只有五台。 ——托马斯沃森，IBM董事长，1943年 没有任何理由能够证明，人人都想在家里拥有一台计算机。 ——肯奥尔森，DEC公司总裁和创始人，1977年]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-MIT-Python课-lecture 8]]></title>
    <url>%2FMIT60001%2F1901030012-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-lecture8notes37%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901030012 学习内容：MIT第8课视频文稿p7-8及幻灯片p12-13 学习用时：67min Notes no.: Day37 学习笔记 assigned vs. equal to So now we have sort of a nice class. It’s very simple, but we can start actually creating coordinate objects. So when you create coordinate objects, you’re creating instances of the class. So this line here, C is equal to coordinate 3,4, is going to call the init method. It’s going to call the init method with x is equal to 3 and y is equal to 4. Cat notes:Here when prof. “read” this piece of codes, “=” read as “equal to” however be aware of its actual specific meaning in Python, “=” means to assign or passing it all the variables, “==” means to check operational “equal to”, and also bear in mind about “!=” —not equal to, when using in arguments to demonstrate boolean operation. dot notionWe can access the data attributes using this dot notation and we’ve seen that before, right?When we’ve worked with lists we’d say something like, L dot append, right, when we create a list. So the same dot notation can be used with your own objects in order to access data attributes. So here, this is going to print 3 because the x value for object C is 3, and the next line, print origin x is going to print 0 because the x value for the object origin is 0. init methodWe have to find the init method so we have a way to create objects when we use the class. And then we can access the data attributes. But that’s kind of lame, right, because there isn’t anything cool we can do with it. add more methodsRemember methods are going to be procedural attributes that allow us to interact with our object. Methods are like functions except that there’s a couple of differences which you’ll see in a moment. eg: “distance”So notice this method is pretty much like a function, right? You have DF, some name, it takes in parameters. It does some stuff and then it returns a value. The only difference is the fact that you have a self here as the first thing and the fact that you always have to be conscious about whose data attributes you’re accessing. So you have to use the dot notation in order to decide whose data attributes you want access. So we’ve defined the method here, distance. Euclidean distance formulaSo here I’m going to just implement the Euclidean distance formula, which is x1 minus x2 squared, plus y1 minus y2 squared, and square root of all that. So that’s what I’m doing inside here. 12345678class Coordinate(object): def __init__(self, x, y): self.x = x self.y = y def distance(self, other): x_diff_sq = (self.x - other.x) ** 2 y_diff_sq = (self.y - other.y) ** 2 return (x_diff_sq + y_diff_sq) ** 0.5 Other than self and dot notation, methods behave like functions (take params, do operations, return) 我看到的时间和实践是最好的朋友，当和最好的朋友在一起的时候，人是真诚、充实、无需谎言的。我们的Camp给我们提供了默认的methods来让我们和自己最好的朋友尽可能的相处，我们也许还不知道default的缘由，但是，能使用到这些methods然后逐渐地通过一步一步的迈进能看到default以及缘由，我们自己就可以create我们的methods，与别人交流，供别人使用，我觉得我这次真的看到了希望。下一步是，build it up。感谢营友们的美好，这个世界有你们真好！！！加油！]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part1)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part1)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D05 Part 1 作业要求（简述）:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学会 not in list 的写法 程序代码（完成三个基本辅助函数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. secret_word = choose_word(wordlist) hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. #secret_word = choose_word(wordlist) #hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part2)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part2)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D06 Part 2 作业:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学习 not in list 的写法 list去重的方法 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. 返回目前还没有猜过的字母 ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef score_counter(guesses_remaining, secret_word): '''计算分数 guesses_remaining: 剩余可猜单词的次数 secret_word: 要猜测但单词 ''' return guesses_remaining * len(list(set(list(secret_word))))def hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. secret_word = choose_word(wordlist) secret_word = 'else' hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. #secret_word = choose_word(wordlist) #hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartB)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartC)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D04 Part C 作业要求（截取）:Part C: Finding the right amount to save away In Part B, you had a chance to explore how both the percentage of your salary that you save each month and your annual raise affect how long it takes you to save for a down payment. This is nice, but suppose you want to set a particular goal, e.g. to be able to afford the down payment in three years. How much should you save each month to achieve this? In this problem, you are going to write a program to answer that question. To simplify things, assume: Your semi­annual raise is .07 (7%) Your investments have an annual return of 0.04 (4%) The down payment is 0.25 (25%) of the cost of the house The cost of the house that you are saving for is $1M. You are now going to try to find the best rate of savings to achieve a down payment on a $1M house in 36 months. Since hitting this exactly is a challenge, we simply want your savings to be within $100 of the required down payment. In ps1c.py, write a program to calculate the best savings rate, as a function of your starting salary. You should use bisection search to help you do this efficiently. You should keep track of the number of steps it takes your bisections search to finish. You should be able to reuse some of the code you wrote for part B in this problem. Because we are searching for a value that is in principle a float, we are going to limit ourselves to two decimals of accuracy (i.e., we may want to save at 7.04% ­­ or 0.0704 in decimal – but we are not going to worry about the difference between 7.041% and 7.039%). This means we can search for an integer between 0 and 10000 (using integer division), and then convert it to a decimal percentage (using float division) to use when we are calculating the current_savings after 36 months. By using this range, there are only a finite number of numbers that we are searching over, as opposed to the infinite number of decimals between 0 and 1. This range will help prevent infinite loops. The reason we use 0 to 10000 is to account for two additional decimal places in the range 0% to 100%. Your code should print out a decimal (e.g. 0.0704 for 7.04%). Try different inputs for your starting salary, and see how the percentage you need to save changes to reach your desired down payment. Also keep in mind it may not be possible for to save a down payment in a year and a half for some salaries. In this case your function should notify the user that it is not possible to save for the down payment in 36 months with a print statement. Please make your program print results in the format shown in the test cases below. Note: There are multiple right ways to implement bisection search/number of steps so your results may not perfectly match those of the test case. 作业心得PartC的作业，根据以下前提条件，计算如果3年内要付首付，每月最优存款比例： 年薪涨幅是 .07 (7%) 投资年回报率是 0.04 (4%) 首付是总款的0.25(25%) 总款是1百万 有几点需要注意： 需要用到 bisection search 算法 每月存款比例保留小数点后两位，比如7.041%，使用浮点数表示为 0.0741，所以我们可以利用0-10000的整数来做算法计算，最后再转化为float 本次作业学习到以下知识点： 需要用到 bisection search 算法，可以参考以下链接：https://stackoverflow.com/questions/47196917/python-bisection-search-exercise python 在函数外定义变量，默认是全局变量，在函数中默认能够读取，但无法修改，参考：https://www.programiz.com/python-programming/global-keyword 程序逻辑引入了全局变量，显得不太优雅，仍有改善空间。 程序实现的时候，参考了一下连接：https://github.com/iamwhil/6.0001（运行结果与作业中的测试相符）https://github.com/kaizenflow/6.0001-ps1（无法得到正确的结果） 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 起始年薪annual_salary = 1500000# annual_salary = float(input("Enter the starting salary:"))# 房价total_cost = 1000000# 薪资涨幅semi_annual_raise = 0.07# 首付比例portion_down_payment = 0.25# 存款年化率R = 0.04deep = 0# 首付down_payment = total_cost * portion_down_paymentlast_portion_saved = Falsedef month_counter(current_savings, annual_salary, portion_saved): # 当前月份 month_count = 1 # while loop while True: # 当月情况判断 # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*R/12 # 如果存款 和 首付，相差不到100，也算达成条件 if current_savings &gt;= down_payment: break if month_count % 6 == 0: annual_salary += annual_salary * semi_annual_raise # 月份自增 month_count += 1 return [month_count, current_savings]def bisection_search(portion_saved_rates, annual_salary): global last_portion_saved global deep deep += 1 # 计算中位数，【//】 符合表示除法的商是整数 if len(portion_saved_rates) == 1: return last_portion_saved middle = len(portion_saved_rates) // 2 portion_saved = portion_saved_rates[middle] / 10000 init_current_savings = 0 # 如何计算的月份与预期相等 res = month_counter(init_current_savings, annual_salary, portion_saved) month_count = res[0] current_savings = res[1] # print(portion_saved_rates, month_count, current_savings, portion_saved, abs(current_savings - down_payment)) if month_count == month_count_expect: last_portion_saved = portion_saved_rates[middle] if abs(current_savings - down_payment) &gt; 100: return bisection_search(portion_saved_rates[:middle], annual_salary) else: return portion_saved_rates[middle] elif month_count &gt; month_count_expect: # 计算的月份比期望的大，说明存款比例少了,要提升比例 # print(portion_saved_rates[:middle]) return bisection_search(portion_saved_rates[middle:], annual_salary) else: return bisection_search(portion_saved_rates[:middle], annual_salary)portion_saved_rates = range(0, 10000)month_count_expect = 36res = bisection_search(portion_saved_rates, annual_salary)if res is False: print("It is not possible to pay the down payment in three years.")else: print("Best savings rate: &#123;&#125;".format(res/10000)) print(res/10000) print("Steps in bisection search: &#123;&#125;".format(deep))]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartB)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartB)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D03 Part A 作业要求（截取）:Part B: Saving, with a raise Background In Part A, we unrealistically assumed that your salary didn’t change. But you are an MIT graduate, and clearly you are going to be worth more to your company over time! So we are going to build on your solution to Part A by factoring in a raise every six months. In ps1b.py, copy your solution to Part A (as we are going to reuse much of that machinery). Modify your program to include the following Have the user input a semi-annual salary raise semi_annual_raise (as a decimal percentage) After the 6 th month, increase your salary by that percentage. Do the same after the 12 th month, the 18 th month, and so on. Write a program to calculate how many months it will take you save up enough money for a down payment. LIke before, assume that your investments earn a return of r = 0.04 (or 4%) and the required down payment percentage is 0.25 (or 25%). Have the user enter the following variables: The starting annual salary (annual_salary) The percentage of salary to be saved (portion_saved) The cost of your dream home (total_cost) The semi­annual salary raise (semi_annual_raise) 作业心得PartB的作业其实和PartA的整体思路差不多，主要是增加了一个变动收入，没6个月加薪 写一个程序用于计算 需要多少个月储蓄才够首付，大多数变量都需要float类型，所以需要将用户的输入转化为float，程序需要用户输入以下变量：: 一开始的年薪 (annual_salary) 每月存款的比例 (portion_saved) 房子的价钱 (total_cost) 提薪的比率（semi_annual_raise） 整体的思路就是做一个循环，每个迭代就是一个月，判断当月 的存款是否大于等于首付。存款由三部分组成： 已有存款 月薪按比例存款；月薪每6个月有涨幅（这里是重点，原文是after 6th month，也就是第7个月薪资变动才生效，而不是第6个月） 每月投资回报 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 起始年薪# annual_salary = 75000annual_salary = float(input("Enter your annual salary:"))# 每月薪资存款比例# portion_saved = .05portion_saved = float(input("Enter the percent of your salary to save, as a decimal:"))# 房价# total_cost = 1500000total_cost = float(input("Enter the cost of your dream home:"))# 薪资涨幅# semi_annual_raise = 0.05semi_annual_raise = float(input("The semi­annual salary raise:"))# 首付比例portion_down_payment = 0.25# 存款年化率r = 0.04# 当前存款current_savings = 0# 当前月份month_count = 1# 首付down_payment = total_cost * portion_down_payment# while loopwhile True: # 当月情况判断 # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*r/12 # print("第&#123;&#125;个月，薪水&#123;&#125;，存款&#123;&#125;，首付&#123;&#125;".format(month_count, annual_salary, current_savings, down_payment)) if current_savings &gt;= down_payment: print("Number of months: &#123;&#125;".format(month_count)) break if month_count % 6 == 0: annual_salary += annual_salary * semi_annual_raise # 月份自增 month_count += 1]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartA)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartA)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D02 Part A 作业要求（截取）:Part A: House Hunting You have graduated from MIT and now have a great job! You move to the San Francisco Bay Area and decide that you want to start saving to buy a house. As housing prices are very high in the Bay Area, you realize you are going to have to save for several years before you can afford to make the down payment on a house. In Part A, we are going to determine how long it will take you to save enough money to make the down payment given the following assumptions: Call the cost of your dream home total_cost. Call the portion of the cost needed for a down payment portion_down_payment. For simplicity, assume that portion_down_payment = 0.25 (25%). Call the amount that you have saved thus far current_savings. You start with a current savings of $0. Assume that you invest your current savings wisely, with an annual return of r (in other words, at the end of each month, you receive an additional current_savings*r/12 funds to put into your savings – the 12 is because r is an annual rate). Assume that your investments earn a return of r = 0.04 (4%). Assume your annual salary is annual_salary. Assume you are going to dedicate a certain amount of your salary each month to saving for the down payment. Call that portion_saved. This variable should be in decimal form (i.e. 0.1 for 10%). At the end of each month, your savings will be increased by the return on your investment, plus a percentage of your monthly salary (annual salary / 12). Write a program to calculate how many months it will take you to save up enough money for a down payment. You will want your main variables to be floats, so you should cast user inputs to floats. Your program should ask the user to enter the following variables: The starting annual salary (annual_salary) The portion of salary to be saved (portion_saved) The cost of your dream home (total_cost) 作业心得光看懂英文作业已经蛮吃力了，哈哈，简化作业说明如下： 买房子的总费用为 total_cost 首付（down payment）为25%, portion_down_payment = 0.25 存款为 current_savings，从0开始 存款有投资，年回报率（an annual return）为r（0.04），所以每月额外收入为 current_savings*r/12 年薪为 annual_salary 从每月薪资中，固定比例用于首付，这个比率设为 portion_saved 每个月的收入来源，主要是 投资回报 + 每月工资 monthly salary（annual salary / 12） 写一个程序用于计算 需要多少个月储蓄才够首付，大多数变量都需要float类型，所以需要将用户的输入转化为float，程序需要用户输入以下变量：: 一开始的年薪 (annual_salary) 每月存款的比例 (portion_saved) 房子的价钱 (total_cost) 整体的思路就是做一个循环，每个迭代就是一个月，判断当月 的存款是否大于等于首付。 存款由三部分组成： 已有存款 月薪按比例存款 每月投资回报 程序代码# 起始年薪 # annual_salary = 120000 annual_salary = float(input("Enter your annual salary:")) # 每月薪资存款比例 # portion_saved = .10 portion_saved = float(input("Enter the percent of your salary to save, as a decimal:")) # 房价 # total_cost = 1000000 total_cost = float(input("Enter the cost of your dream home:")) # 首付比例 portion_down_payment = 0.25 # 存款年化率 r = 0.04 # 当前存款 current_savings = 0 month_count = 1 # 首付 down_payment = total_cost * portion_down_payment while True: # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*r/12 if current_savings &gt;= down_payment: print("Number of months: {}".format(month_count)) break # 月份自增 month_count += 1]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet0]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet0%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 0 (ZIP - 2.0MB) 打卡天数：D01 作业要求（简述）:Write a program that does the following in order: Asks the user to enter a number “x”; Asks the user to enter a number “y”; Prints out number “x”, raised to the power “y”. Prints out the log (base 2) of “x”. Use Spyder to create your program, and save your code in a file named ‘ps0.py’. An example of an interaction with your program is shown below. The words printed in blue are ones the computer should print, based on your commands, while the words in black are an example of a user’s input. The colors are simply here to help you distinguish the two components. 1234Enter number x: 2 Enter number y: 3 X**y = 8log(x) = 1 作业心得根据提示，本章作业涉及的知识点如下： print / input 函数的使用，可以参考以下文章 input()函数 print()函数 python中的基础数学运算，pow函数; math库的math.pow/log2函数 pow()函数 math.log2()函数 math.pow()函数 numpy库的log2函数 https://docs.scipy.org/doc/numpy/reference/generated/numpy.log2.html 程序的实现过程中，遇到几点需要注意的： input函数返回的是str类型，需要通过int函数转化才能进行运算，否则会报错 TypeError: unsupported operand type(s) for ** or pow(): ‘str’ and ‘int’” 一般的数据计算，math库也足够了，numpy提供了更多更方便的函数 程序代码1234567891011import mathimport numpy# 因为要参与计算，所以需要使用int函数来转化x = int(input("Enter number x:"))y = int(input("Enter number y:"))# 使用内置函数和math库来实现程序print("x**y = &#123;&#125;\nlog(x) = &#123;&#125;".format(pow(x, y), int(math.log2(x))))# 使用numpy库来实现程序print("x**y = &#123;&#125;\nlog(x) = &#123;&#125;".format(numpy.power(x, y), int(numpy.log2(x))))]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
</search>
